{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Registry = require('../../registry');\nvar getTraceColor = require('./get_trace_color');\nvar Color = require('../../components/color');\nvar fillText = Lib.fillText;\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var xpx = xa.c2p(xval);\n  var ypx = ya.c2p(yval);\n  var pt = [xpx, ypx];\n  var hoveron = trace.hoveron || '';\n  var minRad = trace.mode.indexOf('markers') !== -1 ? 3 : 0.5;\n  var xPeriod = !!trace.xperiodalignment;\n  var yPeriod = !!trace.yperiodalignment;\n\n  // look for points to hover on first, then take fills only if we\n  // didn't find a point\n\n  if (hoveron.indexOf('points') !== -1) {\n    // dx and dy are used in compare modes - here we want to always\n    // prioritize the closest data point, at least as long as markers are\n    // the same size or nonexistent, but still try to prioritize small markers too.\n    var dx = function (di) {\n      if (xPeriod) {\n        var x0 = xa.c2p(di.xStart);\n        var x1 = xa.c2p(di.xEnd);\n        return xpx >= Math.min(x0, x1) && xpx <= Math.max(x0, x1) ? 0 : Infinity;\n      }\n      var rad = Math.max(3, di.mrc || 0);\n      var kink = 1 - 1 / rad;\n      var dxRaw = Math.abs(xa.c2p(di.x) - xpx);\n      return dxRaw < rad ? kink * dxRaw / rad : dxRaw - rad + kink;\n    };\n    var dy = function (di) {\n      if (yPeriod) {\n        var y0 = ya.c2p(di.yStart);\n        var y1 = ya.c2p(di.yEnd);\n        return ypx >= Math.min(y0, y1) && ypx <= Math.max(y0, y1) ? 0 : Infinity;\n      }\n      var rad = Math.max(3, di.mrc || 0);\n      var kink = 1 - 1 / rad;\n      var dyRaw = Math.abs(ya.c2p(di.y) - ypx);\n      return dyRaw < rad ? kink * dyRaw / rad : dyRaw - rad + kink;\n    };\n\n    // scatter points: d.mrc is the calculated marker radius\n    // adjust the distance so if you're inside the marker it\n    // always will show up regardless of point size, but\n    // prioritize smaller points\n    var dxy = function (di) {\n      var rad = Math.max(minRad, di.mrc || 0);\n      var dx = xa.c2p(di.x) - xpx;\n      var dy = ya.c2p(di.y) - ypx;\n      return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - minRad / rad);\n    };\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if (pointData.index !== false) {\n      // the closest data point\n      var di = cd[pointData.index];\n      var xc = xa.c2p(di.x, true);\n      var yc = ya.c2p(di.y, true);\n      var rad = di.mrc || 1;\n\n      // now we're done using the whole `calcdata` array, replace the\n      // index with the original index (in case of inserted point from\n      // stacked area)\n      pointData.index = di.i;\n      var orientation = cd[0].t.orientation;\n      // TODO: for scatter and bar, option to show (sub)totals and\n      // raw data? Currently stacked and/or normalized bars just show\n      // the normalized individual sizes, so that's what I'm doing here\n      // for now.\n      var sizeVal = orientation && (di.sNorm || di.s);\n      var xLabelVal = orientation === 'h' ? sizeVal : di.orig_x !== undefined ? di.orig_x : di.x;\n      var yLabelVal = orientation === 'v' ? sizeVal : di.orig_y !== undefined ? di.orig_y : di.y;\n      Lib.extendFlat(pointData, {\n        color: getTraceColor(trace, di),\n        x0: xc - rad,\n        x1: xc + rad,\n        xLabelVal: xLabelVal,\n        y0: yc - rad,\n        y1: yc + rad,\n        yLabelVal: yLabelVal,\n        spikeDistance: dxy(di),\n        hovertemplate: trace.hovertemplate\n      });\n      fillText(di, trace, pointData);\n      Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n      return [pointData];\n    }\n  }\n\n  // even if hoveron is 'fills', only use it if we have polygons too\n  if (hoveron.indexOf('fills') !== -1 && trace._polygons) {\n    var polygons = trace._polygons;\n    var polygonsIn = [];\n    var inside = false;\n    var xmin = Infinity;\n    var xmax = -Infinity;\n    var ymin = Infinity;\n    var ymax = -Infinity;\n    var i, j, polygon, pts, xCross, x0, x1, y0, y1;\n    for (i = 0; i < polygons.length; i++) {\n      polygon = polygons[i];\n      // TODO: this is not going to work right for curved edges, it will\n      // act as though they're straight. That's probably going to need\n      // the elements themselves to capture the events. Worth it?\n      if (polygon.contains(pt)) {\n        inside = !inside;\n        // TODO: need better than just the overall bounding box\n        polygonsIn.push(polygon);\n        ymin = Math.min(ymin, polygon.ymin);\n        ymax = Math.max(ymax, polygon.ymax);\n      }\n    }\n    if (inside) {\n      // constrain ymin/max to the visible plot, so the label goes\n      // at the middle of the piece you can see\n      ymin = Math.max(ymin, 0);\n      ymax = Math.min(ymax, ya._length);\n\n      // find the overall left-most and right-most points of the\n      // polygon(s) we're inside at their combined vertical midpoint.\n      // This is where we will draw the hover label.\n      // Note that this might not be the vertical midpoint of the\n      // whole trace, if it's disjoint.\n      var yAvg = (ymin + ymax) / 2;\n      for (i = 0; i < polygonsIn.length; i++) {\n        pts = polygonsIn[i].pts;\n        for (j = 1; j < pts.length; j++) {\n          y0 = pts[j - 1][1];\n          y1 = pts[j][1];\n          if (y0 > yAvg !== y1 >= yAvg) {\n            x0 = pts[j - 1][0];\n            x1 = pts[j][0];\n            if (y1 - y0) {\n              xCross = x0 + (x1 - x0) * (yAvg - y0) / (y1 - y0);\n              xmin = Math.min(xmin, xCross);\n              xmax = Math.max(xmax, xCross);\n            }\n          }\n        }\n      }\n\n      // constrain xmin/max to the visible plot now too\n      xmin = Math.max(xmin, 0);\n      xmax = Math.min(xmax, xa._length);\n\n      // get only fill or line color for the hover color\n      var color = Color.defaultLine;\n      if (Color.opacity(trace.fillcolor)) color = trace.fillcolor;else if (Color.opacity((trace.line || {}).color)) {\n        color = trace.line.color;\n      }\n      Lib.extendFlat(pointData, {\n        // never let a 2D override 1D type as closest point\n        // also: no spikeDistance, it's not allowed for fills\n        distance: pointData.maxHoverDistance,\n        x0: xmin,\n        x1: xmax,\n        y0: yAvg,\n        y1: yAvg,\n        color: color,\n        hovertemplate: false\n      });\n      delete pointData.index;\n      if (trace.text && !Array.isArray(trace.text)) {\n        pointData.text = String(trace.text);\n      } else pointData.text = trace.name;\n      return [pointData];\n    }\n  }\n};","map":{"version":3,"names":["Lib","require","Fx","Registry","getTraceColor","Color","fillText","module","exports","hoverPoints","pointData","xval","yval","hovermode","cd","trace","xa","ya","xpx","c2p","ypx","pt","hoveron","minRad","mode","indexOf","xPeriod","xperiodalignment","yPeriod","yperiodalignment","dx","di","x0","xStart","x1","xEnd","Math","min","max","Infinity","rad","mrc","kink","dxRaw","abs","x","dy","y0","yStart","y1","yEnd","dyRaw","y","dxy","sqrt","distfn","getDistanceFunction","getClosest","index","xc","yc","i","orientation","t","sizeVal","sNorm","s","xLabelVal","orig_x","undefined","yLabelVal","orig_y","extendFlat","color","spikeDistance","hovertemplate","getComponentMethod","_polygons","polygons","polygonsIn","inside","xmin","xmax","ymin","ymax","j","polygon","pts","xCross","length","contains","push","_length","yAvg","defaultLine","opacity","fillcolor","line","distance","maxHoverDistance","text","Array","isArray","String","name"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/traces/scatter/hover.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Registry = require('../../registry');\nvar getTraceColor = require('./get_trace_color');\nvar Color = require('../../components/color');\nvar fillText = Lib.fillText;\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var xpx = xa.c2p(xval);\n    var ypx = ya.c2p(yval);\n    var pt = [xpx, ypx];\n    var hoveron = trace.hoveron || '';\n    var minRad = (trace.mode.indexOf('markers') !== -1) ? 3 : 0.5;\n\n    var xPeriod = !!trace.xperiodalignment;\n    var yPeriod = !!trace.yperiodalignment;\n\n    // look for points to hover on first, then take fills only if we\n    // didn't find a point\n\n    if(hoveron.indexOf('points') !== -1) {\n        // dx and dy are used in compare modes - here we want to always\n        // prioritize the closest data point, at least as long as markers are\n        // the same size or nonexistent, but still try to prioritize small markers too.\n        var dx = function(di) {\n            if(xPeriod) {\n                var x0 = xa.c2p(di.xStart);\n                var x1 = xa.c2p(di.xEnd);\n\n                return (\n                    xpx >= Math.min(x0, x1) &&\n                    xpx <= Math.max(x0, x1)\n                ) ? 0 : Infinity;\n            }\n\n            var rad = Math.max(3, di.mrc || 0);\n            var kink = 1 - 1 / rad;\n            var dxRaw = Math.abs(xa.c2p(di.x) - xpx);\n            return (dxRaw < rad) ? (kink * dxRaw / rad) : (dxRaw - rad + kink);\n        };\n        var dy = function(di) {\n            if(yPeriod) {\n                var y0 = ya.c2p(di.yStart);\n                var y1 = ya.c2p(di.yEnd);\n\n                return (\n                    ypx >= Math.min(y0, y1) &&\n                    ypx <= Math.max(y0, y1)\n                ) ? 0 : Infinity;\n            }\n\n            var rad = Math.max(3, di.mrc || 0);\n            var kink = 1 - 1 / rad;\n            var dyRaw = Math.abs(ya.c2p(di.y) - ypx);\n            return (dyRaw < rad) ? (kink * dyRaw / rad) : (dyRaw - rad + kink);\n        };\n\n        // scatter points: d.mrc is the calculated marker radius\n        // adjust the distance so if you're inside the marker it\n        // always will show up regardless of point size, but\n        // prioritize smaller points\n        var dxy = function(di) {\n            var rad = Math.max(minRad, di.mrc || 0);\n            var dx = xa.c2p(di.x) - xpx;\n            var dy = ya.c2p(di.y) - ypx;\n            return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - minRad / rad);\n        };\n        var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n\n        Fx.getClosest(cd, distfn, pointData);\n\n        // skip the rest (for this trace) if we didn't find a close point\n        if(pointData.index !== false) {\n            // the closest data point\n            var di = cd[pointData.index];\n            var xc = xa.c2p(di.x, true);\n            var yc = ya.c2p(di.y, true);\n            var rad = di.mrc || 1;\n\n            // now we're done using the whole `calcdata` array, replace the\n            // index with the original index (in case of inserted point from\n            // stacked area)\n            pointData.index = di.i;\n\n            var orientation = cd[0].t.orientation;\n            // TODO: for scatter and bar, option to show (sub)totals and\n            // raw data? Currently stacked and/or normalized bars just show\n            // the normalized individual sizes, so that's what I'm doing here\n            // for now.\n            var sizeVal = orientation && (di.sNorm || di.s);\n            var xLabelVal = (orientation === 'h') ? sizeVal : di.orig_x !== undefined ? di.orig_x : di.x;\n            var yLabelVal = (orientation === 'v') ? sizeVal : di.orig_y !== undefined ? di.orig_y : di.y;\n\n            Lib.extendFlat(pointData, {\n                color: getTraceColor(trace, di),\n\n                x0: xc - rad,\n                x1: xc + rad,\n                xLabelVal: xLabelVal,\n\n                y0: yc - rad,\n                y1: yc + rad,\n                yLabelVal: yLabelVal,\n\n                spikeDistance: dxy(di),\n                hovertemplate: trace.hovertemplate\n            });\n\n            fillText(di, trace, pointData);\n            Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n\n            return [pointData];\n        }\n    }\n\n    // even if hoveron is 'fills', only use it if we have polygons too\n    if(hoveron.indexOf('fills') !== -1 && trace._polygons) {\n        var polygons = trace._polygons;\n        var polygonsIn = [];\n        var inside = false;\n        var xmin = Infinity;\n        var xmax = -Infinity;\n        var ymin = Infinity;\n        var ymax = -Infinity;\n\n        var i, j, polygon, pts, xCross, x0, x1, y0, y1;\n\n        for(i = 0; i < polygons.length; i++) {\n            polygon = polygons[i];\n            // TODO: this is not going to work right for curved edges, it will\n            // act as though they're straight. That's probably going to need\n            // the elements themselves to capture the events. Worth it?\n            if(polygon.contains(pt)) {\n                inside = !inside;\n                // TODO: need better than just the overall bounding box\n                polygonsIn.push(polygon);\n                ymin = Math.min(ymin, polygon.ymin);\n                ymax = Math.max(ymax, polygon.ymax);\n            }\n        }\n\n        if(inside) {\n            // constrain ymin/max to the visible plot, so the label goes\n            // at the middle of the piece you can see\n            ymin = Math.max(ymin, 0);\n            ymax = Math.min(ymax, ya._length);\n\n            // find the overall left-most and right-most points of the\n            // polygon(s) we're inside at their combined vertical midpoint.\n            // This is where we will draw the hover label.\n            // Note that this might not be the vertical midpoint of the\n            // whole trace, if it's disjoint.\n            var yAvg = (ymin + ymax) / 2;\n            for(i = 0; i < polygonsIn.length; i++) {\n                pts = polygonsIn[i].pts;\n                for(j = 1; j < pts.length; j++) {\n                    y0 = pts[j - 1][1];\n                    y1 = pts[j][1];\n                    if((y0 > yAvg) !== (y1 >= yAvg)) {\n                        x0 = pts[j - 1][0];\n                        x1 = pts[j][0];\n                        if(y1 - y0) {\n                            xCross = x0 + (x1 - x0) * (yAvg - y0) / (y1 - y0);\n                            xmin = Math.min(xmin, xCross);\n                            xmax = Math.max(xmax, xCross);\n                        }\n                    }\n                }\n            }\n\n            // constrain xmin/max to the visible plot now too\n            xmin = Math.max(xmin, 0);\n            xmax = Math.min(xmax, xa._length);\n\n            // get only fill or line color for the hover color\n            var color = Color.defaultLine;\n            if(Color.opacity(trace.fillcolor)) color = trace.fillcolor;\n            else if(Color.opacity((trace.line || {}).color)) {\n                color = trace.line.color;\n            }\n\n            Lib.extendFlat(pointData, {\n                // never let a 2D override 1D type as closest point\n                // also: no spikeDistance, it's not allowed for fills\n                distance: pointData.maxHoverDistance,\n                x0: xmin,\n                x1: xmax,\n                y0: yAvg,\n                y1: yAvg,\n                color: color,\n                hovertemplate: false\n            });\n\n            delete pointData.index;\n\n            if(trace.text && !Array.isArray(trace.text)) {\n                pointData.text = String(trace.text);\n            } else pointData.text = trace.name;\n\n            return [pointData];\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}