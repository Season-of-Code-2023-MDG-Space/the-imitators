{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar Titles = require('../titles');\nvar Cartesian = require('../../plots/cartesian');\nvar axisIDs = require('../../plots/cartesian/axis_ids');\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\nvar constants = require('./constants');\nmodule.exports = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var rangeSliderData = fullLayout._rangeSliderData;\n  for (var i = 0; i < rangeSliderData.length; i++) {\n    var opts = rangeSliderData[i][constants.name];\n    // fullLayout._uid may not exist when we call makeData\n    opts._clipId = opts._id + '-' + fullLayout._uid;\n  }\n\n  /*\n   * <g container />\n   *  <rect bg />\n   *  < .... range plot />\n   *  <rect mask-min />\n   *  <rect mask-max />\n   *  <rect slidebox />\n   *  <g grabber-min />\n   *      <rect handle-min />\n   *      <rect grabare-min />\n   *  <g grabber-max />\n   *      <rect handle-max />\n   *      <rect grabare-max />\n   *\n   *  ...\n   */\n\n  function keyFunction(axisOpts) {\n    return axisOpts._name;\n  }\n  var rangeSliders = fullLayout._infolayer.selectAll('g.' + constants.containerClassName).data(rangeSliderData, keyFunction);\n\n  // remove exiting sliders and their corresponding clip paths\n  rangeSliders.exit().each(function (axisOpts) {\n    var opts = axisOpts[constants.name];\n    fullLayout._topdefs.select('#' + opts._clipId).remove();\n  }).remove();\n\n  // return early if no range slider is visible\n  if (rangeSliderData.length === 0) return;\n  rangeSliders.enter().append('g').classed(constants.containerClassName, true).attr('pointer-events', 'all');\n\n  // for all present range sliders\n  rangeSliders.each(function (axisOpts) {\n    var rangeSlider = d3.select(this);\n    var opts = axisOpts[constants.name];\n    var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];\n    var oppAxisRangeOpts = opts[axisIDs.id2name(axisOpts.anchor)];\n\n    // update range\n    // Expand slider range to the axis range\n    if (opts.range) {\n      var rng = Lib.simpleMap(opts.range, axisOpts.r2l);\n      var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);\n      var newRng;\n      if (axRng[0] < axRng[1]) {\n        newRng = [Math.min(rng[0], axRng[0]), Math.max(rng[1], axRng[1])];\n      } else {\n        newRng = [Math.max(rng[0], axRng[0]), Math.min(rng[1], axRng[1])];\n      }\n      opts.range = opts._input.range = Lib.simpleMap(newRng, axisOpts.l2r);\n    }\n    axisOpts.cleanRange('rangeslider.range');\n\n    // update range slider dimensions\n\n    var gs = fullLayout._size;\n    var domain = axisOpts.domain;\n    opts._width = gs.w * (domain[1] - domain[0]);\n    var x = Math.round(gs.l + gs.w * domain[0]);\n    var y = Math.round(gs.t + gs.h * (1 - axisOpts._counterDomainMin) + (axisOpts.side === 'bottom' ? axisOpts._depth : 0) + opts._offsetShift + constants.extraPad);\n    rangeSlider.attr('transform', strTranslate(x, y));\n\n    // update data <--> pixel coordinate conversion methods\n\n    opts._rl = Lib.simpleMap(opts.range, axisOpts.r2l);\n    var rl0 = opts._rl[0];\n    var rl1 = opts._rl[1];\n    var drl = rl1 - rl0;\n    opts.p2d = function (v) {\n      return v / opts._width * drl + rl0;\n    };\n    opts.d2p = function (v) {\n      return (v - rl0) / drl * opts._width;\n    };\n    if (axisOpts.rangebreaks) {\n      var rsBreaks = axisOpts.locateBreaks(rl0, rl1);\n      if (rsBreaks.length) {\n        var j, brk;\n        var lBreaks = 0;\n        for (j = 0; j < rsBreaks.length; j++) {\n          brk = rsBreaks[j];\n          lBreaks += brk.max - brk.min;\n        }\n\n        // TODO fix for reversed-range axes !!!\n\n        // compute slope and piecewise offsets\n        var m2 = opts._width / (rl1 - rl0 - lBreaks);\n        var _B = [-m2 * rl0];\n        for (j = 0; j < rsBreaks.length; j++) {\n          brk = rsBreaks[j];\n          _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));\n        }\n        opts.d2p = function (v) {\n          var b = _B[0];\n          for (var j = 0; j < rsBreaks.length; j++) {\n            var brk = rsBreaks[j];\n            if (v >= brk.max) b = _B[j + 1];else if (v < brk.min) break;\n          }\n          return b + m2 * v;\n        };\n\n        // fill pixel (i.e. 'p') min/max here,\n        // to not have to loop through the _rangebreaks twice during `p2d`\n        for (j = 0; j < rsBreaks.length; j++) {\n          brk = rsBreaks[j];\n          brk.pmin = opts.d2p(brk.min);\n          brk.pmax = opts.d2p(brk.max);\n        }\n        opts.p2d = function (v) {\n          var b = _B[0];\n          for (var j = 0; j < rsBreaks.length; j++) {\n            var brk = rsBreaks[j];\n            if (v >= brk.pmax) b = _B[j + 1];else if (v < brk.pmin) break;\n          }\n          return (v - b) / m2;\n        };\n      }\n    }\n    if (oppAxisRangeOpts.rangemode !== 'match') {\n      var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);\n      var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);\n      var distOppAxis = range1OppAxis - range0OppAxis;\n      opts.d2pOppAxis = function (v) {\n        return (v - range0OppAxis) / distOppAxis * opts._height;\n      };\n    }\n\n    // update inner nodes\n\n    rangeSlider.call(drawBg, gd, axisOpts, opts).call(addClipPath, gd, axisOpts, opts).call(drawRangePlot, gd, axisOpts, opts).call(drawMasks, gd, axisOpts, opts, oppAxisRangeOpts).call(drawSlideBox, gd, axisOpts, opts).call(drawGrabbers, gd, axisOpts, opts);\n\n    // setup drag element\n    setupDragElement(rangeSlider, gd, axisOpts, opts);\n\n    // update current range\n    setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts);\n\n    // title goes next to range slider instead of tick labels, so\n    // just take it over and draw it from here\n    if (axisOpts.side === 'bottom') {\n      Titles.draw(gd, axisOpts._id + 'title', {\n        propContainer: axisOpts,\n        propName: axisOpts._name + '.title',\n        placeholder: fullLayout._dfltTitle.x,\n        attributes: {\n          x: axisOpts._offset + axisOpts._length / 2,\n          y: y + opts._height + opts._offsetShift + 10 + 1.5 * axisOpts.title.font.size,\n          'text-anchor': 'middle'\n        }\n      });\n    }\n  });\n};\nfunction setupDragElement(rangeSlider, gd, axisOpts, opts) {\n  if (gd._context.staticPlot) return;\n  var slideBox = rangeSlider.select('rect.' + constants.slideBoxClassName).node();\n  var grabAreaMin = rangeSlider.select('rect.' + constants.grabAreaMinClassName).node();\n  var grabAreaMax = rangeSlider.select('rect.' + constants.grabAreaMaxClassName).node();\n  function mouseDownHandler() {\n    var event = d3.event;\n    var target = event.target;\n    var startX = event.clientX || event.touches[0].clientX;\n    var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;\n    var minVal = opts.d2p(axisOpts._rl[0]);\n    var maxVal = opts.d2p(axisOpts._rl[1]);\n    var dragCover = dragElement.coverSlip();\n    this.addEventListener('touchmove', mouseMove);\n    this.addEventListener('touchend', mouseUp);\n    dragCover.addEventListener('mousemove', mouseMove);\n    dragCover.addEventListener('mouseup', mouseUp);\n    function mouseMove(e) {\n      var clientX = e.clientX || e.touches[0].clientX;\n      var delta = +clientX - startX;\n      var pixelMin, pixelMax, cursor;\n      switch (target) {\n        case slideBox:\n          cursor = 'ew-resize';\n          if (minVal + delta > axisOpts._length || maxVal + delta < 0) {\n            return;\n          }\n          pixelMin = minVal + delta;\n          pixelMax = maxVal + delta;\n          break;\n        case grabAreaMin:\n          cursor = 'col-resize';\n          if (minVal + delta > axisOpts._length) {\n            return;\n          }\n          pixelMin = minVal + delta;\n          pixelMax = maxVal;\n          break;\n        case grabAreaMax:\n          cursor = 'col-resize';\n          if (maxVal + delta < 0) {\n            return;\n          }\n          pixelMin = minVal;\n          pixelMax = maxVal + delta;\n          break;\n        default:\n          cursor = 'ew-resize';\n          pixelMin = offsetX;\n          pixelMax = offsetX + delta;\n          break;\n      }\n      if (pixelMax < pixelMin) {\n        var tmp = pixelMax;\n        pixelMax = pixelMin;\n        pixelMin = tmp;\n      }\n      opts._pixelMin = pixelMin;\n      opts._pixelMax = pixelMax;\n      setCursor(d3.select(dragCover), cursor);\n      setDataRange(rangeSlider, gd, axisOpts, opts);\n    }\n    function mouseUp() {\n      dragCover.removeEventListener('mousemove', mouseMove);\n      dragCover.removeEventListener('mouseup', mouseUp);\n      this.removeEventListener('touchmove', mouseMove);\n      this.removeEventListener('touchend', mouseUp);\n      Lib.removeElement(dragCover);\n    }\n  }\n  rangeSlider.on('mousedown', mouseDownHandler);\n  rangeSlider.on('touchstart', mouseDownHandler);\n}\nfunction setDataRange(rangeSlider, gd, axisOpts, opts) {\n  function clamp(v) {\n    return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));\n  }\n  var dataMin = clamp(opts.p2d(opts._pixelMin));\n  var dataMax = clamp(opts.p2d(opts._pixelMax));\n  window.requestAnimationFrame(function () {\n    Registry.call('_guiRelayout', gd, axisOpts._name + '.range', [dataMin, dataMax]);\n  });\n}\nfunction setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {\n  var hw2 = constants.handleWidth / 2;\n  function clamp(v) {\n    return Lib.constrain(v, 0, opts._width);\n  }\n  function clampOppAxis(v) {\n    return Lib.constrain(v, 0, opts._height);\n  }\n  function clampHandle(v) {\n    return Lib.constrain(v, -hw2, opts._width + hw2);\n  }\n  var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));\n  var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));\n  rangeSlider.select('rect.' + constants.slideBoxClassName).attr('x', pixelMin).attr('width', pixelMax - pixelMin);\n  rangeSlider.select('rect.' + constants.maskMinClassName).attr('width', pixelMin);\n  rangeSlider.select('rect.' + constants.maskMaxClassName).attr('x', pixelMax).attr('width', opts._width - pixelMax);\n  if (oppAxisRangeOpts.rangemode !== 'match') {\n    var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));\n    var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));\n    rangeSlider.select('rect.' + constants.maskMinOppAxisClassName).attr('x', pixelMin).attr('height', pixelMinOppAxis).attr('width', pixelMax - pixelMin);\n    rangeSlider.select('rect.' + constants.maskMaxOppAxisClassName).attr('x', pixelMin).attr('y', pixelMaxOppAxis).attr('height', opts._height - pixelMaxOppAxis).attr('width', pixelMax - pixelMin);\n    rangeSlider.select('rect.' + constants.slideBoxClassName).attr('y', pixelMinOppAxis).attr('height', pixelMaxOppAxis - pixelMinOppAxis);\n  }\n\n  // add offset for crispier corners\n  // https://github.com/plotly/plotly.js/pull/1409\n  var offset = 0.5;\n  var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;\n  var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;\n  rangeSlider.select('g.' + constants.grabberMinClassName).attr('transform', strTranslate(xMin, offset));\n  rangeSlider.select('g.' + constants.grabberMaxClassName).attr('transform', strTranslate(xMax, offset));\n}\nfunction drawBg(rangeSlider, gd, axisOpts, opts) {\n  var bg = Lib.ensureSingle(rangeSlider, 'rect', constants.bgClassName, function (s) {\n    s.attr({\n      x: 0,\n      y: 0,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  var borderCorrect = opts.borderwidth % 2 === 0 ? opts.borderwidth : opts.borderwidth - 1;\n  var offsetShift = -opts._offsetShift;\n  var lw = Drawing.crispRound(gd, opts.borderwidth);\n  bg.attr({\n    width: opts._width + borderCorrect,\n    height: opts._height + borderCorrect,\n    transform: strTranslate(offsetShift, offsetShift),\n    'stroke-width': lw\n  }).call(Color.stroke, opts.bordercolor).call(Color.fill, opts.bgcolor);\n}\nfunction addClipPath(rangeSlider, gd, axisOpts, opts) {\n  var fullLayout = gd._fullLayout;\n  var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', opts._clipId, function (s) {\n    s.append('rect').attr({\n      x: 0,\n      y: 0\n    });\n  });\n  clipPath.select('rect').attr({\n    width: opts._width,\n    height: opts._height\n  });\n}\nfunction drawRangePlot(rangeSlider, gd, axisOpts, opts) {\n  var calcData = gd.calcdata;\n  var rangePlots = rangeSlider.selectAll('g.' + constants.rangePlotClassName).data(axisOpts._subplotsWith, Lib.identity);\n  rangePlots.enter().append('g').attr('class', function (id) {\n    return constants.rangePlotClassName + ' ' + id;\n  }).call(Drawing.setClipUrl, opts._clipId, gd);\n  rangePlots.order();\n  rangePlots.exit().remove();\n  var mainplotinfo;\n  rangePlots.each(function (id, i) {\n    var plotgroup = d3.select(this);\n    var isMainPlot = i === 0;\n    var oppAxisOpts = axisIDs.getFromId(gd, id, 'y');\n    var oppAxisName = oppAxisOpts._name;\n    var oppAxisRangeOpts = opts[oppAxisName];\n    var mockFigure = {\n      data: [],\n      layout: {\n        xaxis: {\n          type: axisOpts.type,\n          domain: [0, 1],\n          range: opts.range.slice(),\n          calendar: axisOpts.calendar\n        },\n        width: opts._width,\n        height: opts._height,\n        margin: {\n          t: 0,\n          b: 0,\n          l: 0,\n          r: 0\n        }\n      },\n      _context: gd._context\n    };\n    if (axisOpts.rangebreaks) {\n      mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;\n    }\n    mockFigure.layout[oppAxisName] = {\n      type: oppAxisOpts.type,\n      domain: [0, 1],\n      range: oppAxisRangeOpts.rangemode !== 'match' ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),\n      calendar: oppAxisOpts.calendar\n    };\n    if (oppAxisOpts.rangebreaks) {\n      mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;\n    }\n    Plots.supplyDefaults(mockFigure);\n    var xa = mockFigure._fullLayout.xaxis;\n    var ya = mockFigure._fullLayout[oppAxisName];\n    xa.clearCalc();\n    xa.setScale();\n    ya.clearCalc();\n    ya.setScale();\n    var plotinfo = {\n      id: id,\n      plotgroup: plotgroup,\n      xaxis: xa,\n      yaxis: ya,\n      isRangePlot: true\n    };\n    if (isMainPlot) mainplotinfo = plotinfo;else {\n      plotinfo.mainplot = 'xy';\n      plotinfo.mainplotinfo = mainplotinfo;\n    }\n    Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));\n  });\n}\nfunction filterRangePlotCalcData(calcData, subplotId) {\n  var out = [];\n  for (var i = 0; i < calcData.length; i++) {\n    var calcTrace = calcData[i];\n    var trace = calcTrace[0].trace;\n    if (trace.xaxis + trace.yaxis === subplotId) {\n      out.push(calcTrace);\n    }\n  }\n  return out;\n}\nfunction drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {\n  var maskMin = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinClassName, function (s) {\n    s.attr({\n      x: 0,\n      y: 0,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  maskMin.attr('height', opts._height).call(Color.fill, constants.maskColor);\n  var maskMax = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxClassName, function (s) {\n    s.attr({\n      y: 0,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  maskMax.attr('height', opts._height).call(Color.fill, constants.maskColor);\n\n  // masks used for oppAxis zoom\n  if (oppAxisRangeOpts.rangemode !== 'match') {\n    var maskMinOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinOppAxisClassName, function (s) {\n      s.attr({\n        y: 0,\n        'shape-rendering': 'crispEdges'\n      });\n    });\n    maskMinOppAxis.attr('width', opts._width).call(Color.fill, constants.maskOppAxisColor);\n    var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxOppAxisClassName, function (s) {\n      s.attr({\n        y: 0,\n        'shape-rendering': 'crispEdges'\n      });\n    });\n    maskMaxOppAxis.attr('width', opts._width).style('border-top', constants.maskOppBorder).call(Color.fill, constants.maskOppAxisColor);\n  }\n}\nfunction drawSlideBox(rangeSlider, gd, axisOpts, opts) {\n  if (gd._context.staticPlot) return;\n  var slideBox = Lib.ensureSingle(rangeSlider, 'rect', constants.slideBoxClassName, function (s) {\n    s.attr({\n      y: 0,\n      cursor: constants.slideBoxCursor,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  slideBox.attr({\n    height: opts._height,\n    fill: constants.slideBoxFill\n  });\n}\nfunction drawGrabbers(rangeSlider, gd, axisOpts, opts) {\n  // <g grabber />\n  var grabberMin = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMinClassName);\n  var grabberMax = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMaxClassName);\n\n  // <g handle />\n  var handleFixAttrs = {\n    x: 0,\n    width: constants.handleWidth,\n    rx: constants.handleRadius,\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': constants.handleStrokeWidth,\n    'shape-rendering': 'crispEdges'\n  };\n  var handleDynamicAttrs = {\n    y: Math.round(opts._height / 4),\n    height: Math.round(opts._height / 2)\n  };\n  var handleMin = Lib.ensureSingle(grabberMin, 'rect', constants.handleMinClassName, function (s) {\n    s.attr(handleFixAttrs);\n  });\n  handleMin.attr(handleDynamicAttrs);\n  var handleMax = Lib.ensureSingle(grabberMax, 'rect', constants.handleMaxClassName, function (s) {\n    s.attr(handleFixAttrs);\n  });\n  handleMax.attr(handleDynamicAttrs);\n\n  // <g grabarea />\n  var grabAreaFixAttrs = {\n    width: constants.grabAreaWidth,\n    x: 0,\n    y: 0,\n    fill: constants.grabAreaFill,\n    cursor: !gd._context.staticPlot ? constants.grabAreaCursor : undefined\n  };\n  var grabAreaMin = Lib.ensureSingle(grabberMin, 'rect', constants.grabAreaMinClassName, function (s) {\n    s.attr(grabAreaFixAttrs);\n  });\n  grabAreaMin.attr('height', opts._height);\n  var grabAreaMax = Lib.ensureSingle(grabberMax, 'rect', constants.grabAreaMaxClassName, function (s) {\n    s.attr(grabAreaFixAttrs);\n  });\n  grabAreaMax.attr('height', opts._height);\n}","map":{"version":3,"names":["d3","require","Registry","Plots","Lib","strTranslate","Drawing","Color","Titles","Cartesian","axisIDs","dragElement","setCursor","constants","module","exports","gd","fullLayout","_fullLayout","rangeSliderData","_rangeSliderData","i","length","opts","name","_clipId","_id","_uid","keyFunction","axisOpts","_name","rangeSliders","_infolayer","selectAll","containerClassName","data","exit","each","_topdefs","select","remove","enter","append","classed","attr","rangeSlider","oppAxisOpts","id2name","anchor","oppAxisRangeOpts","range","rng","simpleMap","r2l","axRng","newRng","Math","min","max","_input","l2r","cleanRange","gs","_size","domain","_width","w","x","round","l","y","t","h","_counterDomainMin","side","_depth","_offsetShift","extraPad","_rl","rl0","rl1","drl","p2d","v","d2p","rangebreaks","rsBreaks","locateBreaks","j","brk","lBreaks","m2","_B","push","b","pmin","pmax","rangemode","range0OppAxis","range1OppAxis","distOppAxis","d2pOppAxis","_height","call","drawBg","addClipPath","drawRangePlot","drawMasks","drawSlideBox","drawGrabbers","setupDragElement","setPixelRange","draw","propContainer","propName","placeholder","_dfltTitle","attributes","_offset","_length","title","font","size","_context","staticPlot","slideBox","slideBoxClassName","node","grabAreaMin","grabAreaMinClassName","grabAreaMax","grabAreaMaxClassName","mouseDownHandler","event","target","startX","clientX","touches","offsetX","getBoundingClientRect","left","minVal","maxVal","dragCover","coverSlip","addEventListener","mouseMove","mouseUp","e","delta","pixelMin","pixelMax","cursor","tmp","_pixelMin","_pixelMax","setDataRange","removeEventListener","removeElement","on","clamp","constrain","dataMin","dataMax","window","requestAnimationFrame","hw2","handleWidth","clampOppAxis","clampHandle","maskMinClassName","maskMaxClassName","pixelMinOppAxis","pixelMaxOppAxis","maskMinOppAxisClassName","maskMaxOppAxisClassName","offset","xMin","xMax","grabberMinClassName","grabberMaxClassName","bg","ensureSingle","bgClassName","s","borderCorrect","borderwidth","offsetShift","lw","crispRound","width","height","transform","stroke","bordercolor","fill","bgcolor","clipPath","ensureSingleById","calcData","calcdata","rangePlots","rangePlotClassName","_subplotsWith","identity","id","setClipUrl","order","mainplotinfo","plotgroup","isMainPlot","getFromId","oppAxisName","mockFigure","layout","xaxis","type","slice","calendar","margin","r","supplyDefaults","xa","ya","clearCalc","setScale","plotinfo","yaxis","isRangePlot","mainplot","rangePlot","filterRangePlotCalcData","subplotId","out","calcTrace","trace","maskMin","maskColor","maskMax","maskMinOppAxis","maskOppAxisColor","maskMaxOppAxis","style","maskOppBorder","slideBoxCursor","slideBoxFill","grabberMin","grabberMax","handleFixAttrs","rx","handleRadius","background","defaultLine","handleStrokeWidth","handleDynamicAttrs","handleMin","handleMinClassName","handleMax","handleMaxClassName","grabAreaFixAttrs","grabAreaWidth","grabAreaFill","grabAreaCursor","undefined"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/components/rangeslider/draw.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\n\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar Titles = require('../titles');\n\nvar Cartesian = require('../../plots/cartesian');\nvar axisIDs = require('../../plots/cartesian/axis_ids');\n\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\n\nmodule.exports = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var rangeSliderData = fullLayout._rangeSliderData;\n    for(var i = 0; i < rangeSliderData.length; i++) {\n        var opts = rangeSliderData[i][constants.name];\n        // fullLayout._uid may not exist when we call makeData\n        opts._clipId = opts._id + '-' + fullLayout._uid;\n    }\n\n    /*\n     * <g container />\n     *  <rect bg />\n     *  < .... range plot />\n     *  <rect mask-min />\n     *  <rect mask-max />\n     *  <rect slidebox />\n     *  <g grabber-min />\n     *      <rect handle-min />\n     *      <rect grabare-min />\n     *  <g grabber-max />\n     *      <rect handle-max />\n     *      <rect grabare-max />\n     *\n     *  ...\n     */\n\n    function keyFunction(axisOpts) {\n        return axisOpts._name;\n    }\n\n    var rangeSliders = fullLayout._infolayer\n        .selectAll('g.' + constants.containerClassName)\n        .data(rangeSliderData, keyFunction);\n\n    // remove exiting sliders and their corresponding clip paths\n    rangeSliders.exit().each(function(axisOpts) {\n        var opts = axisOpts[constants.name];\n        fullLayout._topdefs.select('#' + opts._clipId).remove();\n    }).remove();\n\n    // return early if no range slider is visible\n    if(rangeSliderData.length === 0) return;\n\n    rangeSliders.enter().append('g')\n        .classed(constants.containerClassName, true)\n        .attr('pointer-events', 'all');\n\n    // for all present range sliders\n    rangeSliders.each(function(axisOpts) {\n        var rangeSlider = d3.select(this);\n        var opts = axisOpts[constants.name];\n        var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];\n        var oppAxisRangeOpts = opts[axisIDs.id2name(axisOpts.anchor)];\n\n        // update range\n        // Expand slider range to the axis range\n        if(opts.range) {\n            var rng = Lib.simpleMap(opts.range, axisOpts.r2l);\n            var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);\n            var newRng;\n\n            if(axRng[0] < axRng[1]) {\n                newRng = [\n                    Math.min(rng[0], axRng[0]),\n                    Math.max(rng[1], axRng[1])\n                ];\n            } else {\n                newRng = [\n                    Math.max(rng[0], axRng[0]),\n                    Math.min(rng[1], axRng[1])\n                ];\n            }\n\n            opts.range = opts._input.range = Lib.simpleMap(newRng, axisOpts.l2r);\n        }\n\n        axisOpts.cleanRange('rangeslider.range');\n\n        // update range slider dimensions\n\n        var gs = fullLayout._size;\n        var domain = axisOpts.domain;\n\n        opts._width = gs.w * (domain[1] - domain[0]);\n\n        var x = Math.round(gs.l + (gs.w * domain[0]));\n\n        var y = Math.round(\n            gs.t + gs.h * (1 - axisOpts._counterDomainMin) +\n            (axisOpts.side === 'bottom' ? axisOpts._depth : 0) +\n            opts._offsetShift + constants.extraPad\n        );\n\n        rangeSlider.attr('transform', strTranslate(x, y));\n\n        // update data <--> pixel coordinate conversion methods\n\n        opts._rl = Lib.simpleMap(opts.range, axisOpts.r2l);\n        var rl0 = opts._rl[0];\n        var rl1 = opts._rl[1];\n        var drl = rl1 - rl0;\n\n        opts.p2d = function(v) {\n            return (v / opts._width) * drl + rl0;\n        };\n\n        opts.d2p = function(v) {\n            return (v - rl0) / drl * opts._width;\n        };\n\n        if(axisOpts.rangebreaks) {\n            var rsBreaks = axisOpts.locateBreaks(rl0, rl1);\n\n            if(rsBreaks.length) {\n                var j, brk;\n\n                var lBreaks = 0;\n                for(j = 0; j < rsBreaks.length; j++) {\n                    brk = rsBreaks[j];\n                    lBreaks += (brk.max - brk.min);\n                }\n\n                // TODO fix for reversed-range axes !!!\n\n                // compute slope and piecewise offsets\n                var m2 = opts._width / (rl1 - rl0 - lBreaks);\n                var _B = [-m2 * rl0];\n                for(j = 0; j < rsBreaks.length; j++) {\n                    brk = rsBreaks[j];\n                    _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));\n                }\n\n                opts.d2p = function(v) {\n                    var b = _B[0];\n                    for(var j = 0; j < rsBreaks.length; j++) {\n                        var brk = rsBreaks[j];\n                        if(v >= brk.max) b = _B[j + 1];\n                        else if(v < brk.min) break;\n                    }\n                    return b + m2 * v;\n                };\n\n                // fill pixel (i.e. 'p') min/max here,\n                // to not have to loop through the _rangebreaks twice during `p2d`\n                for(j = 0; j < rsBreaks.length; j++) {\n                    brk = rsBreaks[j];\n                    brk.pmin = opts.d2p(brk.min);\n                    brk.pmax = opts.d2p(brk.max);\n                }\n\n                opts.p2d = function(v) {\n                    var b = _B[0];\n                    for(var j = 0; j < rsBreaks.length; j++) {\n                        var brk = rsBreaks[j];\n                        if(v >= brk.pmax) b = _B[j + 1];\n                        else if(v < brk.pmin) break;\n                    }\n                    return (v - b) / m2;\n                };\n            }\n        }\n\n        if(oppAxisRangeOpts.rangemode !== 'match') {\n            var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);\n            var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);\n            var distOppAxis = range1OppAxis - range0OppAxis;\n\n            opts.d2pOppAxis = function(v) {\n                return (v - range0OppAxis) / distOppAxis * opts._height;\n            };\n        }\n\n        // update inner nodes\n\n        rangeSlider\n            .call(drawBg, gd, axisOpts, opts)\n            .call(addClipPath, gd, axisOpts, opts)\n            .call(drawRangePlot, gd, axisOpts, opts)\n            .call(drawMasks, gd, axisOpts, opts, oppAxisRangeOpts)\n            .call(drawSlideBox, gd, axisOpts, opts)\n            .call(drawGrabbers, gd, axisOpts, opts);\n\n        // setup drag element\n        setupDragElement(rangeSlider, gd, axisOpts, opts);\n\n        // update current range\n        setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts);\n\n        // title goes next to range slider instead of tick labels, so\n        // just take it over and draw it from here\n        if(axisOpts.side === 'bottom') {\n            Titles.draw(gd, axisOpts._id + 'title', {\n                propContainer: axisOpts,\n                propName: axisOpts._name + '.title',\n                placeholder: fullLayout._dfltTitle.x,\n                attributes: {\n                    x: axisOpts._offset + axisOpts._length / 2,\n                    y: y + opts._height + opts._offsetShift + 10 + 1.5 * axisOpts.title.font.size,\n                    'text-anchor': 'middle'\n                }\n            });\n        }\n    });\n};\n\nfunction setupDragElement(rangeSlider, gd, axisOpts, opts) {\n    if(gd._context.staticPlot) return;\n\n    var slideBox = rangeSlider.select('rect.' + constants.slideBoxClassName).node();\n    var grabAreaMin = rangeSlider.select('rect.' + constants.grabAreaMinClassName).node();\n    var grabAreaMax = rangeSlider.select('rect.' + constants.grabAreaMaxClassName).node();\n\n    function mouseDownHandler() {\n        var event = d3.event;\n        var target = event.target;\n        var startX = event.clientX || event.touches[0].clientX;\n        var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;\n        var minVal = opts.d2p(axisOpts._rl[0]);\n        var maxVal = opts.d2p(axisOpts._rl[1]);\n\n        var dragCover = dragElement.coverSlip();\n\n        this.addEventListener('touchmove', mouseMove);\n        this.addEventListener('touchend', mouseUp);\n        dragCover.addEventListener('mousemove', mouseMove);\n        dragCover.addEventListener('mouseup', mouseUp);\n\n        function mouseMove(e) {\n            var clientX = e.clientX || e.touches[0].clientX;\n            var delta = +clientX - startX;\n            var pixelMin, pixelMax, cursor;\n\n            switch(target) {\n                case slideBox:\n                    cursor = 'ew-resize';\n                    if(minVal + delta > axisOpts._length || maxVal + delta < 0) {\n                        return;\n                    }\n                    pixelMin = minVal + delta;\n                    pixelMax = maxVal + delta;\n                    break;\n\n                case grabAreaMin:\n                    cursor = 'col-resize';\n                    if(minVal + delta > axisOpts._length) {\n                        return;\n                    }\n                    pixelMin = minVal + delta;\n                    pixelMax = maxVal;\n                    break;\n\n                case grabAreaMax:\n                    cursor = 'col-resize';\n                    if(maxVal + delta < 0) {\n                        return;\n                    }\n                    pixelMin = minVal;\n                    pixelMax = maxVal + delta;\n                    break;\n\n                default:\n                    cursor = 'ew-resize';\n                    pixelMin = offsetX;\n                    pixelMax = offsetX + delta;\n                    break;\n            }\n\n            if(pixelMax < pixelMin) {\n                var tmp = pixelMax;\n                pixelMax = pixelMin;\n                pixelMin = tmp;\n            }\n\n            opts._pixelMin = pixelMin;\n            opts._pixelMax = pixelMax;\n\n            setCursor(d3.select(dragCover), cursor);\n            setDataRange(rangeSlider, gd, axisOpts, opts);\n        }\n\n        function mouseUp() {\n            dragCover.removeEventListener('mousemove', mouseMove);\n            dragCover.removeEventListener('mouseup', mouseUp);\n            this.removeEventListener('touchmove', mouseMove);\n            this.removeEventListener('touchend', mouseUp);\n            Lib.removeElement(dragCover);\n        }\n    }\n\n    rangeSlider.on('mousedown', mouseDownHandler);\n    rangeSlider.on('touchstart', mouseDownHandler);\n}\n\nfunction setDataRange(rangeSlider, gd, axisOpts, opts) {\n    function clamp(v) {\n        return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));\n    }\n\n    var dataMin = clamp(opts.p2d(opts._pixelMin));\n    var dataMax = clamp(opts.p2d(opts._pixelMax));\n\n    window.requestAnimationFrame(function() {\n        Registry.call('_guiRelayout', gd, axisOpts._name + '.range', [dataMin, dataMax]);\n    });\n}\n\nfunction setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {\n    var hw2 = constants.handleWidth / 2;\n\n    function clamp(v) {\n        return Lib.constrain(v, 0, opts._width);\n    }\n\n    function clampOppAxis(v) {\n        return Lib.constrain(v, 0, opts._height);\n    }\n\n    function clampHandle(v) {\n        return Lib.constrain(v, -hw2, opts._width + hw2);\n    }\n\n    var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));\n    var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));\n\n    rangeSlider.select('rect.' + constants.slideBoxClassName)\n        .attr('x', pixelMin)\n        .attr('width', pixelMax - pixelMin);\n\n    rangeSlider.select('rect.' + constants.maskMinClassName)\n        .attr('width', pixelMin);\n\n    rangeSlider.select('rect.' + constants.maskMaxClassName)\n        .attr('x', pixelMax)\n        .attr('width', opts._width - pixelMax);\n\n    if(oppAxisRangeOpts.rangemode !== 'match') {\n        var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));\n        var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));\n\n        rangeSlider.select('rect.' + constants.maskMinOppAxisClassName)\n            .attr('x', pixelMin)\n            .attr('height', pixelMinOppAxis)\n            .attr('width', pixelMax - pixelMin);\n\n        rangeSlider.select('rect.' + constants.maskMaxOppAxisClassName)\n            .attr('x', pixelMin)\n            .attr('y', pixelMaxOppAxis)\n            .attr('height', opts._height - pixelMaxOppAxis)\n            .attr('width', pixelMax - pixelMin);\n\n        rangeSlider.select('rect.' + constants.slideBoxClassName)\n            .attr('y', pixelMinOppAxis)\n            .attr('height', pixelMaxOppAxis - pixelMinOppAxis);\n    }\n\n    // add offset for crispier corners\n    // https://github.com/plotly/plotly.js/pull/1409\n    var offset = 0.5;\n\n    var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;\n    var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;\n\n    rangeSlider.select('g.' + constants.grabberMinClassName)\n        .attr('transform', strTranslate(xMin, offset));\n\n    rangeSlider.select('g.' + constants.grabberMaxClassName)\n        .attr('transform', strTranslate(xMax, offset));\n}\n\nfunction drawBg(rangeSlider, gd, axisOpts, opts) {\n    var bg = Lib.ensureSingle(rangeSlider, 'rect', constants.bgClassName, function(s) {\n        s.attr({\n            x: 0,\n            y: 0,\n            'shape-rendering': 'crispEdges'\n        });\n    });\n\n    var borderCorrect = (opts.borderwidth % 2) === 0 ?\n        opts.borderwidth :\n        opts.borderwidth - 1;\n\n    var offsetShift = -opts._offsetShift;\n    var lw = Drawing.crispRound(gd, opts.borderwidth);\n\n    bg.attr({\n        width: opts._width + borderCorrect,\n        height: opts._height + borderCorrect,\n        transform: strTranslate(offsetShift, offsetShift),\n        'stroke-width': lw\n    })\n    .call(Color.stroke, opts.bordercolor)\n    .call(Color.fill, opts.bgcolor);\n}\n\nfunction addClipPath(rangeSlider, gd, axisOpts, opts) {\n    var fullLayout = gd._fullLayout;\n\n    var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', opts._clipId, function(s) {\n        s.append('rect').attr({ x: 0, y: 0 });\n    });\n\n    clipPath.select('rect').attr({\n        width: opts._width,\n        height: opts._height\n    });\n}\n\nfunction drawRangePlot(rangeSlider, gd, axisOpts, opts) {\n    var calcData = gd.calcdata;\n\n    var rangePlots = rangeSlider.selectAll('g.' + constants.rangePlotClassName)\n        .data(axisOpts._subplotsWith, Lib.identity);\n\n    rangePlots.enter().append('g')\n        .attr('class', function(id) { return constants.rangePlotClassName + ' ' + id; })\n        .call(Drawing.setClipUrl, opts._clipId, gd);\n\n    rangePlots.order();\n\n    rangePlots.exit().remove();\n\n    var mainplotinfo;\n\n    rangePlots.each(function(id, i) {\n        var plotgroup = d3.select(this);\n        var isMainPlot = (i === 0);\n\n        var oppAxisOpts = axisIDs.getFromId(gd, id, 'y');\n        var oppAxisName = oppAxisOpts._name;\n        var oppAxisRangeOpts = opts[oppAxisName];\n\n        var mockFigure = {\n            data: [],\n            layout: {\n                xaxis: {\n                    type: axisOpts.type,\n                    domain: [0, 1],\n                    range: opts.range.slice(),\n                    calendar: axisOpts.calendar\n                },\n                width: opts._width,\n                height: opts._height,\n                margin: { t: 0, b: 0, l: 0, r: 0 }\n            },\n            _context: gd._context\n        };\n\n        if(axisOpts.rangebreaks) {\n            mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;\n        }\n\n        mockFigure.layout[oppAxisName] = {\n            type: oppAxisOpts.type,\n            domain: [0, 1],\n            range: oppAxisRangeOpts.rangemode !== 'match' ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),\n            calendar: oppAxisOpts.calendar\n        };\n\n        if(oppAxisOpts.rangebreaks) {\n            mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;\n        }\n\n        Plots.supplyDefaults(mockFigure);\n\n        var xa = mockFigure._fullLayout.xaxis;\n        var ya = mockFigure._fullLayout[oppAxisName];\n\n        xa.clearCalc();\n        xa.setScale();\n        ya.clearCalc();\n        ya.setScale();\n\n        var plotinfo = {\n            id: id,\n            plotgroup: plotgroup,\n            xaxis: xa,\n            yaxis: ya,\n            isRangePlot: true\n        };\n\n        if(isMainPlot) mainplotinfo = plotinfo;\n        else {\n            plotinfo.mainplot = 'xy';\n            plotinfo.mainplotinfo = mainplotinfo;\n        }\n\n        Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));\n    });\n}\n\nfunction filterRangePlotCalcData(calcData, subplotId) {\n    var out = [];\n\n    for(var i = 0; i < calcData.length; i++) {\n        var calcTrace = calcData[i];\n        var trace = calcTrace[0].trace;\n\n        if(trace.xaxis + trace.yaxis === subplotId) {\n            out.push(calcTrace);\n        }\n    }\n\n    return out;\n}\n\nfunction drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {\n    var maskMin = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinClassName, function(s) {\n        s.attr({\n            x: 0,\n            y: 0,\n            'shape-rendering': 'crispEdges'\n        });\n    });\n\n    maskMin\n        .attr('height', opts._height)\n        .call(Color.fill, constants.maskColor);\n\n    var maskMax = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxClassName, function(s) {\n        s.attr({\n            y: 0,\n            'shape-rendering': 'crispEdges'\n        });\n    });\n\n    maskMax\n        .attr('height', opts._height)\n        .call(Color.fill, constants.maskColor);\n\n    // masks used for oppAxis zoom\n    if(oppAxisRangeOpts.rangemode !== 'match') {\n        var maskMinOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinOppAxisClassName, function(s) {\n            s.attr({\n                y: 0,\n                'shape-rendering': 'crispEdges'\n            });\n        });\n\n        maskMinOppAxis\n            .attr('width', opts._width)\n            .call(Color.fill, constants.maskOppAxisColor);\n\n        var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxOppAxisClassName, function(s) {\n            s.attr({\n                y: 0,\n                'shape-rendering': 'crispEdges'\n            });\n        });\n\n        maskMaxOppAxis\n            .attr('width', opts._width)\n            .style('border-top', constants.maskOppBorder)\n            .call(Color.fill, constants.maskOppAxisColor);\n    }\n}\n\nfunction drawSlideBox(rangeSlider, gd, axisOpts, opts) {\n    if(gd._context.staticPlot) return;\n\n    var slideBox = Lib.ensureSingle(rangeSlider, 'rect', constants.slideBoxClassName, function(s) {\n        s.attr({\n            y: 0,\n            cursor: constants.slideBoxCursor,\n            'shape-rendering': 'crispEdges'\n        });\n    });\n\n    slideBox.attr({\n        height: opts._height,\n        fill: constants.slideBoxFill\n    });\n}\n\nfunction drawGrabbers(rangeSlider, gd, axisOpts, opts) {\n    // <g grabber />\n    var grabberMin = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMinClassName);\n    var grabberMax = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMaxClassName);\n\n    // <g handle />\n    var handleFixAttrs = {\n        x: 0,\n        width: constants.handleWidth,\n        rx: constants.handleRadius,\n        fill: Color.background,\n        stroke: Color.defaultLine,\n        'stroke-width': constants.handleStrokeWidth,\n        'shape-rendering': 'crispEdges'\n    };\n    var handleDynamicAttrs = {\n        y: Math.round(opts._height / 4),\n        height: Math.round(opts._height / 2),\n    };\n    var handleMin = Lib.ensureSingle(grabberMin, 'rect', constants.handleMinClassName, function(s) {\n        s.attr(handleFixAttrs);\n    });\n    handleMin.attr(handleDynamicAttrs);\n\n    var handleMax = Lib.ensureSingle(grabberMax, 'rect', constants.handleMaxClassName, function(s) {\n        s.attr(handleFixAttrs);\n    });\n    handleMax.attr(handleDynamicAttrs);\n\n    // <g grabarea />\n    var grabAreaFixAttrs = {\n        width: constants.grabAreaWidth,\n        x: 0,\n        y: 0,\n        fill: constants.grabAreaFill,\n        cursor: !gd._context.staticPlot ? constants.grabAreaCursor : undefined,\n    };\n\n    var grabAreaMin = Lib.ensureSingle(grabberMin, 'rect', constants.grabAreaMinClassName, function(s) {\n        s.attr(grabAreaFixAttrs);\n    });\n    grabAreaMin.attr('height', opts._height);\n\n    var grabAreaMax = Lib.ensureSingle(grabberMax, 'rect', constants.grabAreaMaxClassName, function(s) {\n        s.attr(grabAreaFixAttrs);\n    });\n    grabAreaMax.attr('height', opts._height);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}