{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  left: 1,\n  end: -1,\n  right: -1,\n  middle: 0,\n  center: 0,\n  bottom: 1,\n  top: -1\n};\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\nfunction convertStyle(gd, trace) {\n  var i;\n  var opts = {\n    marker: undefined,\n    markerSel: undefined,\n    markerUnsel: undefined,\n    line: undefined,\n    fill: undefined,\n    errorX: undefined,\n    errorY: undefined,\n    text: undefined,\n    textSel: undefined,\n    textUnsel: undefined\n  };\n  var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n  if (trace.visible !== true) return opts;\n  if (subTypes.hasText(trace)) {\n    opts.text = convertTextStyle(gd, trace);\n    opts.textSel = convertTextSelection(gd, trace, trace.selected);\n    opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n  }\n  if (subTypes.hasMarkers(trace)) {\n    opts.marker = convertMarkerStyle(gd, trace);\n    opts.markerSel = convertMarkerSelection(gd, trace, trace.selected);\n    opts.markerUnsel = convertMarkerSelection(gd, trace, trace.unselected);\n    if (!trace.unselected && Lib.isArrayOrTypedArray(trace.marker.opacity)) {\n      var mo = trace.marker.opacity;\n      opts.markerUnsel.opacity = new Array(mo.length);\n      for (i = 0; i < mo.length; i++) {\n        opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n      }\n    }\n  }\n  if (subTypes.hasLines(trace)) {\n    opts.line = {\n      overlay: true,\n      thickness: trace.line.width * plotGlPixelRatio,\n      color: trace.line.color,\n      opacity: trace.opacity\n    };\n    var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n    for (i = 0; i < dashes.length; ++i) {\n      dashes[i] *= trace.line.width * plotGlPixelRatio;\n    }\n    opts.line.dashes = dashes;\n  }\n  if (trace.error_x && trace.error_x.visible) {\n    opts.errorX = convertErrorBarStyle(trace, trace.error_x, plotGlPixelRatio);\n  }\n  if (trace.error_y && trace.error_y.visible) {\n    opts.errorY = convertErrorBarStyle(trace, trace.error_y, plotGlPixelRatio);\n  }\n  if (!!trace.fill && trace.fill !== 'none') {\n    opts.fill = {\n      closed: true,\n      fill: trace.fillcolor,\n      thickness: 0\n    };\n  }\n  return opts;\n}\nfunction convertTextStyle(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var count = trace._length;\n  var textfontIn = trace.textfont;\n  var textpositionIn = trace.textposition;\n  var textPos = Array.isArray(textpositionIn) ? textpositionIn : [textpositionIn];\n  var tfc = textfontIn.color;\n  var tfs = textfontIn.size;\n  var tff = textfontIn.family;\n  var optsOut = {};\n  var i;\n  var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n  var texttemplate = trace.texttemplate;\n  if (texttemplate) {\n    optsOut.text = [];\n    var d3locale = fullLayout._d3locale;\n    var isArray = Array.isArray(texttemplate);\n    var N = isArray ? Math.min(texttemplate.length, count) : count;\n    var txt = isArray ? function (i) {\n      return texttemplate[i];\n    } : function () {\n      return texttemplate;\n    };\n    for (i = 0; i < N; i++) {\n      var d = {\n        i: i\n      };\n      var labels = trace._module.formatLabels(d, trace, fullLayout);\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, i);\n      var meta = trace._meta || {};\n      optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n    }\n  } else {\n    if (Array.isArray(trace.text) && trace.text.length < count) {\n      // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n      optsOut.text = trace.text.slice();\n    } else {\n      optsOut.text = trace.text;\n    }\n  }\n  // pad text array with empty strings\n  if (Array.isArray(optsOut.text)) {\n    for (i = optsOut.text.length; i < count; i++) {\n      optsOut.text[i] = '';\n    }\n  }\n  optsOut.opacity = trace.opacity;\n  optsOut.font = {};\n  optsOut.align = [];\n  optsOut.baseline = [];\n  for (i = 0; i < textPos.length; i++) {\n    var tp = textPos[i].split(/\\s+/);\n    switch (tp[1]) {\n      case 'left':\n        optsOut.align.push('right');\n        break;\n      case 'right':\n        optsOut.align.push('left');\n        break;\n      default:\n        optsOut.align.push(tp[1]);\n    }\n    switch (tp[0]) {\n      case 'top':\n        optsOut.baseline.push('bottom');\n        break;\n      case 'bottom':\n        optsOut.baseline.push('top');\n        break;\n      default:\n        optsOut.baseline.push(tp[0]);\n    }\n  }\n  if (Array.isArray(tfc)) {\n    optsOut.color = new Array(count);\n    for (i = 0; i < count; i++) {\n      optsOut.color[i] = tfc[i];\n    }\n  } else {\n    optsOut.color = tfc;\n  }\n  if (Lib.isArrayOrTypedArray(tfs) || Array.isArray(tff)) {\n    // if any textfont param is array - make render a batch\n    optsOut.font = new Array(count);\n    for (i = 0; i < count; i++) {\n      var fonti = optsOut.font[i] = {};\n      fonti.size = (Lib.isTypedArray(tfs) ? tfs[i] : Array.isArray(tfs) ? isNumeric(tfs[i]) ? tfs[i] : 0 : tfs) * plotGlPixelRatio;\n      fonti.family = Array.isArray(tff) ? tff[i] : tff;\n    }\n  } else {\n    // if both are single values, make render fast single-value\n    optsOut.font = {\n      size: tfs * plotGlPixelRatio,\n      family: tff\n    };\n  }\n  return optsOut;\n}\nfunction convertMarkerStyle(gd, trace) {\n  var count = trace._length;\n  var optsIn = trace.marker;\n  var optsOut = {};\n  var i;\n  var multiSymbol = Lib.isArrayOrTypedArray(optsIn.symbol);\n  var multiAngle = Lib.isArrayOrTypedArray(optsIn.angle);\n  var multiColor = Lib.isArrayOrTypedArray(optsIn.color);\n  var multiLineColor = Lib.isArrayOrTypedArray(optsIn.line.color);\n  var multiOpacity = Lib.isArrayOrTypedArray(optsIn.opacity);\n  var multiSize = Lib.isArrayOrTypedArray(optsIn.size);\n  var multiLineWidth = Lib.isArrayOrTypedArray(optsIn.line.width);\n  var isOpen;\n  if (!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol);\n\n  // prepare colors\n  if (multiSymbol || multiColor || multiLineColor || multiOpacity || multiAngle) {\n    optsOut.symbols = new Array(count);\n    optsOut.angles = new Array(count);\n    optsOut.colors = new Array(count);\n    optsOut.borderColors = new Array(count);\n    var symbols = optsIn.symbol;\n    var angles = optsIn.angle;\n    var colors = formatColor(optsIn, optsIn.opacity, count);\n    var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n    if (!Array.isArray(borderColors[0])) {\n      var borderColor = borderColors;\n      borderColors = Array(count);\n      for (i = 0; i < count; i++) {\n        borderColors[i] = borderColor;\n      }\n    }\n    if (!Array.isArray(colors[0])) {\n      var color = colors;\n      colors = Array(count);\n      for (i = 0; i < count; i++) {\n        colors[i] = color;\n      }\n    }\n    if (!Array.isArray(symbols)) {\n      var symbol = symbols;\n      symbols = Array(count);\n      for (i = 0; i < count; i++) {\n        symbols[i] = symbol;\n      }\n    }\n    if (!Array.isArray(angles)) {\n      var angle = angles;\n      angles = Array(count);\n      for (i = 0; i < count; i++) {\n        angles[i] = angle;\n      }\n    }\n    optsOut.symbols = symbols;\n    optsOut.angles = angles;\n    optsOut.colors = colors;\n    optsOut.borderColors = borderColors;\n    for (i = 0; i < count; i++) {\n      if (multiSymbol) {\n        isOpen = helpers.isOpenSymbol(optsIn.symbol[i]);\n      }\n      if (isOpen) {\n        borderColors[i] = colors[i].slice();\n        colors[i] = colors[i].slice();\n        colors[i][3] = 0;\n      }\n    }\n    optsOut.opacity = trace.opacity;\n    optsOut.markers = new Array(count);\n    for (i = 0; i < count; i++) {\n      optsOut.markers[i] = getSymbolSdf({\n        mx: optsOut.symbols[i],\n        ma: optsOut.angles[i]\n      }, trace);\n    }\n  } else {\n    if (isOpen) {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.color[3] = 0;\n      optsOut.borderColor = rgba(optsIn.color, 'uint8');\n    } else {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n    }\n    optsOut.opacity = trace.opacity * optsIn.opacity;\n    optsOut.marker = getSymbolSdf({\n      mx: optsIn.symbol,\n      ma: optsIn.angle\n    }, trace);\n  }\n\n  // prepare sizes\n  var sizeFactor = 1;\n  var markerSizeFunc = makeBubbleSizeFn(trace, sizeFactor);\n  var s;\n  if (multiSize || multiLineWidth) {\n    var sizes = optsOut.sizes = new Array(count);\n    var borderSizes = optsOut.borderSizes = new Array(count);\n    var sizeTotal = 0;\n    var sizeAvg;\n    if (multiSize) {\n      for (i = 0; i < count; i++) {\n        sizes[i] = markerSizeFunc(optsIn.size[i]);\n        sizeTotal += sizes[i];\n      }\n      sizeAvg = sizeTotal / count;\n    } else {\n      s = markerSizeFunc(optsIn.size);\n      for (i = 0; i < count; i++) {\n        sizes[i] = s;\n      }\n    }\n\n    // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n    if (multiLineWidth) {\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = optsIn.line.width[i];\n      }\n    } else {\n      s = optsIn.line.width;\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = s;\n      }\n    }\n    optsOut.sizeAvg = sizeAvg;\n  } else {\n    optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n    optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n  }\n  return optsOut;\n}\nfunction convertMarkerSelection(gd, trace, target) {\n  var optsIn = trace.marker;\n  var optsOut = {};\n  if (!target) return optsOut;\n  if (target.marker && target.marker.symbol) {\n    optsOut = convertMarkerStyle(gd, Lib.extendFlat({}, optsIn, target.marker));\n  } else if (target.marker) {\n    if (target.marker.size) optsOut.size = target.marker.size;\n    if (target.marker.color) optsOut.colors = target.marker.color;\n    if (target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n  }\n  return optsOut;\n}\nfunction convertTextSelection(gd, trace, target) {\n  var optsOut = {};\n  if (!target) return optsOut;\n  if (target.textfont) {\n    var optsIn = {\n      opacity: 1,\n      text: trace.text,\n      texttemplate: trace.texttemplate,\n      textposition: trace.textposition,\n      textfont: Lib.extendFlat({}, trace.textfont)\n    };\n    if (target.textfont) {\n      Lib.extendFlat(optsIn.textfont, target.textfont);\n    }\n    optsOut = convertTextStyle(gd, optsIn);\n  }\n  return optsOut;\n}\nfunction convertErrorBarStyle(trace, target, plotGlPixelRatio) {\n  var optsOut = {\n    capSize: target.width * 2 * plotGlPixelRatio,\n    lineWidth: target.thickness * plotGlPixelRatio,\n    color: target.color\n  };\n  if (target.copy_ystyle) {\n    optsOut = trace.error_y;\n  }\n  return optsOut;\n}\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\nfunction getSymbolSdf(d, trace) {\n  var symbol = d.mx;\n  if (symbol === 'circle') return null;\n  var symbolPath, symbolSdf;\n  var symbolNumber = Drawing.symbolNumber(symbol);\n  var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n  var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n  var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n  var isDot = helpers.isDotSymbol(symbol);\n\n  // until we may handle angles in shader?\n  if (d.ma) symbol += '_' + d.ma;\n\n  // get symbol sdf from cache or generate it\n  if (SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n  var angle = Drawing.getMarkerAngle(d, trace);\n  if (isDot && !symbolNoDot) {\n    symbolPath = symbolFunc(SYMBOL_SIZE * 1.1, angle) + SYMBOL_SVG_CIRCLE;\n  } else {\n    symbolPath = symbolFunc(SYMBOL_SIZE, angle);\n  }\n  symbolSdf = svgSdf(symbolPath, {\n    w: SYMBOL_SDF_SIZE,\n    h: SYMBOL_SDF_SIZE,\n    viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n    stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n  });\n  SYMBOL_SDF[symbol] = symbolSdf;\n  return symbolSdf || null;\n}\nfunction convertLinePositions(gd, trace, positions) {\n  var len = positions.length;\n  var count = len / 2;\n  var linePositions;\n  var i;\n  if (subTypes.hasLines(trace) && count) {\n    if (trace.line.shape === 'hv') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'hvh') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], midPtX, positions[i * 2 + 1], midPtX, positions[i * 2 + 3]);\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vhv') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], positions[i * 2], midPtY, positions[i * 2 + 2], midPtY);\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vh') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else {\n      linePositions = positions;\n    }\n  }\n\n  // If we have data with gaps, we ought to use rect joins\n  // FIXME: get rid of this\n  var hasNaN = false;\n  for (i = 0; i < linePositions.length; i++) {\n    if (isNaN(linePositions[i])) {\n      hasNaN = true;\n      break;\n    }\n  }\n  var join = hasNaN || linePositions.length > constants.TOO_MANY_POINTS ? 'rect' : subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n  // fill gaps\n  if (hasNaN && trace.connectgaps) {\n    var lastX = linePositions[0];\n    var lastY = linePositions[1];\n    for (i = 0; i < linePositions.length; i += 2) {\n      if (isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n        linePositions[i] = lastX;\n        linePositions[i + 1] = lastY;\n      } else {\n        lastX = linePositions[i];\n        lastY = linePositions[i + 1];\n      }\n    }\n  }\n  return {\n    join: join,\n    positions: linePositions\n  };\n}\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n  var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n  var xa = AxisIDs.getFromId(gd, trace.xaxis, 'x');\n  var ya = AxisIDs.getFromId(gd, trace.yaxis, 'y');\n  var count = positions.length / 2;\n  var out = {};\n  function convertOneAxis(coords, ax) {\n    var axLetter = ax._id.charAt(0);\n    var opts = trace['error_' + axLetter];\n    if (opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n      var computeError = makeComputeError(opts);\n      var pOffset = {\n        x: 0,\n        y: 1\n      }[axLetter];\n      var eOffset = {\n        x: [0, 1, 2, 3],\n        y: [2, 3, 0, 1]\n      }[axLetter];\n      var errors = new Float64Array(4 * count);\n      var minShoe = Infinity;\n      var maxHat = -Infinity;\n      for (var i = 0, j = 0; i < count; i++, j += 4) {\n        var dc = coords[i];\n        if (isNumeric(dc)) {\n          var dl = positions[i * 2 + pOffset];\n          var vals = computeError(dc, i);\n          var lv = vals[0];\n          var hv = vals[1];\n          if (isNumeric(lv) && isNumeric(hv)) {\n            var shoe = dc - lv;\n            var hat = dc + hv;\n            errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n            errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n            errors[j + eOffset[2]] = 0;\n            errors[j + eOffset[3]] = 0;\n            minShoe = Math.min(minShoe, dc - lv);\n            maxHat = Math.max(maxHat, dc + hv);\n          }\n        }\n      }\n      out[axLetter] = {\n        positions: positions,\n        errors: errors,\n        _bnds: [minShoe, maxHat]\n      };\n    }\n  }\n  convertOneAxis(x, xa);\n  convertOneAxis(y, ya);\n  return out;\n}\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n  var count = trace._length;\n  var out = {};\n  var i;\n\n  // corresponds to textPointPosition from component.drawing\n  if (subTypes.hasMarkers(trace)) {\n    var fontOpts = textOpts.font;\n    var align = textOpts.align;\n    var baseline = textOpts.baseline;\n    out.offset = new Array(count);\n    for (i = 0; i < count; i++) {\n      var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n      var fs = Array.isArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n      var a = Array.isArray(align) ? align.length > 1 ? align[i] : align[0] : align;\n      var b = Array.isArray(baseline) ? baseline.length > 1 ? baseline[i] : baseline[0] : baseline;\n      var hSign = TEXTOFFSETSIGN[a];\n      var vSign = TEXTOFFSETSIGN[b];\n      var xPad = ms ? ms / 0.8 + 1 : 0;\n      var yPad = -vSign * xPad - vSign * 0.5;\n      out.offset[i] = [hSign * xPad / fs, yPad / fs];\n    }\n  }\n  return out;\n}\nmodule.exports = {\n  style: convertStyle,\n  markerStyle: convertMarkerStyle,\n  markerSelection: convertMarkerSelection,\n  linePositions: convertLinePositions,\n  errorBarPositions: convertErrorBarPositions,\n  textPosition: convertTextPosition\n};","map":{"version":3,"names":["isNumeric","require","svgSdf","rgba","Registry","Lib","Drawing","AxisIDs","formatColor","subTypes","makeBubbleSizeFn","helpers","constants","DESELECTDIM","TEXTOFFSETSIGN","start","left","end","right","middle","center","bottom","top","appendArrayPointValue","convertStyle","gd","trace","i","opts","marker","undefined","markerSel","markerUnsel","line","fill","errorX","errorY","text","textSel","textUnsel","plotGlPixelRatio","_context","visible","hasText","convertTextStyle","convertTextSelection","selected","unselected","hasMarkers","convertMarkerStyle","convertMarkerSelection","isArrayOrTypedArray","opacity","mo","Array","length","hasLines","overlay","thickness","width","color","dashes","DASHES","dash","slice","error_x","convertErrorBarStyle","error_y","closed","fillcolor","fullLayout","_fullLayout","count","_length","textfontIn","textfont","textpositionIn","textposition","textPos","isArray","tfc","tfs","size","tff","family","optsOut","texttemplate","d3locale","_d3locale","N","Math","min","txt","d","labels","_module","formatLabels","pointValues","meta","_meta","push","texttemplateString","font","align","baseline","tp","split","fonti","isTypedArray","optsIn","multiSymbol","symbol","multiAngle","angle","multiColor","multiLineColor","multiOpacity","multiSize","multiLineWidth","isOpen","isOpenSymbol","symbols","angles","colors","borderColors","borderColor","markers","getSymbolSdf","mx","ma","sizeFactor","markerSizeFunc","s","sizes","borderSizes","sizeTotal","sizeAvg","target","extendFlat","capSize","lineWidth","copy_ystyle","SYMBOL_SDF_SIZE","SYMBOL_SIZE","SYMBOL_STROKE","SYMBOL_SDF","SYMBOL_SVG_CIRCLE","symbolFuncs","symbolPath","symbolSdf","symbolNumber","symbolFunc","symbolNoDot","symbolNoFill","isDot","isDotSymbol","getMarkerAngle","w","h","viewBox","stroke","convertLinePositions","positions","len","linePositions","shape","isNaN","NaN","midPtX","midPtY","hasNaN","join","TOO_MANY_POINTS","connectgaps","lastX","lastY","convertErrorBarPositions","x","y","makeComputeError","getComponentMethod","xa","getFromId","xaxis","ya","yaxis","out","convertOneAxis","coords","ax","axLetter","_id","charAt","type","computeError","pOffset","eOffset","errors","Float64Array","minShoe","Infinity","maxHat","j","dc","dl","vals","lv","hv","shoe","hat","c2l","max","_bnds","convertTextPosition","textOpts","markerOpts","fontOpts","offset","ms","fs","a","b","hSign","vSign","xPad","yPad","module","exports","style","markerStyle","markerSelection","errorBarPositions","textPosition"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/traces/scattergl/convert.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar TEXTOFFSETSIGN = {\n    start: 1, left: 1, end: -1, right: -1, middle: 0, center: 0, bottom: 1, top: -1\n};\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nfunction convertStyle(gd, trace) {\n    var i;\n\n    var opts = {\n        marker: undefined,\n        markerSel: undefined,\n        markerUnsel: undefined,\n        line: undefined,\n        fill: undefined,\n        errorX: undefined,\n        errorY: undefined,\n        text: undefined,\n        textSel: undefined,\n        textUnsel: undefined\n    };\n\n    var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n\n    if(trace.visible !== true) return opts;\n\n    if(subTypes.hasText(trace)) {\n        opts.text = convertTextStyle(gd, trace);\n        opts.textSel = convertTextSelection(gd, trace, trace.selected);\n        opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n    }\n\n    if(subTypes.hasMarkers(trace)) {\n        opts.marker = convertMarkerStyle(gd, trace);\n        opts.markerSel = convertMarkerSelection(gd, trace, trace.selected);\n        opts.markerUnsel = convertMarkerSelection(gd, trace, trace.unselected);\n\n        if(!trace.unselected && Lib.isArrayOrTypedArray(trace.marker.opacity)) {\n            var mo = trace.marker.opacity;\n            opts.markerUnsel.opacity = new Array(mo.length);\n            for(i = 0; i < mo.length; i++) {\n                opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n            }\n        }\n    }\n\n    if(subTypes.hasLines(trace)) {\n        opts.line = {\n            overlay: true,\n            thickness: trace.line.width * plotGlPixelRatio,\n            color: trace.line.color,\n            opacity: trace.opacity\n        };\n\n        var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n        for(i = 0; i < dashes.length; ++i) {\n            dashes[i] *= trace.line.width * plotGlPixelRatio;\n        }\n        opts.line.dashes = dashes;\n    }\n\n    if(trace.error_x && trace.error_x.visible) {\n        opts.errorX = convertErrorBarStyle(trace, trace.error_x, plotGlPixelRatio);\n    }\n\n    if(trace.error_y && trace.error_y.visible) {\n        opts.errorY = convertErrorBarStyle(trace, trace.error_y, plotGlPixelRatio);\n    }\n\n    if(!!trace.fill && trace.fill !== 'none') {\n        opts.fill = {\n            closed: true,\n            fill: trace.fillcolor,\n            thickness: 0\n        };\n    }\n\n    return opts;\n}\n\nfunction convertTextStyle(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var count = trace._length;\n    var textfontIn = trace.textfont;\n    var textpositionIn = trace.textposition;\n    var textPos = Array.isArray(textpositionIn) ? textpositionIn : [textpositionIn];\n    var tfc = textfontIn.color;\n    var tfs = textfontIn.size;\n    var tff = textfontIn.family;\n    var optsOut = {};\n    var i;\n    var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n\n    var texttemplate = trace.texttemplate;\n    if(texttemplate) {\n        optsOut.text = [];\n\n        var d3locale = fullLayout._d3locale;\n        var isArray = Array.isArray(texttemplate);\n        var N = isArray ? Math.min(texttemplate.length, count) : count;\n        var txt = isArray ?\n            function(i) { return texttemplate[i]; } :\n            function() { return texttemplate; };\n\n        for(i = 0; i < N; i++) {\n            var d = {i: i};\n            var labels = trace._module.formatLabels(d, trace, fullLayout);\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, i);\n            var meta = trace._meta || {};\n            optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n        }\n    } else {\n        if(Array.isArray(trace.text) && trace.text.length < count) {\n            // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n            optsOut.text = trace.text.slice();\n        } else {\n            optsOut.text = trace.text;\n        }\n    }\n    // pad text array with empty strings\n    if(Array.isArray(optsOut.text)) {\n        for(i = optsOut.text.length; i < count; i++) {\n            optsOut.text[i] = '';\n        }\n    }\n\n    optsOut.opacity = trace.opacity;\n    optsOut.font = {};\n    optsOut.align = [];\n    optsOut.baseline = [];\n\n    for(i = 0; i < textPos.length; i++) {\n        var tp = textPos[i].split(/\\s+/);\n\n        switch(tp[1]) {\n            case 'left':\n                optsOut.align.push('right');\n                break;\n            case 'right':\n                optsOut.align.push('left');\n                break;\n            default:\n                optsOut.align.push(tp[1]);\n        }\n        switch(tp[0]) {\n            case 'top':\n                optsOut.baseline.push('bottom');\n                break;\n            case 'bottom':\n                optsOut.baseline.push('top');\n                break;\n            default:\n                optsOut.baseline.push(tp[0]);\n        }\n    }\n\n    if(Array.isArray(tfc)) {\n        optsOut.color = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.color[i] = tfc[i];\n        }\n    } else {\n        optsOut.color = tfc;\n    }\n\n    if(Lib.isArrayOrTypedArray(tfs) || Array.isArray(tff)) {\n        // if any textfont param is array - make render a batch\n        optsOut.font = new Array(count);\n        for(i = 0; i < count; i++) {\n            var fonti = optsOut.font[i] = {};\n\n            fonti.size = (\n                Lib.isTypedArray(tfs) ? tfs[i] :\n                Array.isArray(tfs) ? (\n                    isNumeric(tfs[i]) ? tfs[i] : 0\n                ) : tfs\n            ) * plotGlPixelRatio;\n\n            fonti.family = Array.isArray(tff) ? tff[i] : tff;\n        }\n    } else {\n        // if both are single values, make render fast single-value\n        optsOut.font = {size: tfs * plotGlPixelRatio, family: tff};\n    }\n\n    return optsOut;\n}\n\n\nfunction convertMarkerStyle(gd, trace) {\n    var count = trace._length;\n    var optsIn = trace.marker;\n    var optsOut = {};\n    var i;\n\n    var multiSymbol = Lib.isArrayOrTypedArray(optsIn.symbol);\n    var multiAngle = Lib.isArrayOrTypedArray(optsIn.angle);\n    var multiColor = Lib.isArrayOrTypedArray(optsIn.color);\n    var multiLineColor = Lib.isArrayOrTypedArray(optsIn.line.color);\n    var multiOpacity = Lib.isArrayOrTypedArray(optsIn.opacity);\n    var multiSize = Lib.isArrayOrTypedArray(optsIn.size);\n    var multiLineWidth = Lib.isArrayOrTypedArray(optsIn.line.width);\n\n    var isOpen;\n    if(!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol);\n\n    // prepare colors\n    if(multiSymbol || multiColor || multiLineColor || multiOpacity || multiAngle) {\n        optsOut.symbols = new Array(count);\n        optsOut.angles = new Array(count);\n        optsOut.colors = new Array(count);\n        optsOut.borderColors = new Array(count);\n\n        var symbols = optsIn.symbol;\n        var angles = optsIn.angle;\n        var colors = formatColor(optsIn, optsIn.opacity, count);\n        var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n\n        if(!Array.isArray(borderColors[0])) {\n            var borderColor = borderColors;\n            borderColors = Array(count);\n            for(i = 0; i < count; i++) {\n                borderColors[i] = borderColor;\n            }\n        }\n        if(!Array.isArray(colors[0])) {\n            var color = colors;\n            colors = Array(count);\n            for(i = 0; i < count; i++) {\n                colors[i] = color;\n            }\n        }\n        if(!Array.isArray(symbols)) {\n            var symbol = symbols;\n            symbols = Array(count);\n            for(i = 0; i < count; i++) {\n                symbols[i] = symbol;\n            }\n        }\n        if(!Array.isArray(angles)) {\n            var angle = angles;\n            angles = Array(count);\n            for(i = 0; i < count; i++) {\n                angles[i] = angle;\n            }\n        }\n\n        optsOut.symbols = symbols;\n        optsOut.angles = angles;\n        optsOut.colors = colors;\n        optsOut.borderColors = borderColors;\n\n        for(i = 0; i < count; i++) {\n            if(multiSymbol) {\n                isOpen = helpers.isOpenSymbol(optsIn.symbol[i]);\n            }\n            if(isOpen) {\n                borderColors[i] = colors[i].slice();\n                colors[i] = colors[i].slice();\n                colors[i][3] = 0;\n            }\n        }\n\n        optsOut.opacity = trace.opacity;\n\n        optsOut.markers = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.markers[i] = getSymbolSdf({\n                mx: optsOut.symbols[i],\n                ma: optsOut.angles[i]\n            }, trace);\n        }\n    } else {\n        if(isOpen) {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.color[3] = 0;\n            optsOut.borderColor = rgba(optsIn.color, 'uint8');\n        } else {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n        }\n\n        optsOut.opacity = trace.opacity * optsIn.opacity;\n\n        optsOut.marker = getSymbolSdf({\n            mx: optsIn.symbol,\n            ma: optsIn.angle\n        }, trace);\n    }\n\n    // prepare sizes\n    var sizeFactor = 1;\n    var markerSizeFunc = makeBubbleSizeFn(trace, sizeFactor);\n    var s;\n\n    if(multiSize || multiLineWidth) {\n        var sizes = optsOut.sizes = new Array(count);\n        var borderSizes = optsOut.borderSizes = new Array(count);\n        var sizeTotal = 0;\n        var sizeAvg;\n\n        if(multiSize) {\n            for(i = 0; i < count; i++) {\n                sizes[i] = markerSizeFunc(optsIn.size[i]);\n                sizeTotal += sizes[i];\n            }\n            sizeAvg = sizeTotal / count;\n        } else {\n            s = markerSizeFunc(optsIn.size);\n            for(i = 0; i < count; i++) {\n                sizes[i] = s;\n            }\n        }\n\n        // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n        if(multiLineWidth) {\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = optsIn.line.width[i];\n            }\n        } else {\n            s = optsIn.line.width;\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = s;\n            }\n        }\n\n        optsOut.sizeAvg = sizeAvg;\n    } else {\n        optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n        optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n    }\n\n    return optsOut;\n}\n\nfunction convertMarkerSelection(gd, trace, target) {\n    var optsIn = trace.marker;\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.marker && target.marker.symbol) {\n        optsOut = convertMarkerStyle(gd, Lib.extendFlat({}, optsIn, target.marker));\n    } else if(target.marker) {\n        if(target.marker.size) optsOut.size = target.marker.size;\n        if(target.marker.color) optsOut.colors = target.marker.color;\n        if(target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n    }\n\n    return optsOut;\n}\n\nfunction convertTextSelection(gd, trace, target) {\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.textfont) {\n        var optsIn = {\n            opacity: 1,\n            text: trace.text,\n            texttemplate: trace.texttemplate,\n            textposition: trace.textposition,\n            textfont: Lib.extendFlat({}, trace.textfont)\n        };\n        if(target.textfont) {\n            Lib.extendFlat(optsIn.textfont, target.textfont);\n        }\n        optsOut = convertTextStyle(gd, optsIn);\n    }\n\n    return optsOut;\n}\n\nfunction convertErrorBarStyle(trace, target, plotGlPixelRatio) {\n    var optsOut = {\n        capSize: target.width * 2 * plotGlPixelRatio,\n        lineWidth: target.thickness * plotGlPixelRatio,\n        color: target.color\n    };\n\n    if(target.copy_ystyle) {\n        optsOut = trace.error_y;\n    }\n\n    return optsOut;\n}\n\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\n\nfunction getSymbolSdf(d, trace) {\n    var symbol = d.mx;\n    if(symbol === 'circle') return null;\n\n    var symbolPath, symbolSdf;\n    var symbolNumber = Drawing.symbolNumber(symbol);\n    var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n    var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n    var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n\n    var isDot = helpers.isDotSymbol(symbol);\n\n    // until we may handle angles in shader?\n    if(d.ma) symbol += '_' + d.ma;\n\n    // get symbol sdf from cache or generate it\n    if(SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n\n    var angle = Drawing.getMarkerAngle(d, trace);\n    if(isDot && !symbolNoDot) {\n        symbolPath = symbolFunc(SYMBOL_SIZE * 1.1, angle) + SYMBOL_SVG_CIRCLE;\n    } else {\n        symbolPath = symbolFunc(SYMBOL_SIZE, angle);\n    }\n\n    symbolSdf = svgSdf(symbolPath, {\n        w: SYMBOL_SDF_SIZE,\n        h: SYMBOL_SDF_SIZE,\n        viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n        stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n    });\n\n    SYMBOL_SDF[symbol] = symbolSdf;\n\n    return symbolSdf || null;\n}\n\nfunction convertLinePositions(gd, trace, positions) {\n    var len = positions.length;\n    var count = len / 2;\n    var linePositions;\n    var i;\n\n    if(subTypes.hasLines(trace) && count) {\n        if(trace.line.shape === 'hv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'hvh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 3]\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vhv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        positions[i * 2],\n                        midPtY,\n                        positions[i * 2 + 2],\n                        midPtY\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else {\n            linePositions = positions;\n        }\n    }\n\n    // If we have data with gaps, we ought to use rect joins\n    // FIXME: get rid of this\n    var hasNaN = false;\n    for(i = 0; i < linePositions.length; i++) {\n        if(isNaN(linePositions[i])) {\n            hasNaN = true;\n            break;\n        }\n    }\n\n    var join = (hasNaN || linePositions.length > constants.TOO_MANY_POINTS) ? 'rect' :\n        subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n    // fill gaps\n    if(hasNaN && trace.connectgaps) {\n        var lastX = linePositions[0];\n        var lastY = linePositions[1];\n\n        for(i = 0; i < linePositions.length; i += 2) {\n            if(isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n                linePositions[i] = lastX;\n                linePositions[i + 1] = lastY;\n            } else {\n                lastX = linePositions[i];\n                lastY = linePositions[i + 1];\n            }\n        }\n    }\n\n    return {\n        join: join,\n        positions: linePositions\n    };\n}\n\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n    var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n    var xa = AxisIDs.getFromId(gd, trace.xaxis, 'x');\n    var ya = AxisIDs.getFromId(gd, trace.yaxis, 'y');\n    var count = positions.length / 2;\n    var out = {};\n\n    function convertOneAxis(coords, ax) {\n        var axLetter = ax._id.charAt(0);\n        var opts = trace['error_' + axLetter];\n\n        if(opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n            var computeError = makeComputeError(opts);\n            var pOffset = {x: 0, y: 1}[axLetter];\n            var eOffset = {x: [0, 1, 2, 3], y: [2, 3, 0, 1]}[axLetter];\n            var errors = new Float64Array(4 * count);\n            var minShoe = Infinity;\n            var maxHat = -Infinity;\n\n            for(var i = 0, j = 0; i < count; i++, j += 4) {\n                var dc = coords[i];\n\n                if(isNumeric(dc)) {\n                    var dl = positions[i * 2 + pOffset];\n                    var vals = computeError(dc, i);\n                    var lv = vals[0];\n                    var hv = vals[1];\n\n                    if(isNumeric(lv) && isNumeric(hv)) {\n                        var shoe = dc - lv;\n                        var hat = dc + hv;\n\n                        errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n                        errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n                        errors[j + eOffset[2]] = 0;\n                        errors[j + eOffset[3]] = 0;\n\n                        minShoe = Math.min(minShoe, dc - lv);\n                        maxHat = Math.max(maxHat, dc + hv);\n                    }\n                }\n            }\n\n            out[axLetter] = {\n                positions: positions,\n                errors: errors,\n                _bnds: [minShoe, maxHat]\n            };\n        }\n    }\n\n    convertOneAxis(x, xa);\n    convertOneAxis(y, ya);\n    return out;\n}\n\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n    var count = trace._length;\n    var out = {};\n    var i;\n\n    // corresponds to textPointPosition from component.drawing\n    if(subTypes.hasMarkers(trace)) {\n        var fontOpts = textOpts.font;\n        var align = textOpts.align;\n        var baseline = textOpts.baseline;\n        out.offset = new Array(count);\n\n        for(i = 0; i < count; i++) {\n            var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n            var fs = Array.isArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n\n            var a = Array.isArray(align) ?\n                (align.length > 1 ? align[i] : align[0]) :\n                align;\n            var b = Array.isArray(baseline) ?\n                (baseline.length > 1 ? baseline[i] : baseline[0]) :\n                baseline;\n\n            var hSign = TEXTOFFSETSIGN[a];\n            var vSign = TEXTOFFSETSIGN[b];\n            var xPad = ms ? ms / 0.8 + 1 : 0;\n            var yPad = -vSign * xPad - vSign * 0.5;\n            out.offset[i] = [hSign * xPad / fs, yPad / fs];\n        }\n    }\n\n    return out;\n}\n\nmodule.exports = {\n    style: convertStyle,\n\n    markerStyle: convertMarkerStyle,\n    markerSelection: convertMarkerSelection,\n\n    linePositions: convertLinePositions,\n    errorBarPositions: convertErrorBarPositions,\n    textPosition: convertTextPosition\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}