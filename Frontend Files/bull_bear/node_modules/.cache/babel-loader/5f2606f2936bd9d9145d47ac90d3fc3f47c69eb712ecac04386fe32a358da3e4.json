{"ast":null,"code":"'use strict';\n\nvar Registry = require('../registry');\nvar SUBPLOT_PATTERN = require('./cartesian/constants').SUBPLOT_PATTERN;\n\n/**\n * Get calcdata trace(s) associated with a given subplot\n *\n * @param {array} calcData: as in gd.calcdata\n * @param {string} type: subplot type\n * @param {string} subplotId: subplot id to look for\n *\n * @return {array} array of calcdata traces\n */\nexports.getSubplotCalcData = function (calcData, type, subplotId) {\n  var basePlotModule = Registry.subplotsRegistry[type];\n  if (!basePlotModule) return [];\n  var attr = basePlotModule.attr;\n  var subplotCalcData = [];\n  for (var i = 0; i < calcData.length; i++) {\n    var calcTrace = calcData[i];\n    var trace = calcTrace[0].trace;\n    if (trace[attr] === subplotId) subplotCalcData.push(calcTrace);\n  }\n  return subplotCalcData;\n};\n/**\n * Get calcdata trace(s) that can be plotted with a given module\n * NOTE: this isn't necessarily just exactly matching trace type,\n * if multiple trace types use the same plotting routine, they will be\n * collected here.\n * In order to not plot the same thing multiple times, we return two arrays,\n * the calcdata we *will* plot with this module, and the ones we *won't*\n *\n * @param {array} calcdata: as in gd.calcdata\n * @param {object|string|fn} arg1:\n *  the plotting module, or its name, or its plot method\n *\n * @return {array[array]} [foundCalcdata, remainingCalcdata]\n */\nexports.getModuleCalcData = function (calcdata, arg1) {\n  var moduleCalcData = [];\n  var remainingCalcData = [];\n  var plotMethod;\n  if (typeof arg1 === 'string') {\n    plotMethod = Registry.getModule(arg1).plot;\n  } else if (typeof arg1 === 'function') {\n    plotMethod = arg1;\n  } else {\n    plotMethod = arg1.plot;\n  }\n  if (!plotMethod) {\n    return [moduleCalcData, calcdata];\n  }\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var trace = cd[0].trace;\n    // N.B.\n    // - 'legendonly' traces do not make it past here\n    // - skip over 'visible' traces that got trimmed completely during calc transforms\n    if (trace.visible !== true || trace._length === 0) continue;\n\n    // group calcdata trace not by 'module' (as the name of this function\n    // would suggest), but by 'module plot method' so that if some traces\n    // share the same module plot method (e.g. bar and histogram), we\n    // only call it one!\n    if (trace._module.plot === plotMethod) {\n      moduleCalcData.push(cd);\n    } else {\n      remainingCalcData.push(cd);\n    }\n  }\n  return [moduleCalcData, remainingCalcData];\n};\n\n/**\n * Get the data trace(s) associated with a given subplot.\n *\n * @param {array} data  plotly full data array.\n * @param {string} type subplot type to look for.\n * @param {string} subplotId subplot id to look for.\n *\n * @return {array} list of trace objects.\n *\n */\nexports.getSubplotData = function getSubplotData(data, type, subplotId) {\n  if (!Registry.subplotsRegistry[type]) return [];\n  var attr = Registry.subplotsRegistry[type].attr;\n  var subplotData = [];\n  var trace, subplotX, subplotY;\n  if (type === 'gl2d') {\n    var spmatch = subplotId.match(SUBPLOT_PATTERN);\n    subplotX = 'x' + spmatch[1];\n    subplotY = 'y' + spmatch[2];\n  }\n  for (var i = 0; i < data.length; i++) {\n    trace = data[i];\n    if (type === 'gl2d' && Registry.traceIs(trace, 'gl2d')) {\n      if (trace[attr[0]] === subplotX && trace[attr[1]] === subplotY) {\n        subplotData.push(trace);\n      }\n    } else {\n      if (trace[attr] === subplotId) subplotData.push(trace);\n    }\n  }\n  return subplotData;\n};","map":{"version":3,"names":["Registry","require","SUBPLOT_PATTERN","exports","getSubplotCalcData","calcData","type","subplotId","basePlotModule","subplotsRegistry","attr","subplotCalcData","i","length","calcTrace","trace","push","getModuleCalcData","calcdata","arg1","moduleCalcData","remainingCalcData","plotMethod","getModule","plot","cd","visible","_length","_module","getSubplotData","data","subplotData","subplotX","subplotY","spmatch","match","traceIs"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/plots/get_data.js"],"sourcesContent":["'use strict';\n\nvar Registry = require('../registry');\nvar SUBPLOT_PATTERN = require('./cartesian/constants').SUBPLOT_PATTERN;\n\n/**\n * Get calcdata trace(s) associated with a given subplot\n *\n * @param {array} calcData: as in gd.calcdata\n * @param {string} type: subplot type\n * @param {string} subplotId: subplot id to look for\n *\n * @return {array} array of calcdata traces\n */\nexports.getSubplotCalcData = function(calcData, type, subplotId) {\n    var basePlotModule = Registry.subplotsRegistry[type];\n    if(!basePlotModule) return [];\n\n    var attr = basePlotModule.attr;\n    var subplotCalcData = [];\n\n    for(var i = 0; i < calcData.length; i++) {\n        var calcTrace = calcData[i];\n        var trace = calcTrace[0].trace;\n\n        if(trace[attr] === subplotId) subplotCalcData.push(calcTrace);\n    }\n\n    return subplotCalcData;\n};\n/**\n * Get calcdata trace(s) that can be plotted with a given module\n * NOTE: this isn't necessarily just exactly matching trace type,\n * if multiple trace types use the same plotting routine, they will be\n * collected here.\n * In order to not plot the same thing multiple times, we return two arrays,\n * the calcdata we *will* plot with this module, and the ones we *won't*\n *\n * @param {array} calcdata: as in gd.calcdata\n * @param {object|string|fn} arg1:\n *  the plotting module, or its name, or its plot method\n *\n * @return {array[array]} [foundCalcdata, remainingCalcdata]\n */\nexports.getModuleCalcData = function(calcdata, arg1) {\n    var moduleCalcData = [];\n    var remainingCalcData = [];\n\n    var plotMethod;\n    if(typeof arg1 === 'string') {\n        plotMethod = Registry.getModule(arg1).plot;\n    } else if(typeof arg1 === 'function') {\n        plotMethod = arg1;\n    } else {\n        plotMethod = arg1.plot;\n    }\n    if(!plotMethod) {\n        return [moduleCalcData, calcdata];\n    }\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var trace = cd[0].trace;\n        // N.B.\n        // - 'legendonly' traces do not make it past here\n        // - skip over 'visible' traces that got trimmed completely during calc transforms\n        if(trace.visible !== true || trace._length === 0) continue;\n\n        // group calcdata trace not by 'module' (as the name of this function\n        // would suggest), but by 'module plot method' so that if some traces\n        // share the same module plot method (e.g. bar and histogram), we\n        // only call it one!\n        if(trace._module.plot === plotMethod) {\n            moduleCalcData.push(cd);\n        } else {\n            remainingCalcData.push(cd);\n        }\n    }\n\n    return [moduleCalcData, remainingCalcData];\n};\n\n/**\n * Get the data trace(s) associated with a given subplot.\n *\n * @param {array} data  plotly full data array.\n * @param {string} type subplot type to look for.\n * @param {string} subplotId subplot id to look for.\n *\n * @return {array} list of trace objects.\n *\n */\nexports.getSubplotData = function getSubplotData(data, type, subplotId) {\n    if(!Registry.subplotsRegistry[type]) return [];\n\n    var attr = Registry.subplotsRegistry[type].attr;\n    var subplotData = [];\n    var trace, subplotX, subplotY;\n\n    if(type === 'gl2d') {\n        var spmatch = subplotId.match(SUBPLOT_PATTERN);\n        subplotX = 'x' + spmatch[1];\n        subplotY = 'y' + spmatch[2];\n    }\n\n    for(var i = 0; i < data.length; i++) {\n        trace = data[i];\n\n        if(type === 'gl2d' && Registry.traceIs(trace, 'gl2d')) {\n            if(trace[attr[0]] === subplotX && trace[attr[1]] === subplotY) {\n                subplotData.push(trace);\n            }\n        } else {\n            if(trace[attr] === subplotId) subplotData.push(trace);\n        }\n    }\n\n    return subplotData;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}