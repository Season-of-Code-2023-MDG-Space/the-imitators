{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar autorange = require('./autorange');\nvar id2name = require('./axis_ids').id2name;\nvar layoutAttributes = require('./layout_attributes');\nvar scaleZoom = require('./scale_zoom');\nvar setConvert = require('./set_convert');\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\nexports.handleDefaults = function (layoutIn, layoutOut, opts) {\n  var axIds = opts.axIds;\n  var axHasImage = opts.axHasImage;\n\n  // sets of axes linked by `scaleanchor` OR `matches` along with the\n  // scaleratios compounded together, populated in handleConstraintDefaults\n  var constraintGroups = layoutOut._axisConstraintGroups = [];\n  // similar to _axisConstraintGroups, but only matching axes\n  var matchGroups = layoutOut._axisMatchGroups = [];\n  var i, group, axId, axName, axIn, axOut, attr, val;\n  for (i = 0; i < axIds.length; i++) {\n    axName = id2name(axIds[i]);\n    axIn = layoutIn[axName];\n    axOut = layoutOut[axName];\n    handleOneAxDefaults(axIn, axOut, {\n      axIds: axIds,\n      layoutOut: layoutOut,\n      hasImage: axHasImage[axName]\n    });\n  }\n\n  // save matchGroup on each matching axis\n  function stash(groups, stashAttr) {\n    for (i = 0; i < groups.length; i++) {\n      group = groups[i];\n      for (axId in group) {\n        layoutOut[id2name(axId)][stashAttr] = group;\n      }\n    }\n  }\n  stash(matchGroups, '_matchGroup');\n\n  // If any axis in a constraint group is fixedrange, they all get fixed\n  // This covers matches axes, as they're now in the constraintgroup too\n  // and have not yet been removed (if the group is *only* matching)\n  for (i = 0; i < constraintGroups.length; i++) {\n    group = constraintGroups[i];\n    for (axId in group) {\n      axOut = layoutOut[id2name(axId)];\n      if (axOut.fixedrange) {\n        for (var axId2 in group) {\n          var axName2 = id2name(axId2);\n          if ((layoutIn[axName2] || {}).fixedrange === false) {\n            Lib.warn('fixedrange was specified as false for axis ' + axName2 + ' but was overridden because another ' + 'axis in its constraint group has fixedrange true');\n          }\n          layoutOut[axName2].fixedrange = true;\n        }\n        break;\n      }\n    }\n  }\n\n  // remove constraint groups that simply duplicate match groups\n  i = 0;\n  while (i < constraintGroups.length) {\n    group = constraintGroups[i];\n    for (axId in group) {\n      axOut = layoutOut[id2name(axId)];\n      if (axOut._matchGroup && Object.keys(axOut._matchGroup).length === Object.keys(group).length) {\n        constraintGroups.splice(i, 1);\n        i--;\n      }\n      break;\n    }\n    i++;\n  }\n\n  // save constraintGroup on each constrained axis\n  stash(constraintGroups, '_constraintGroup');\n\n  // make sure `matching` axes share values of necessary attributes\n  // Precedence (base axis is the one that doesn't list a `matches`, ie others\n  // all point to it):\n  // (1) explicitly defined value in the base axis\n  // (2) explicitly defined in another axis (arbitrary order)\n  // (3) default in the base axis\n  var matchAttrs = ['constrain', 'range', 'autorange', 'rangemode', 'rangebreaks', 'categoryorder', 'categoryarray'];\n  var hasRange = false;\n  var hasDayOfWeekBreaks = false;\n  function setAttrVal() {\n    val = axOut[attr];\n    if (attr === 'rangebreaks') {\n      hasDayOfWeekBreaks = axOut._hasDayOfWeekBreaks;\n    }\n  }\n  for (i = 0; i < matchGroups.length; i++) {\n    group = matchGroups[i];\n\n    // find 'matching' range attrs\n    for (var j = 0; j < matchAttrs.length; j++) {\n      attr = matchAttrs[j];\n      val = null;\n      var baseAx;\n      for (axId in group) {\n        axName = id2name(axId);\n        axIn = layoutIn[axName];\n        axOut = layoutOut[axName];\n        if (!(attr in axOut)) {\n          continue;\n        }\n        if (!axOut.matches) {\n          baseAx = axOut;\n          // top priority: explicit value in base axis\n          if (attr in axIn) {\n            setAttrVal();\n            break;\n          }\n        }\n        if (val === null && attr in axIn) {\n          // second priority: first explicit value in another axis\n          setAttrVal();\n        }\n      }\n\n      // special logic for coupling of range and autorange\n      // if nobody explicitly specifies autorange, but someone does\n      // explicitly specify range, autorange must be disabled.\n      if (attr === 'range' && val) {\n        hasRange = true;\n      }\n      if (attr === 'autorange' && val === null && hasRange) {\n        val = false;\n      }\n      if (val === null && attr in baseAx) {\n        // fallback: default value in base axis\n        val = baseAx[attr];\n      }\n      // but we still might not have a value, which is fine.\n      if (val !== null) {\n        for (axId in group) {\n          axOut = layoutOut[id2name(axId)];\n          axOut[attr] = attr === 'range' ? val.slice() : val;\n          if (attr === 'rangebreaks') {\n            axOut._hasDayOfWeekBreaks = hasDayOfWeekBreaks;\n            setConvert(axOut, layoutOut);\n          }\n        }\n      }\n    }\n  }\n};\nfunction handleOneAxDefaults(axIn, axOut, opts) {\n  var axIds = opts.axIds;\n  var layoutOut = opts.layoutOut;\n  var hasImage = opts.hasImage;\n  var constraintGroups = layoutOut._axisConstraintGroups;\n  var matchGroups = layoutOut._axisMatchGroups;\n  var axId = axOut._id;\n  var axLetter = axId.charAt(0);\n  var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};\n  var thisID = axOut._id;\n  var isX = thisID.charAt(0) === 'x';\n\n  // Clear _matchGroup & _constraintGroup so relinkPrivateKeys doesn't keep\n  // an old one around. If this axis is in a group we'll set this again later\n  axOut._matchGroup = null;\n  axOut._constraintGroup = null;\n  function coerce(attr, dflt) {\n    return Lib.coerce(axIn, axOut, layoutAttributes, attr, dflt);\n  }\n\n  // coerce the constraint mechanics even if this axis has no scaleanchor\n  // because it may be the anchor of another axis.\n  coerce('constrain', hasImage ? 'domain' : 'range');\n  Lib.coerce(axIn, axOut, {\n    constraintoward: {\n      valType: 'enumerated',\n      values: isX ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n      dflt: isX ? 'center' : 'middle'\n    }\n  }, 'constraintoward');\n\n  // If this axis is already part of a constraint group, we can't\n  // scaleanchor any other axis in that group, or we'd make a loop.\n  // Filter axIds to enforce this, also matching axis types.\n  var thisType = axOut.type;\n  var i, idi;\n  var linkableAxes = [];\n  for (i = 0; i < axIds.length; i++) {\n    idi = axIds[i];\n    if (idi === thisID) continue;\n    var axi = layoutOut[id2name(idi)];\n    if (axi.type === thisType) {\n      linkableAxes.push(idi);\n    }\n  }\n  var thisGroup = getConstraintGroup(constraintGroups, thisID);\n  if (thisGroup) {\n    var linkableAxesNoLoops = [];\n    for (i = 0; i < linkableAxes.length; i++) {\n      idi = linkableAxes[i];\n      if (!thisGroup[idi]) linkableAxesNoLoops.push(idi);\n    }\n    linkableAxes = linkableAxesNoLoops;\n  }\n  var canLink = linkableAxes.length;\n  var matches, scaleanchor;\n  if (canLink && (axIn.matches || splomStash.matches)) {\n    matches = Lib.coerce(axIn, axOut, {\n      matches: {\n        valType: 'enumerated',\n        values: linkableAxes,\n        dflt: linkableAxes.indexOf(splomStash.matches) !== -1 ? splomStash.matches : undefined\n      }\n    }, 'matches');\n  }\n\n  // 'matches' wins over 'scaleanchor' - each axis can only specify one\n  // constraint, but you can chain matches and scaleanchor constraints by\n  // specifying them in separate axes.\n  var scaleanchorDflt = hasImage && !isX ? axOut.anchor : undefined;\n  if (canLink && !matches && (axIn.scaleanchor || scaleanchorDflt)) {\n    scaleanchor = Lib.coerce(axIn, axOut, {\n      scaleanchor: {\n        valType: 'enumerated',\n        values: linkableAxes\n      }\n    }, 'scaleanchor', scaleanchorDflt);\n  }\n  if (matches) {\n    axOut._matchGroup = updateConstraintGroups(matchGroups, thisID, matches, 1);\n\n    // Also include match constraints in the scale groups\n    var matchedAx = layoutOut[id2name(matches)];\n    var matchRatio = extent(layoutOut, axOut) / extent(layoutOut, matchedAx);\n    if (isX !== (matches.charAt(0) === 'x')) {\n      // We don't yet know the actual scale ratio of x/y matches constraints,\n      // due to possible automargins, so just leave a placeholder for this:\n      // 'x' means \"x size over y size\", 'y' means the inverse.\n      // in principle in the constraint group you could get multiple of these.\n      matchRatio = (isX ? 'x' : 'y') + matchRatio;\n    }\n    updateConstraintGroups(constraintGroups, thisID, matches, matchRatio);\n  } else if (axIn.matches && axIds.indexOf(axIn.matches) !== -1) {\n    Lib.warn('ignored ' + axOut._name + '.matches: \"' + axIn.matches + '\" to avoid an infinite loop');\n  }\n  if (scaleanchor) {\n    var scaleratio = coerce('scaleratio');\n\n    // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n    // but that seems hacky. Better way to say \"must be a positive number\"?\n    // Of course if you use several super-tiny values you could eventually\n    // force a product of these to zero and all hell would break loose...\n    // Likewise with super-huge values.\n    if (!scaleratio) scaleratio = axOut.scaleratio = 1;\n    updateConstraintGroups(constraintGroups, thisID, scaleanchor, scaleratio);\n  } else if (axIn.scaleanchor && axIds.indexOf(axIn.scaleanchor) !== -1) {\n    Lib.warn('ignored ' + axOut._name + '.scaleanchor: \"' + axIn.scaleanchor + '\" to avoid either an infinite loop ' + 'and possibly inconsistent scaleratios, or because this axis ' + 'declares a *matches* constraint.');\n  }\n}\nfunction extent(layoutOut, ax) {\n  var domain = ax.domain;\n  if (!domain) {\n    // at this point overlaying axes haven't yet inherited their main domains\n    // TODO: constrain: domain with overlaying axes is likely a bug.\n    domain = layoutOut[id2name(ax.overlaying)].domain;\n  }\n  return domain[1] - domain[0];\n}\nfunction getConstraintGroup(groups, thisID) {\n  for (var i = 0; i < groups.length; i++) {\n    if (groups[i][thisID]) {\n      return groups[i];\n    }\n  }\n  return null;\n}\n\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale (or matching).\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * thatID: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the thatID axis\n */\nfunction updateConstraintGroups(constraintGroups, thisID, thatID, scaleratio) {\n  var i, j, groupi, keyj, thisGroupIndex;\n  var thisGroup = getConstraintGroup(constraintGroups, thisID);\n  if (thisGroup === null) {\n    thisGroup = {};\n    thisGroup[thisID] = 1;\n    thisGroupIndex = constraintGroups.length;\n    constraintGroups.push(thisGroup);\n  } else {\n    thisGroupIndex = constraintGroups.indexOf(thisGroup);\n  }\n  var thisGroupKeys = Object.keys(thisGroup);\n\n  // we know that this axis isn't in any other groups, but we don't know\n  // about the thatID axis. If it is, we need to merge the groups.\n  for (i = 0; i < constraintGroups.length; i++) {\n    groupi = constraintGroups[i];\n    if (i !== thisGroupIndex && groupi[thatID]) {\n      var baseScale = groupi[thatID];\n      for (j = 0; j < thisGroupKeys.length; j++) {\n        keyj = thisGroupKeys[j];\n        groupi[keyj] = multiplyScales(baseScale, multiplyScales(scaleratio, thisGroup[keyj]));\n      }\n      constraintGroups.splice(thisGroupIndex, 1);\n      return;\n    }\n  }\n\n  // otherwise, we insert the new thatID axis as the base scale (1)\n  // in its group, and scale the rest of the group to it\n  if (scaleratio !== 1) {\n    for (j = 0; j < thisGroupKeys.length; j++) {\n      var key = thisGroupKeys[j];\n      thisGroup[key] = multiplyScales(scaleratio, thisGroup[key]);\n    }\n  }\n  thisGroup[thatID] = 1;\n}\n\n// scales may be numbers or 'x1.3', 'yy4.5' etc to multiply by as-yet-unknown\n// ratios between x and y plot sizes n times\nfunction multiplyScales(a, b) {\n  var aPrefix = '';\n  var bPrefix = '';\n  var aLen, bLen;\n  if (typeof a === 'string') {\n    aPrefix = a.match(/^[xy]*/)[0];\n    aLen = aPrefix.length;\n    a = +a.substr(aLen);\n  }\n  if (typeof b === 'string') {\n    bPrefix = b.match(/^[xy]*/)[0];\n    bLen = bPrefix.length;\n    b = +b.substr(bLen);\n  }\n  var c = a * b;\n\n  // just two numbers\n  if (!aLen && !bLen) {\n    return c;\n  }\n\n  // one or more prefixes of the same type\n  if (!aLen || !bLen || aPrefix.charAt(0) === bPrefix.charAt(0)) {\n    return aPrefix + bPrefix + a * b;\n  }\n\n  // x and y cancel each other out exactly - back to a number\n  if (aLen === bLen) {\n    return c;\n  }\n\n  // partial cancelation of prefixes\n  return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c;\n}\nfunction finalRatios(group, fullLayout) {\n  var size = fullLayout._size;\n  var yRatio = size.h / size.w;\n  var out = {};\n  var keys = Object.keys(group);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var val = group[key];\n    if (typeof val === 'string') {\n      var prefix = val.match(/^[xy]*/)[0];\n      var pLen = prefix.length;\n      val = +val.substr(pLen);\n      var mult = prefix.charAt(0) === 'y' ? yRatio : 1 / yRatio;\n      for (var j = 0; j < pLen; j++) {\n        val *= mult;\n      }\n    }\n    out[key] = val;\n  }\n  return out;\n}\nexports.enforce = function enforce(gd) {\n  var fullLayout = gd._fullLayout;\n  var constraintGroups = fullLayout._axisConstraintGroups || [];\n  var i, j, group, axisID, ax, normScale, mode, factor;\n\n  // matching constraints are handled in the autorange code when autoranged,\n  // or in the supplyDefaults code when explicitly ranged.\n  // now we just need to handle scaleanchor constraints\n  // matches constraints that chain with scaleanchor constraints are included\n  // here too, but because matches has already been satisfied,\n  // any changes here should preserve that.\n  for (i = 0; i < constraintGroups.length; i++) {\n    group = finalRatios(constraintGroups[i], fullLayout);\n    var axisIDs = Object.keys(group);\n    var minScale = Infinity;\n    var maxScale = 0;\n    // mostly matchScale will be the same as minScale\n    // ie we expand axis ranges to encompass *everything*\n    // that's currently in any of their ranges, but during\n    // autorange of a subset of axes we will ignore other\n    // axes for this purpose.\n    var matchScale = Infinity;\n    var normScales = {};\n    var axes = {};\n    var hasAnyDomainConstraint = false;\n\n    // find the (normalized) scale of each axis in the group\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      axes[axisID] = ax = fullLayout[id2name(axisID)];\n      if (ax._inputDomain) ax.domain = ax._inputDomain.slice();else ax._inputDomain = ax.domain.slice();\n      if (!ax._inputRange) ax._inputRange = ax.range.slice();\n\n      // set axis scale here so we can use _m rather than\n      // having to calculate it from length and range\n      ax.setScale();\n\n      // abs: inverted scales still satisfy the constraint\n      normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n      minScale = Math.min(minScale, normScale);\n      if (ax.constrain === 'domain' || !ax._constraintShrinkable) {\n        matchScale = Math.min(matchScale, normScale);\n      }\n\n      // this has served its purpose, so remove it\n      delete ax._constraintShrinkable;\n      maxScale = Math.max(maxScale, normScale);\n      if (ax.constrain === 'domain') hasAnyDomainConstraint = true;\n    }\n\n    // Do we have a constraint mismatch? Give a small buffer for rounding errors\n    if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;\n\n    // now increase any ranges we need to until all normalized scales are equal\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      normScale = normScales[axisID];\n      ax = axes[axisID];\n      mode = ax.constrain;\n\n      // even if the scale didn't change, if we're shrinking domain\n      // we need to recalculate in case `constraintoward` changed\n      if (normScale !== matchScale || mode === 'domain') {\n        factor = normScale / matchScale;\n        if (mode === 'range') {\n          scaleZoom(ax, factor);\n        } else {\n          // mode === 'domain'\n\n          var inputDomain = ax._inputDomain;\n          var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);\n          var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n          factor /= domainShrunk;\n          if (factor * rangeShrunk < 1) {\n            // we've asked to magnify the axis more than we can just by\n            // enlarging the domain - so we need to constrict range\n            ax.domain = ax._input.domain = inputDomain.slice();\n            scaleZoom(ax, factor);\n            continue;\n          }\n          if (rangeShrunk < 1) {\n            // the range has previously been constricted by ^^, but we've\n            // switched to the domain-constricted regime, so reset range\n            ax.range = ax._input.range = ax._inputRange.slice();\n            factor *= rangeShrunk;\n          }\n          if (ax.autorange) {\n            /*\n             * range & factor may need to change because range was\n             * calculated for the larger scaling, so some pixel\n             * paddings may get cut off when we reduce the domain.\n             *\n             * This is easier than the regular autorange calculation\n             * because we already know the scaling `m`, but we still\n             * need to cut out impossible constraints (like\n             * annotations with super-long arrows). That's what\n             * outerMin/Max are for - if the expansion was going to\n             * go beyond the original domain, it must be impossible\n             */\n            var rl0 = ax.r2l(ax.range[0]);\n            var rl1 = ax.r2l(ax.range[1]);\n            var rangeCenter = (rl0 + rl1) / 2;\n            var rangeMin = rangeCenter;\n            var rangeMax = rangeCenter;\n            var halfRange = Math.abs(rl1 - rangeCenter);\n            // extra tiny bit for rounding errors, in case we actually\n            // *are* expanding to the full domain\n            var outerMin = rangeCenter - halfRange * factor * 1.0001;\n            var outerMax = rangeCenter + halfRange * factor * 1.0001;\n            var getPadMin = autorange.makePadFn(fullLayout, ax, 0);\n            var getPadMax = autorange.makePadFn(fullLayout, ax, 1);\n            updateDomain(ax, factor);\n            var m = Math.abs(ax._m);\n            var extremes = autorange.concatExtremes(gd, ax);\n            var minArray = extremes.min;\n            var maxArray = extremes.max;\n            var newVal;\n            var k;\n            for (k = 0; k < minArray.length; k++) {\n              newVal = minArray[k].val - getPadMin(minArray[k]) / m;\n              if (newVal > outerMin && newVal < rangeMin) {\n                rangeMin = newVal;\n              }\n            }\n            for (k = 0; k < maxArray.length; k++) {\n              newVal = maxArray[k].val + getPadMax(maxArray[k]) / m;\n              if (newVal < outerMax && newVal > rangeMax) {\n                rangeMax = newVal;\n              }\n            }\n            var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n            factor /= domainExpand;\n            rangeMin = ax.l2r(rangeMin);\n            rangeMax = ax.l2r(rangeMax);\n            ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];\n          }\n          updateDomain(ax, factor);\n        }\n      }\n    }\n  }\n};\nexports.getAxisGroup = function getAxisGroup(fullLayout, axId) {\n  var matchGroups = fullLayout._axisMatchGroups;\n  for (var i = 0; i < matchGroups.length; i++) {\n    var group = matchGroups[i];\n    if (group[axId]) return 'g' + i;\n  }\n  return axId;\n};\n\n// For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\nexports.clean = function clean(gd, ax) {\n  if (ax._inputDomain) {\n    var isConstrained = false;\n    var axId = ax._id;\n    var constraintGroups = gd._fullLayout._axisConstraintGroups;\n    for (var j = 0; j < constraintGroups.length; j++) {\n      if (constraintGroups[j][axId]) {\n        isConstrained = true;\n        break;\n      }\n    }\n    if (!isConstrained || ax.constrain !== 'domain') {\n      ax._input.domain = ax.domain = ax._inputDomain;\n      delete ax._inputDomain;\n    }\n  }\n};\nfunction updateDomain(ax, factor) {\n  var inputDomain = ax._inputDomain;\n  var centerFraction = FROM_BL[ax.constraintoward];\n  var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n  ax.domain = ax._input.domain = [center + (inputDomain[0] - center) / factor, center + (inputDomain[1] - center) / factor];\n  ax.setScale();\n}","map":{"version":3,"names":["Lib","require","autorange","id2name","layoutAttributes","scaleZoom","setConvert","ALMOST_EQUAL","FROM_BL","exports","handleDefaults","layoutIn","layoutOut","opts","axIds","axHasImage","constraintGroups","_axisConstraintGroups","matchGroups","_axisMatchGroups","i","group","axId","axName","axIn","axOut","attr","val","length","handleOneAxDefaults","hasImage","stash","groups","stashAttr","fixedrange","axId2","axName2","warn","_matchGroup","Object","keys","splice","matchAttrs","hasRange","hasDayOfWeekBreaks","setAttrVal","_hasDayOfWeekBreaks","j","baseAx","matches","slice","_id","axLetter","charAt","splomStash","_splomAxes","thisID","isX","_constraintGroup","coerce","dflt","constraintoward","valType","values","thisType","type","idi","linkableAxes","axi","push","thisGroup","getConstraintGroup","linkableAxesNoLoops","canLink","scaleanchor","indexOf","undefined","scaleanchorDflt","anchor","updateConstraintGroups","matchedAx","matchRatio","extent","_name","scaleratio","ax","domain","overlaying","thatID","groupi","keyj","thisGroupIndex","thisGroupKeys","baseScale","multiplyScales","key","a","b","aPrefix","bPrefix","aLen","bLen","match","substr","c","finalRatios","fullLayout","size","_size","yRatio","h","w","out","prefix","pLen","mult","enforce","gd","_fullLayout","axisID","normScale","mode","factor","axisIDs","minScale","Infinity","maxScale","matchScale","normScales","axes","hasAnyDomainConstraint","_inputDomain","_inputRange","range","setScale","Math","abs","_m","min","constrain","_constraintShrinkable","max","inputDomain","domainShrunk","rangeShrunk","r2l","_input","rl0","rl1","rangeCenter","rangeMin","rangeMax","halfRange","outerMin","outerMax","getPadMin","makePadFn","getPadMax","updateDomain","m","extremes","concatExtremes","minArray","maxArray","newVal","k","domainExpand","l2r","getAxisGroup","clean","isConstrained","centerFraction","center"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/plots/cartesian/constraints.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\nvar autorange = require('./autorange');\nvar id2name = require('./axis_ids').id2name;\nvar layoutAttributes = require('./layout_attributes');\nvar scaleZoom = require('./scale_zoom');\nvar setConvert = require('./set_convert');\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\n\nexports.handleDefaults = function(layoutIn, layoutOut, opts) {\n    var axIds = opts.axIds;\n    var axHasImage = opts.axHasImage;\n\n    // sets of axes linked by `scaleanchor` OR `matches` along with the\n    // scaleratios compounded together, populated in handleConstraintDefaults\n    var constraintGroups = layoutOut._axisConstraintGroups = [];\n    // similar to _axisConstraintGroups, but only matching axes\n    var matchGroups = layoutOut._axisMatchGroups = [];\n\n    var i, group, axId, axName, axIn, axOut, attr, val;\n\n    for(i = 0; i < axIds.length; i++) {\n        axName = id2name(axIds[i]);\n        axIn = layoutIn[axName];\n        axOut = layoutOut[axName];\n\n        handleOneAxDefaults(axIn, axOut, {\n            axIds: axIds,\n            layoutOut: layoutOut,\n            hasImage: axHasImage[axName]\n        });\n    }\n\n    // save matchGroup on each matching axis\n    function stash(groups, stashAttr) {\n        for(i = 0; i < groups.length; i++) {\n            group = groups[i];\n            for(axId in group) {\n                layoutOut[id2name(axId)][stashAttr] = group;\n            }\n        }\n    }\n    stash(matchGroups, '_matchGroup');\n\n    // If any axis in a constraint group is fixedrange, they all get fixed\n    // This covers matches axes, as they're now in the constraintgroup too\n    // and have not yet been removed (if the group is *only* matching)\n    for(i = 0; i < constraintGroups.length; i++) {\n        group = constraintGroups[i];\n        for(axId in group) {\n            axOut = layoutOut[id2name(axId)];\n            if(axOut.fixedrange) {\n                for(var axId2 in group) {\n                    var axName2 = id2name(axId2);\n                    if((layoutIn[axName2] || {}).fixedrange === false) {\n                        Lib.warn(\n                            'fixedrange was specified as false for axis ' +\n                            axName2 + ' but was overridden because another ' +\n                            'axis in its constraint group has fixedrange true'\n                        );\n                    }\n                    layoutOut[axName2].fixedrange = true;\n                }\n                break;\n            }\n        }\n    }\n\n    // remove constraint groups that simply duplicate match groups\n    i = 0;\n    while(i < constraintGroups.length) {\n        group = constraintGroups[i];\n        for(axId in group) {\n            axOut = layoutOut[id2name(axId)];\n            if(axOut._matchGroup && Object.keys(axOut._matchGroup).length === Object.keys(group).length) {\n                constraintGroups.splice(i, 1);\n                i--;\n            }\n            break;\n        }\n        i++;\n    }\n\n    // save constraintGroup on each constrained axis\n    stash(constraintGroups, '_constraintGroup');\n\n    // make sure `matching` axes share values of necessary attributes\n    // Precedence (base axis is the one that doesn't list a `matches`, ie others\n    // all point to it):\n    // (1) explicitly defined value in the base axis\n    // (2) explicitly defined in another axis (arbitrary order)\n    // (3) default in the base axis\n    var matchAttrs = [\n        'constrain',\n        'range',\n        'autorange',\n        'rangemode',\n        'rangebreaks',\n        'categoryorder',\n        'categoryarray'\n    ];\n    var hasRange = false;\n    var hasDayOfWeekBreaks = false;\n\n    function setAttrVal() {\n        val = axOut[attr];\n        if(attr === 'rangebreaks') {\n            hasDayOfWeekBreaks = axOut._hasDayOfWeekBreaks;\n        }\n    }\n\n    for(i = 0; i < matchGroups.length; i++) {\n        group = matchGroups[i];\n\n        // find 'matching' range attrs\n        for(var j = 0; j < matchAttrs.length; j++) {\n            attr = matchAttrs[j];\n            val = null;\n            var baseAx;\n            for(axId in group) {\n                axName = id2name(axId);\n                axIn = layoutIn[axName];\n                axOut = layoutOut[axName];\n                if(!(attr in axOut)) {\n                    continue;\n                }\n                if(!axOut.matches) {\n                    baseAx = axOut;\n                    // top priority: explicit value in base axis\n                    if(attr in axIn) {\n                        setAttrVal();\n                        break;\n                    }\n                }\n                if(val === null && attr in axIn) {\n                    // second priority: first explicit value in another axis\n                    setAttrVal();\n                }\n            }\n\n            // special logic for coupling of range and autorange\n            // if nobody explicitly specifies autorange, but someone does\n            // explicitly specify range, autorange must be disabled.\n            if(attr === 'range' && val) {\n                hasRange = true;\n            }\n            if(attr === 'autorange' && val === null && hasRange) {\n                val = false;\n            }\n\n            if(val === null && attr in baseAx) {\n                // fallback: default value in base axis\n                val = baseAx[attr];\n            }\n            // but we still might not have a value, which is fine.\n            if(val !== null) {\n                for(axId in group) {\n                    axOut = layoutOut[id2name(axId)];\n                    axOut[attr] = attr === 'range' ? val.slice() : val;\n\n                    if(attr === 'rangebreaks') {\n                        axOut._hasDayOfWeekBreaks = hasDayOfWeekBreaks;\n                        setConvert(axOut, layoutOut);\n                    }\n                }\n            }\n        }\n    }\n};\n\nfunction handleOneAxDefaults(axIn, axOut, opts) {\n    var axIds = opts.axIds;\n    var layoutOut = opts.layoutOut;\n    var hasImage = opts.hasImage;\n    var constraintGroups = layoutOut._axisConstraintGroups;\n    var matchGroups = layoutOut._axisMatchGroups;\n    var axId = axOut._id;\n    var axLetter = axId.charAt(0);\n    var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};\n    var thisID = axOut._id;\n    var isX = thisID.charAt(0) === 'x';\n\n    // Clear _matchGroup & _constraintGroup so relinkPrivateKeys doesn't keep\n    // an old one around. If this axis is in a group we'll set this again later\n    axOut._matchGroup = null;\n    axOut._constraintGroup = null;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(axIn, axOut, layoutAttributes, attr, dflt);\n    }\n\n    // coerce the constraint mechanics even if this axis has no scaleanchor\n    // because it may be the anchor of another axis.\n    coerce('constrain', hasImage ? 'domain' : 'range');\n    Lib.coerce(axIn, axOut, {\n        constraintoward: {\n            valType: 'enumerated',\n            values: isX ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n            dflt: isX ? 'center' : 'middle'\n        }\n    }, 'constraintoward');\n\n    // If this axis is already part of a constraint group, we can't\n    // scaleanchor any other axis in that group, or we'd make a loop.\n    // Filter axIds to enforce this, also matching axis types.\n    var thisType = axOut.type;\n    var i, idi;\n\n    var linkableAxes = [];\n    for(i = 0; i < axIds.length; i++) {\n        idi = axIds[i];\n        if(idi === thisID) continue;\n\n        var axi = layoutOut[id2name(idi)];\n        if(axi.type === thisType) {\n            linkableAxes.push(idi);\n        }\n    }\n\n    var thisGroup = getConstraintGroup(constraintGroups, thisID);\n    if(thisGroup) {\n        var linkableAxesNoLoops = [];\n        for(i = 0; i < linkableAxes.length; i++) {\n            idi = linkableAxes[i];\n            if(!thisGroup[idi]) linkableAxesNoLoops.push(idi);\n        }\n        linkableAxes = linkableAxesNoLoops;\n    }\n\n    var canLink = linkableAxes.length;\n\n    var matches, scaleanchor;\n\n    if(canLink && (axIn.matches || splomStash.matches)) {\n        matches = Lib.coerce(axIn, axOut, {\n            matches: {\n                valType: 'enumerated',\n                values: linkableAxes,\n                dflt: linkableAxes.indexOf(splomStash.matches) !== -1 ? splomStash.matches : undefined\n            }\n        }, 'matches');\n    }\n\n    // 'matches' wins over 'scaleanchor' - each axis can only specify one\n    // constraint, but you can chain matches and scaleanchor constraints by\n    // specifying them in separate axes.\n    var scaleanchorDflt = hasImage && !isX ? axOut.anchor : undefined;\n    if(canLink && !matches && (axIn.scaleanchor || scaleanchorDflt)) {\n        scaleanchor = Lib.coerce(axIn, axOut, {\n            scaleanchor: {\n                valType: 'enumerated',\n                values: linkableAxes\n            }\n        }, 'scaleanchor', scaleanchorDflt);\n    }\n\n    if(matches) {\n        axOut._matchGroup = updateConstraintGroups(matchGroups, thisID, matches, 1);\n\n        // Also include match constraints in the scale groups\n        var matchedAx = layoutOut[id2name(matches)];\n        var matchRatio = extent(layoutOut, axOut) / extent(layoutOut, matchedAx);\n        if(isX !== (matches.charAt(0) === 'x')) {\n            // We don't yet know the actual scale ratio of x/y matches constraints,\n            // due to possible automargins, so just leave a placeholder for this:\n            // 'x' means \"x size over y size\", 'y' means the inverse.\n            // in principle in the constraint group you could get multiple of these.\n            matchRatio = (isX ? 'x' : 'y') + matchRatio;\n        }\n        updateConstraintGroups(constraintGroups, thisID, matches, matchRatio);\n    } else if(axIn.matches && axIds.indexOf(axIn.matches) !== -1) {\n        Lib.warn('ignored ' + axOut._name + '.matches: \"' +\n            axIn.matches + '\" to avoid an infinite loop');\n    }\n\n    if(scaleanchor) {\n        var scaleratio = coerce('scaleratio');\n\n        // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n        // but that seems hacky. Better way to say \"must be a positive number\"?\n        // Of course if you use several super-tiny values you could eventually\n        // force a product of these to zero and all hell would break loose...\n        // Likewise with super-huge values.\n        if(!scaleratio) scaleratio = axOut.scaleratio = 1;\n\n        updateConstraintGroups(constraintGroups, thisID, scaleanchor, scaleratio);\n    } else if(axIn.scaleanchor && axIds.indexOf(axIn.scaleanchor) !== -1) {\n        Lib.warn('ignored ' + axOut._name + '.scaleanchor: \"' +\n            axIn.scaleanchor + '\" to avoid either an infinite loop ' +\n            'and possibly inconsistent scaleratios, or because this axis ' +\n            'declares a *matches* constraint.');\n    }\n}\n\nfunction extent(layoutOut, ax) {\n    var domain = ax.domain;\n    if(!domain) {\n        // at this point overlaying axes haven't yet inherited their main domains\n        // TODO: constrain: domain with overlaying axes is likely a bug.\n        domain = layoutOut[id2name(ax.overlaying)].domain;\n    }\n    return domain[1] - domain[0];\n}\n\nfunction getConstraintGroup(groups, thisID) {\n    for(var i = 0; i < groups.length; i++) {\n        if(groups[i][thisID]) {\n            return groups[i];\n        }\n    }\n    return null;\n}\n\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale (or matching).\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * thatID: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the thatID axis\n */\nfunction updateConstraintGroups(constraintGroups, thisID, thatID, scaleratio) {\n    var i, j, groupi, keyj, thisGroupIndex;\n\n    var thisGroup = getConstraintGroup(constraintGroups, thisID);\n\n    if(thisGroup === null) {\n        thisGroup = {};\n        thisGroup[thisID] = 1;\n        thisGroupIndex = constraintGroups.length;\n        constraintGroups.push(thisGroup);\n    } else {\n        thisGroupIndex = constraintGroups.indexOf(thisGroup);\n    }\n\n    var thisGroupKeys = Object.keys(thisGroup);\n\n    // we know that this axis isn't in any other groups, but we don't know\n    // about the thatID axis. If it is, we need to merge the groups.\n    for(i = 0; i < constraintGroups.length; i++) {\n        groupi = constraintGroups[i];\n        if(i !== thisGroupIndex && groupi[thatID]) {\n            var baseScale = groupi[thatID];\n            for(j = 0; j < thisGroupKeys.length; j++) {\n                keyj = thisGroupKeys[j];\n                groupi[keyj] = multiplyScales(baseScale, multiplyScales(scaleratio, thisGroup[keyj]));\n            }\n            constraintGroups.splice(thisGroupIndex, 1);\n            return;\n        }\n    }\n\n    // otherwise, we insert the new thatID axis as the base scale (1)\n    // in its group, and scale the rest of the group to it\n    if(scaleratio !== 1) {\n        for(j = 0; j < thisGroupKeys.length; j++) {\n            var key = thisGroupKeys[j];\n            thisGroup[key] = multiplyScales(scaleratio, thisGroup[key]);\n        }\n    }\n    thisGroup[thatID] = 1;\n}\n\n// scales may be numbers or 'x1.3', 'yy4.5' etc to multiply by as-yet-unknown\n// ratios between x and y plot sizes n times\nfunction multiplyScales(a, b) {\n    var aPrefix = '';\n    var bPrefix = '';\n    var aLen, bLen;\n\n    if(typeof a === 'string') {\n        aPrefix = a.match(/^[xy]*/)[0];\n        aLen = aPrefix.length;\n        a = +a.substr(aLen);\n    }\n\n    if(typeof b === 'string') {\n        bPrefix = b.match(/^[xy]*/)[0];\n        bLen = bPrefix.length;\n        b = +b.substr(bLen);\n    }\n\n    var c = a * b;\n\n    // just two numbers\n    if(!aLen && !bLen) {\n        return c;\n    }\n\n    // one or more prefixes of the same type\n    if(!aLen || !bLen || aPrefix.charAt(0) === bPrefix.charAt(0)) {\n        return aPrefix + bPrefix + (a * b);\n    }\n\n    // x and y cancel each other out exactly - back to a number\n    if(aLen === bLen) {\n        return c;\n    }\n\n    // partial cancelation of prefixes\n    return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c;\n}\n\nfunction finalRatios(group, fullLayout) {\n    var size = fullLayout._size;\n    var yRatio = size.h / size.w;\n    var out = {};\n    var keys = Object.keys(group);\n    for(var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var val = group[key];\n\n        if(typeof val === 'string') {\n            var prefix = val.match(/^[xy]*/)[0];\n            var pLen = prefix.length;\n            val = +val.substr(pLen);\n            var mult = prefix.charAt(0) === 'y' ? yRatio : (1 / yRatio);\n            for(var j = 0; j < pLen; j++) {\n                val *= mult;\n            }\n        }\n\n        out[key] = val;\n    }\n    return out;\n}\n\nexports.enforce = function enforce(gd) {\n    var fullLayout = gd._fullLayout;\n    var constraintGroups = fullLayout._axisConstraintGroups || [];\n\n    var i, j, group, axisID, ax, normScale, mode, factor;\n\n    // matching constraints are handled in the autorange code when autoranged,\n    // or in the supplyDefaults code when explicitly ranged.\n    // now we just need to handle scaleanchor constraints\n    // matches constraints that chain with scaleanchor constraints are included\n    // here too, but because matches has already been satisfied,\n    // any changes here should preserve that.\n    for(i = 0; i < constraintGroups.length; i++) {\n        group = finalRatios(constraintGroups[i], fullLayout);\n        var axisIDs = Object.keys(group);\n\n        var minScale = Infinity;\n        var maxScale = 0;\n        // mostly matchScale will be the same as minScale\n        // ie we expand axis ranges to encompass *everything*\n        // that's currently in any of their ranges, but during\n        // autorange of a subset of axes we will ignore other\n        // axes for this purpose.\n        var matchScale = Infinity;\n        var normScales = {};\n        var axes = {};\n        var hasAnyDomainConstraint = false;\n\n        // find the (normalized) scale of each axis in the group\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            axes[axisID] = ax = fullLayout[id2name(axisID)];\n\n            if(ax._inputDomain) ax.domain = ax._inputDomain.slice();\n            else ax._inputDomain = ax.domain.slice();\n\n            if(!ax._inputRange) ax._inputRange = ax.range.slice();\n\n            // set axis scale here so we can use _m rather than\n            // having to calculate it from length and range\n            ax.setScale();\n\n            // abs: inverted scales still satisfy the constraint\n            normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n            minScale = Math.min(minScale, normScale);\n            if(ax.constrain === 'domain' || !ax._constraintShrinkable) {\n                matchScale = Math.min(matchScale, normScale);\n            }\n\n            // this has served its purpose, so remove it\n            delete ax._constraintShrinkable;\n            maxScale = Math.max(maxScale, normScale);\n\n            if(ax.constrain === 'domain') hasAnyDomainConstraint = true;\n        }\n\n        // Do we have a constraint mismatch? Give a small buffer for rounding errors\n        if(minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;\n\n        // now increase any ranges we need to until all normalized scales are equal\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            normScale = normScales[axisID];\n            ax = axes[axisID];\n            mode = ax.constrain;\n\n            // even if the scale didn't change, if we're shrinking domain\n            // we need to recalculate in case `constraintoward` changed\n            if(normScale !== matchScale || mode === 'domain') {\n                factor = normScale / matchScale;\n\n                if(mode === 'range') {\n                    scaleZoom(ax, factor);\n                } else {\n                    // mode === 'domain'\n\n                    var inputDomain = ax._inputDomain;\n                    var domainShrunk = (ax.domain[1] - ax.domain[0]) /\n                        (inputDomain[1] - inputDomain[0]);\n                    var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) /\n                        (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n\n                    factor /= domainShrunk;\n\n                    if(factor * rangeShrunk < 1) {\n                        // we've asked to magnify the axis more than we can just by\n                        // enlarging the domain - so we need to constrict range\n                        ax.domain = ax._input.domain = inputDomain.slice();\n                        scaleZoom(ax, factor);\n                        continue;\n                    }\n\n                    if(rangeShrunk < 1) {\n                        // the range has previously been constricted by ^^, but we've\n                        // switched to the domain-constricted regime, so reset range\n                        ax.range = ax._input.range = ax._inputRange.slice();\n                        factor *= rangeShrunk;\n                    }\n\n                    if(ax.autorange) {\n                        /*\n                         * range & factor may need to change because range was\n                         * calculated for the larger scaling, so some pixel\n                         * paddings may get cut off when we reduce the domain.\n                         *\n                         * This is easier than the regular autorange calculation\n                         * because we already know the scaling `m`, but we still\n                         * need to cut out impossible constraints (like\n                         * annotations with super-long arrows). That's what\n                         * outerMin/Max are for - if the expansion was going to\n                         * go beyond the original domain, it must be impossible\n                         */\n                        var rl0 = ax.r2l(ax.range[0]);\n                        var rl1 = ax.r2l(ax.range[1]);\n                        var rangeCenter = (rl0 + rl1) / 2;\n                        var rangeMin = rangeCenter;\n                        var rangeMax = rangeCenter;\n                        var halfRange = Math.abs(rl1 - rangeCenter);\n                        // extra tiny bit for rounding errors, in case we actually\n                        // *are* expanding to the full domain\n                        var outerMin = rangeCenter - halfRange * factor * 1.0001;\n                        var outerMax = rangeCenter + halfRange * factor * 1.0001;\n                        var getPadMin = autorange.makePadFn(fullLayout, ax, 0);\n                        var getPadMax = autorange.makePadFn(fullLayout, ax, 1);\n\n                        updateDomain(ax, factor);\n                        var m = Math.abs(ax._m);\n                        var extremes = autorange.concatExtremes(gd, ax);\n                        var minArray = extremes.min;\n                        var maxArray = extremes.max;\n                        var newVal;\n                        var k;\n\n                        for(k = 0; k < minArray.length; k++) {\n                            newVal = minArray[k].val - getPadMin(minArray[k]) / m;\n                            if(newVal > outerMin && newVal < rangeMin) {\n                                rangeMin = newVal;\n                            }\n                        }\n\n                        for(k = 0; k < maxArray.length; k++) {\n                            newVal = maxArray[k].val + getPadMax(maxArray[k]) / m;\n                            if(newVal < outerMax && newVal > rangeMax) {\n                                rangeMax = newVal;\n                            }\n                        }\n\n                        var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n                        factor /= domainExpand;\n\n                        rangeMin = ax.l2r(rangeMin);\n                        rangeMax = ax.l2r(rangeMax);\n                        ax.range = ax._input.range = (rl0 < rl1) ?\n                            [rangeMin, rangeMax] : [rangeMax, rangeMin];\n                    }\n\n                    updateDomain(ax, factor);\n                }\n            }\n        }\n    }\n};\n\nexports.getAxisGroup = function getAxisGroup(fullLayout, axId) {\n    var matchGroups = fullLayout._axisMatchGroups;\n\n    for(var i = 0; i < matchGroups.length; i++) {\n        var group = matchGroups[i];\n        if(group[axId]) return 'g' + i;\n    }\n    return axId;\n};\n\n// For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\nexports.clean = function clean(gd, ax) {\n    if(ax._inputDomain) {\n        var isConstrained = false;\n        var axId = ax._id;\n        var constraintGroups = gd._fullLayout._axisConstraintGroups;\n        for(var j = 0; j < constraintGroups.length; j++) {\n            if(constraintGroups[j][axId]) {\n                isConstrained = true;\n                break;\n            }\n        }\n        if(!isConstrained || ax.constrain !== 'domain') {\n            ax._input.domain = ax.domain = ax._inputDomain;\n            delete ax._inputDomain;\n        }\n    }\n};\n\nfunction updateDomain(ax, factor) {\n    var inputDomain = ax._inputDomain;\n    var centerFraction = FROM_BL[ax.constraintoward];\n    var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n\n    ax.domain = ax._input.domain = [\n        center + (inputDomain[0] - center) / factor,\n        center + (inputDomain[1] - center) / factor\n    ];\n    ax.setScale();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}