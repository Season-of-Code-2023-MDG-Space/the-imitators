{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\n\n// constants for dynamic jitter (ie less jitter for sparser points)\nvar JITTERCOUNT = 5; // points either side of this to include\nvar JITTERSPREAD = 0.01; // fraction of IQR to count as \"dense\"\n\nfunction plot(gd, plotinfo, cdbox, boxLayer) {\n  var isStatic = gd._context.staticPlot;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(boxLayer, cdbox, 'trace boxes').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var t = cd0.t;\n    var trace = cd0.trace;\n\n    // whisker width\n    t.wdPos = t.bdPos * trace.whiskerwidth;\n    if (trace.visible !== true || t.empty) {\n      plotGroup.remove();\n      return;\n    }\n    var posAxis, valAxis;\n    if (trace.orientation === 'h') {\n      posAxis = ya;\n      valAxis = xa;\n    } else {\n      posAxis = xa;\n      valAxis = ya;\n    }\n    plotBoxAndWhiskers(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, t, isStatic);\n    plotPoints(plotGroup, {\n      x: xa,\n      y: ya\n    }, trace, t);\n    plotBoxMean(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, t);\n  });\n}\nfunction plotBoxAndWhiskers(sel, axes, trace, t, isStatic) {\n  var isHorizontal = trace.orientation === 'h';\n  var valAxis = axes.val;\n  var posAxis = axes.pos;\n  var posHasRangeBreaks = !!posAxis.rangebreaks;\n  var bPos = t.bPos;\n  var wdPos = t.wdPos || 0;\n  var bPosPxOffset = t.bPosPxOffset || 0;\n  var whiskerWidth = trace.whiskerwidth || 0;\n  var notched = trace.notched || false;\n  var nw = notched ? 1 - 2 * trace.notchwidth : 1;\n\n  // to support for one-sided box\n  var bdPos0;\n  var bdPos1;\n  if (Array.isArray(t.bdPos)) {\n    bdPos0 = t.bdPos[0];\n    bdPos1 = t.bdPos[1];\n  } else {\n    bdPos0 = t.bdPos;\n    bdPos1 = t.bdPos;\n  }\n  var paths = sel.selectAll('path.box').data(trace.type !== 'violin' || trace.box.visible ? Lib.identity : []);\n  paths.enter().append('path').style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke').attr('class', 'box');\n  paths.exit().remove();\n  paths.each(function (d) {\n    if (d.empty) return 'M0,0Z';\n    var lcenter = posAxis.c2l(d.pos + bPos, true);\n    var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n    var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n    var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;\n    var r = trace.whiskerwidth;\n    var posw0 = posHasRangeBreaks ? pos0 * r + (1 - r) * posc : posAxis.l2p(lcenter - wdPos) + bPosPxOffset;\n    var posw1 = posHasRangeBreaks ? pos1 * r + (1 - r) * posc : posAxis.l2p(lcenter + wdPos) + bPosPxOffset;\n    var posm0 = posAxis.l2p(lcenter - bdPos0 * nw) + bPosPxOffset;\n    var posm1 = posAxis.l2p(lcenter + bdPos1 * nw) + bPosPxOffset;\n    var q1 = valAxis.c2p(d.q1, true);\n    var q3 = valAxis.c2p(d.q3, true);\n    // make sure median isn't identical to either of the\n    // quartiles, so we can see it\n    var m = Lib.constrain(valAxis.c2p(d.med, true), Math.min(q1, q3) + 1, Math.max(q1, q3) - 1);\n\n    // for compatibility with box, violin, and candlestick\n    // perhaps we should put this into cd0.t instead so it's more explicit,\n    // but what we have now is:\n    // - box always has d.lf, but boxpoints can be anything\n    // - violin has d.lf and should always use it (boxpoints is undefined)\n    // - candlestick has only min/max\n    var useExtremes = d.lf === undefined || trace.boxpoints === false;\n    var lf = valAxis.c2p(useExtremes ? d.min : d.lf, true);\n    var uf = valAxis.c2p(useExtremes ? d.max : d.uf, true);\n    var ln = valAxis.c2p(d.ln, true);\n    var un = valAxis.c2p(d.un, true);\n    if (isHorizontal) {\n      d3.select(this).attr('d', 'M' + m + ',' + posm0 + 'V' + posm1 +\n      // median line\n      'M' + q1 + ',' + pos0 + 'V' + pos1 + (\n      // left edge\n      notched ? 'H' + ln + 'L' + m + ',' + posm1 + 'L' + un + ',' + pos1 : '') +\n      // top notched edge\n      'H' + q3 +\n      // end of the top edge\n      'V' + pos0 + (\n      // right edge\n      notched ? 'H' + un + 'L' + m + ',' + posm0 + 'L' + ln + ',' + pos0 : '') +\n      // bottom notched edge\n      'Z' +\n      // end of the box\n      'M' + q1 + ',' + posc + 'H' + lf + 'M' + q3 + ',' + posc + 'H' + uf + (\n      // whiskers\n      whiskerWidth === 0 ? '' :\n      // whisker caps\n      'M' + lf + ',' + posw0 + 'V' + posw1 + 'M' + uf + ',' + posw0 + 'V' + posw1));\n    } else {\n      d3.select(this).attr('d', 'M' + posm0 + ',' + m + 'H' + posm1 +\n      // median line\n      'M' + pos0 + ',' + q1 + 'H' + pos1 + (\n      // top of the box\n      notched ? 'V' + ln + 'L' + posm1 + ',' + m + 'L' + pos1 + ',' + un : '') +\n      // notched right edge\n      'V' + q3 +\n      // end of the right edge\n      'H' + pos0 + (\n      // bottom of the box\n      notched ? 'V' + un + 'L' + posm0 + ',' + m + 'L' + pos0 + ',' + ln : '') +\n      // notched left edge\n      'Z' +\n      // end of the box\n      'M' + posc + ',' + q1 + 'V' + lf + 'M' + posc + ',' + q3 + 'V' + uf + (\n      // whiskers\n      whiskerWidth === 0 ? '' :\n      // whisker caps\n      'M' + posw0 + ',' + lf + 'H' + posw1 + 'M' + posw0 + ',' + uf + 'H' + posw1));\n    }\n  });\n}\nfunction plotPoints(sel, axes, trace, t) {\n  var xa = axes.x;\n  var ya = axes.y;\n  var bdPos = t.bdPos;\n  var bPos = t.bPos;\n\n  // to support violin points\n  var mode = trace.boxpoints || trace.points;\n\n  // repeatable pseudo-random number generator\n  Lib.seedPseudoRandom();\n\n  // since box plot points get an extra level of nesting, each\n  // box needs the trace styling info\n  var fn = function (d) {\n    d.forEach(function (v) {\n      v.t = t;\n      v.trace = trace;\n    });\n    return d;\n  };\n  var gPoints = sel.selectAll('g.points').data(mode ? fn : []);\n  gPoints.enter().append('g').attr('class', 'points');\n  gPoints.exit().remove();\n  var paths = gPoints.selectAll('path').data(function (d) {\n    var i;\n    var pts = d.pts2;\n\n    // normally use IQR, but if this is 0 or too small, use max-min\n    var typicalSpread = Math.max((d.max - d.min) / 10, d.q3 - d.q1);\n    var minSpread = typicalSpread * 1e-9;\n    var spreadLimit = typicalSpread * JITTERSPREAD;\n    var jitterFactors = [];\n    var maxJitterFactor = 0;\n    var newJitter;\n\n    // dynamic jitter\n    if (trace.jitter) {\n      if (typicalSpread === 0) {\n        // edge case of no spread at all: fall back to max jitter\n        maxJitterFactor = 1;\n        jitterFactors = new Array(pts.length);\n        for (i = 0; i < pts.length; i++) {\n          jitterFactors[i] = 1;\n        }\n      } else {\n        for (i = 0; i < pts.length; i++) {\n          var i0 = Math.max(0, i - JITTERCOUNT);\n          var pmin = pts[i0].v;\n          var i1 = Math.min(pts.length - 1, i + JITTERCOUNT);\n          var pmax = pts[i1].v;\n          if (mode !== 'all') {\n            if (pts[i].v < d.lf) pmax = Math.min(pmax, d.lf);else pmin = Math.max(pmin, d.uf);\n          }\n          var jitterFactor = Math.sqrt(spreadLimit * (i1 - i0) / (pmax - pmin + minSpread)) || 0;\n          jitterFactor = Lib.constrain(Math.abs(jitterFactor), 0, 1);\n          jitterFactors.push(jitterFactor);\n          maxJitterFactor = Math.max(jitterFactor, maxJitterFactor);\n        }\n      }\n      newJitter = trace.jitter * 2 / (maxJitterFactor || 1);\n    }\n\n    // fills in 'x' and 'y' in calcdata 'pts' item\n    for (i = 0; i < pts.length; i++) {\n      var pt = pts[i];\n      var v = pt.v;\n      var jitterOffset = trace.jitter ? newJitter * jitterFactors[i] * (Lib.pseudoRandom() - 0.5) : 0;\n      var posPx = d.pos + bPos + bdPos * (trace.pointpos + jitterOffset);\n      if (trace.orientation === 'h') {\n        pt.y = posPx;\n        pt.x = v;\n      } else {\n        pt.x = posPx;\n        pt.y = v;\n      }\n\n      // tag suspected outliers\n      if (mode === 'suspectedoutliers' && v < d.uo && v > d.lo) {\n        pt.so = true;\n      }\n    }\n    return pts;\n  });\n  paths.enter().append('path').classed('point', true);\n  paths.exit().remove();\n  paths.call(Drawing.translatePoints, xa, ya);\n}\nfunction plotBoxMean(sel, axes, trace, t) {\n  var valAxis = axes.val;\n  var posAxis = axes.pos;\n  var posHasRangeBreaks = !!posAxis.rangebreaks;\n  var bPos = t.bPos;\n  var bPosPxOffset = t.bPosPxOffset || 0;\n\n  // to support violin mean lines\n  var mode = trace.boxmean || (trace.meanline || {}).visible;\n\n  // to support for one-sided box\n  var bdPos0;\n  var bdPos1;\n  if (Array.isArray(t.bdPos)) {\n    bdPos0 = t.bdPos[0];\n    bdPos1 = t.bdPos[1];\n  } else {\n    bdPos0 = t.bdPos;\n    bdPos1 = t.bdPos;\n  }\n  var paths = sel.selectAll('path.mean').data(trace.type === 'box' && trace.boxmean || trace.type === 'violin' && trace.box.visible && trace.meanline.visible ? Lib.identity : []);\n  paths.enter().append('path').attr('class', 'mean').style({\n    fill: 'none',\n    'vector-effect': 'non-scaling-stroke'\n  });\n  paths.exit().remove();\n  paths.each(function (d) {\n    var lcenter = posAxis.c2l(d.pos + bPos, true);\n    var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n    var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n    var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;\n    var m = valAxis.c2p(d.mean, true);\n    var sl = valAxis.c2p(d.mean - d.sd, true);\n    var sh = valAxis.c2p(d.mean + d.sd, true);\n    if (trace.orientation === 'h') {\n      d3.select(this).attr('d', 'M' + m + ',' + pos0 + 'V' + pos1 + (mode === 'sd' ? 'm0,0L' + sl + ',' + posc + 'L' + m + ',' + pos0 + 'L' + sh + ',' + posc + 'Z' : ''));\n    } else {\n      d3.select(this).attr('d', 'M' + pos0 + ',' + m + 'H' + pos1 + (mode === 'sd' ? 'm0,0L' + posc + ',' + sl + 'L' + pos0 + ',' + m + 'L' + posc + ',' + sh + 'Z' : ''));\n    }\n  });\n}\nmodule.exports = {\n  plot: plot,\n  plotBoxAndWhiskers: plotBoxAndWhiskers,\n  plotPoints: plotPoints,\n  plotBoxMean: plotBoxMean\n};","map":{"version":3,"names":["d3","require","Lib","Drawing","JITTERCOUNT","JITTERSPREAD","plot","gd","plotinfo","cdbox","boxLayer","isStatic","_context","staticPlot","xa","xaxis","ya","yaxis","makeTraceGroups","each","cd","plotGroup","select","cd0","t","trace","wdPos","bdPos","whiskerwidth","visible","empty","remove","posAxis","valAxis","orientation","plotBoxAndWhiskers","pos","val","plotPoints","x","y","plotBoxMean","sel","axes","isHorizontal","posHasRangeBreaks","rangebreaks","bPos","bPosPxOffset","whiskerWidth","notched","nw","notchwidth","bdPos0","bdPos1","Array","isArray","paths","selectAll","data","type","box","identity","enter","append","style","attr","exit","d","lcenter","c2l","pos0","l2p","pos1","posc","r","posw0","posw1","posm0","posm1","q1","c2p","q3","m","constrain","med","Math","min","max","useExtremes","lf","undefined","boxpoints","uf","ln","un","mode","points","seedPseudoRandom","fn","forEach","v","gPoints","i","pts","pts2","typicalSpread","minSpread","spreadLimit","jitterFactors","maxJitterFactor","newJitter","jitter","length","i0","pmin","i1","pmax","jitterFactor","sqrt","abs","push","pt","jitterOffset","pseudoRandom","posPx","pointpos","uo","lo","so","classed","call","translatePoints","boxmean","meanline","fill","mean","sl","sd","sh","module","exports"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/traces/box/plot.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\n\n// constants for dynamic jitter (ie less jitter for sparser points)\nvar JITTERCOUNT = 5; // points either side of this to include\nvar JITTERSPREAD = 0.01; // fraction of IQR to count as \"dense\"\n\nfunction plot(gd, plotinfo, cdbox, boxLayer) {\n    var isStatic = gd._context.staticPlot;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    Lib.makeTraceGroups(boxLayer, cdbox, 'trace boxes').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var t = cd0.t;\n        var trace = cd0.trace;\n\n        // whisker width\n        t.wdPos = t.bdPos * trace.whiskerwidth;\n\n        if(trace.visible !== true || t.empty) {\n            plotGroup.remove();\n            return;\n        }\n\n        var posAxis, valAxis;\n\n        if(trace.orientation === 'h') {\n            posAxis = ya;\n            valAxis = xa;\n        } else {\n            posAxis = xa;\n            valAxis = ya;\n        }\n\n        plotBoxAndWhiskers(plotGroup, {pos: posAxis, val: valAxis}, trace, t, isStatic);\n        plotPoints(plotGroup, {x: xa, y: ya}, trace, t);\n        plotBoxMean(plotGroup, {pos: posAxis, val: valAxis}, trace, t);\n    });\n}\n\nfunction plotBoxAndWhiskers(sel, axes, trace, t, isStatic) {\n    var isHorizontal = trace.orientation === 'h';\n    var valAxis = axes.val;\n    var posAxis = axes.pos;\n    var posHasRangeBreaks = !!posAxis.rangebreaks;\n\n    var bPos = t.bPos;\n    var wdPos = t.wdPos || 0;\n    var bPosPxOffset = t.bPosPxOffset || 0;\n    var whiskerWidth = trace.whiskerwidth || 0;\n    var notched = trace.notched || false;\n    var nw = notched ? 1 - 2 * trace.notchwidth : 1;\n\n    // to support for one-sided box\n    var bdPos0;\n    var bdPos1;\n    if(Array.isArray(t.bdPos)) {\n        bdPos0 = t.bdPos[0];\n        bdPos1 = t.bdPos[1];\n    } else {\n        bdPos0 = t.bdPos;\n        bdPos1 = t.bdPos;\n    }\n\n    var paths = sel.selectAll('path.box').data((\n        trace.type !== 'violin' ||\n        trace.box.visible\n    ) ? Lib.identity : []);\n\n    paths.enter().append('path')\n        .style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke')\n        .attr('class', 'box');\n\n    paths.exit().remove();\n\n    paths.each(function(d) {\n        if(d.empty) return 'M0,0Z';\n\n        var lcenter = posAxis.c2l(d.pos + bPos, true);\n\n        var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n        var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n        var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;\n\n        var r = trace.whiskerwidth;\n        var posw0 = posHasRangeBreaks ? pos0 * r + (1 - r) * posc : posAxis.l2p(lcenter - wdPos) + bPosPxOffset;\n        var posw1 = posHasRangeBreaks ? pos1 * r + (1 - r) * posc : posAxis.l2p(lcenter + wdPos) + bPosPxOffset;\n\n        var posm0 = posAxis.l2p(lcenter - bdPos0 * nw) + bPosPxOffset;\n        var posm1 = posAxis.l2p(lcenter + bdPos1 * nw) + bPosPxOffset;\n        var q1 = valAxis.c2p(d.q1, true);\n        var q3 = valAxis.c2p(d.q3, true);\n        // make sure median isn't identical to either of the\n        // quartiles, so we can see it\n        var m = Lib.constrain(\n            valAxis.c2p(d.med, true),\n            Math.min(q1, q3) + 1, Math.max(q1, q3) - 1\n        );\n\n        // for compatibility with box, violin, and candlestick\n        // perhaps we should put this into cd0.t instead so it's more explicit,\n        // but what we have now is:\n        // - box always has d.lf, but boxpoints can be anything\n        // - violin has d.lf and should always use it (boxpoints is undefined)\n        // - candlestick has only min/max\n        var useExtremes = (d.lf === undefined) || (trace.boxpoints === false);\n        var lf = valAxis.c2p(useExtremes ? d.min : d.lf, true);\n        var uf = valAxis.c2p(useExtremes ? d.max : d.uf, true);\n        var ln = valAxis.c2p(d.ln, true);\n        var un = valAxis.c2p(d.un, true);\n\n        if(isHorizontal) {\n            d3.select(this).attr('d',\n                'M' + m + ',' + posm0 + 'V' + posm1 + // median line\n                'M' + q1 + ',' + pos0 + 'V' + pos1 + // left edge\n                (notched ?\n                    'H' + ln + 'L' + m + ',' + posm1 + 'L' + un + ',' + pos1 :\n                    ''\n                ) + // top notched edge\n                'H' + q3 + // end of the top edge\n                'V' + pos0 + // right edge\n                (notched ? 'H' + un + 'L' + m + ',' + posm0 + 'L' + ln + ',' + pos0 : '') + // bottom notched edge\n                'Z' + // end of the box\n                'M' + q1 + ',' + posc + 'H' + lf + 'M' + q3 + ',' + posc + 'H' + uf + // whiskers\n                (whiskerWidth === 0 ?\n                    '' : // whisker caps\n                    'M' + lf + ',' + posw0 + 'V' + posw1 + 'M' + uf + ',' + posw0 + 'V' + posw1\n                )\n            );\n        } else {\n            d3.select(this).attr('d',\n                'M' + posm0 + ',' + m + 'H' + posm1 + // median line\n                'M' + pos0 + ',' + q1 + 'H' + pos1 + // top of the box\n                (notched ?\n                    'V' + ln + 'L' + posm1 + ',' + m + 'L' + pos1 + ',' + un :\n                    ''\n                ) + // notched right edge\n                'V' + q3 + // end of the right edge\n                'H' + pos0 + // bottom of the box\n                (notched ?\n                    'V' + un + 'L' + posm0 + ',' + m + 'L' + pos0 + ',' + ln :\n                    ''\n                ) + // notched left edge\n                'Z' + // end of the box\n                'M' + posc + ',' + q1 + 'V' + lf + 'M' + posc + ',' + q3 + 'V' + uf + // whiskers\n                (whiskerWidth === 0 ?\n                    '' : // whisker caps\n                    'M' + posw0 + ',' + lf + 'H' + posw1 + 'M' + posw0 + ',' + uf + 'H' + posw1\n                )\n            );\n        }\n    });\n}\n\nfunction plotPoints(sel, axes, trace, t) {\n    var xa = axes.x;\n    var ya = axes.y;\n    var bdPos = t.bdPos;\n    var bPos = t.bPos;\n\n    // to support violin points\n    var mode = trace.boxpoints || trace.points;\n\n    // repeatable pseudo-random number generator\n    Lib.seedPseudoRandom();\n\n    // since box plot points get an extra level of nesting, each\n    // box needs the trace styling info\n    var fn = function(d) {\n        d.forEach(function(v) {\n            v.t = t;\n            v.trace = trace;\n        });\n        return d;\n    };\n\n    var gPoints = sel.selectAll('g.points')\n        .data(mode ? fn : []);\n\n    gPoints.enter().append('g')\n        .attr('class', 'points');\n\n    gPoints.exit().remove();\n\n    var paths = gPoints.selectAll('path')\n        .data(function(d) {\n            var i;\n            var pts = d.pts2;\n\n            // normally use IQR, but if this is 0 or too small, use max-min\n            var typicalSpread = Math.max((d.max - d.min) / 10, d.q3 - d.q1);\n            var minSpread = typicalSpread * 1e-9;\n            var spreadLimit = typicalSpread * JITTERSPREAD;\n            var jitterFactors = [];\n            var maxJitterFactor = 0;\n            var newJitter;\n\n            // dynamic jitter\n            if(trace.jitter) {\n                if(typicalSpread === 0) {\n                    // edge case of no spread at all: fall back to max jitter\n                    maxJitterFactor = 1;\n                    jitterFactors = new Array(pts.length);\n                    for(i = 0; i < pts.length; i++) {\n                        jitterFactors[i] = 1;\n                    }\n                } else {\n                    for(i = 0; i < pts.length; i++) {\n                        var i0 = Math.max(0, i - JITTERCOUNT);\n                        var pmin = pts[i0].v;\n                        var i1 = Math.min(pts.length - 1, i + JITTERCOUNT);\n                        var pmax = pts[i1].v;\n\n                        if(mode !== 'all') {\n                            if(pts[i].v < d.lf) pmax = Math.min(pmax, d.lf);\n                            else pmin = Math.max(pmin, d.uf);\n                        }\n\n                        var jitterFactor = Math.sqrt(spreadLimit * (i1 - i0) / (pmax - pmin + minSpread)) || 0;\n                        jitterFactor = Lib.constrain(Math.abs(jitterFactor), 0, 1);\n\n                        jitterFactors.push(jitterFactor);\n                        maxJitterFactor = Math.max(jitterFactor, maxJitterFactor);\n                    }\n                }\n                newJitter = trace.jitter * 2 / (maxJitterFactor || 1);\n            }\n\n            // fills in 'x' and 'y' in calcdata 'pts' item\n            for(i = 0; i < pts.length; i++) {\n                var pt = pts[i];\n                var v = pt.v;\n\n                var jitterOffset = trace.jitter ?\n                    (newJitter * jitterFactors[i] * (Lib.pseudoRandom() - 0.5)) :\n                    0;\n\n                var posPx = d.pos + bPos + bdPos * (trace.pointpos + jitterOffset);\n\n                if(trace.orientation === 'h') {\n                    pt.y = posPx;\n                    pt.x = v;\n                } else {\n                    pt.x = posPx;\n                    pt.y = v;\n                }\n\n                // tag suspected outliers\n                if(mode === 'suspectedoutliers' && v < d.uo && v > d.lo) {\n                    pt.so = true;\n                }\n            }\n\n            return pts;\n        });\n\n    paths.enter().append('path')\n        .classed('point', true);\n\n    paths.exit().remove();\n\n    paths.call(Drawing.translatePoints, xa, ya);\n}\n\nfunction plotBoxMean(sel, axes, trace, t) {\n    var valAxis = axes.val;\n    var posAxis = axes.pos;\n    var posHasRangeBreaks = !!posAxis.rangebreaks;\n\n    var bPos = t.bPos;\n    var bPosPxOffset = t.bPosPxOffset || 0;\n\n    // to support violin mean lines\n    var mode = trace.boxmean || (trace.meanline || {}).visible;\n\n    // to support for one-sided box\n    var bdPos0;\n    var bdPos1;\n    if(Array.isArray(t.bdPos)) {\n        bdPos0 = t.bdPos[0];\n        bdPos1 = t.bdPos[1];\n    } else {\n        bdPos0 = t.bdPos;\n        bdPos1 = t.bdPos;\n    }\n\n    var paths = sel.selectAll('path.mean').data((\n        (trace.type === 'box' && trace.boxmean) ||\n        (trace.type === 'violin' && trace.box.visible && trace.meanline.visible)\n    ) ? Lib.identity : []);\n\n    paths.enter().append('path')\n        .attr('class', 'mean')\n        .style({\n            fill: 'none',\n            'vector-effect': 'non-scaling-stroke'\n        });\n\n    paths.exit().remove();\n\n    paths.each(function(d) {\n        var lcenter = posAxis.c2l(d.pos + bPos, true);\n\n        var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n        var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n        var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;\n\n        var m = valAxis.c2p(d.mean, true);\n        var sl = valAxis.c2p(d.mean - d.sd, true);\n        var sh = valAxis.c2p(d.mean + d.sd, true);\n\n        if(trace.orientation === 'h') {\n            d3.select(this).attr('d',\n                'M' + m + ',' + pos0 + 'V' + pos1 +\n                (mode === 'sd' ?\n                    'm0,0L' + sl + ',' + posc + 'L' + m + ',' + pos0 + 'L' + sh + ',' + posc + 'Z' :\n                    '')\n            );\n        } else {\n            d3.select(this).attr('d',\n                'M' + pos0 + ',' + m + 'H' + pos1 +\n                (mode === 'sd' ?\n                    'm0,0L' + posc + ',' + sl + 'L' + pos0 + ',' + m + 'L' + posc + ',' + sh + 'Z' :\n                    '')\n            );\n        }\n    });\n}\n\nmodule.exports = {\n    plot: plot,\n    plotBoxAndWhiskers: plotBoxAndWhiskers,\n    plotPoints: plotPoints,\n    plotBoxMean: plotBoxMean\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,EAAE,GAAGC,OAAO,CAAC,YAAY,CAAC;AAE9B,IAAIC,GAAG,GAAGD,OAAO,CAAC,WAAW,CAAC;AAC9B,IAAIE,OAAO,GAAGF,OAAO,CAAC,0BAA0B,CAAC;;AAEjD;AACA,IAAIG,WAAW,GAAG,CAAC,CAAC,CAAC;AACrB,IAAIC,YAAY,GAAG,IAAI,CAAC,CAAC;;AAEzB,SAASC,IAAIA,CAACC,EAAE,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EACzC,IAAIC,QAAQ,GAAGJ,EAAE,CAACK,QAAQ,CAACC,UAAU;EACrC,IAAIC,EAAE,GAAGN,QAAQ,CAACO,KAAK;EACvB,IAAIC,EAAE,GAAGR,QAAQ,CAACS,KAAK;EAEvBf,GAAG,CAACgB,eAAe,CAACR,QAAQ,EAAED,KAAK,EAAE,aAAa,CAAC,CAACU,IAAI,CAAC,UAASC,EAAE,EAAE;IAClE,IAAIC,SAAS,GAAGrB,EAAE,CAACsB,MAAM,CAAC,IAAI,CAAC;IAC/B,IAAIC,GAAG,GAAGH,EAAE,CAAC,CAAC,CAAC;IACf,IAAII,CAAC,GAAGD,GAAG,CAACC,CAAC;IACb,IAAIC,KAAK,GAAGF,GAAG,CAACE,KAAK;;IAErB;IACAD,CAAC,CAACE,KAAK,GAAGF,CAAC,CAACG,KAAK,GAAGF,KAAK,CAACG,YAAY;IAEtC,IAAGH,KAAK,CAACI,OAAO,KAAK,IAAI,IAAIL,CAAC,CAACM,KAAK,EAAE;MAClCT,SAAS,CAACU,MAAM,EAAE;MAClB;IACJ;IAEA,IAAIC,OAAO,EAAEC,OAAO;IAEpB,IAAGR,KAAK,CAACS,WAAW,KAAK,GAAG,EAAE;MAC1BF,OAAO,GAAGhB,EAAE;MACZiB,OAAO,GAAGnB,EAAE;IAChB,CAAC,MAAM;MACHkB,OAAO,GAAGlB,EAAE;MACZmB,OAAO,GAAGjB,EAAE;IAChB;IAEAmB,kBAAkB,CAACd,SAAS,EAAE;MAACe,GAAG,EAAEJ,OAAO;MAAEK,GAAG,EAAEJ;IAAO,CAAC,EAAER,KAAK,EAAED,CAAC,EAAEb,QAAQ,CAAC;IAC/E2B,UAAU,CAACjB,SAAS,EAAE;MAACkB,CAAC,EAAEzB,EAAE;MAAE0B,CAAC,EAAExB;IAAE,CAAC,EAAES,KAAK,EAAED,CAAC,CAAC;IAC/CiB,WAAW,CAACpB,SAAS,EAAE;MAACe,GAAG,EAAEJ,OAAO;MAAEK,GAAG,EAAEJ;IAAO,CAAC,EAAER,KAAK,EAAED,CAAC,CAAC;EAClE,CAAC,CAAC;AACN;AAEA,SAASW,kBAAkBA,CAACO,GAAG,EAAEC,IAAI,EAAElB,KAAK,EAAED,CAAC,EAAEb,QAAQ,EAAE;EACvD,IAAIiC,YAAY,GAAGnB,KAAK,CAACS,WAAW,KAAK,GAAG;EAC5C,IAAID,OAAO,GAAGU,IAAI,CAACN,GAAG;EACtB,IAAIL,OAAO,GAAGW,IAAI,CAACP,GAAG;EACtB,IAAIS,iBAAiB,GAAG,CAAC,CAACb,OAAO,CAACc,WAAW;EAE7C,IAAIC,IAAI,GAAGvB,CAAC,CAACuB,IAAI;EACjB,IAAIrB,KAAK,GAAGF,CAAC,CAACE,KAAK,IAAI,CAAC;EACxB,IAAIsB,YAAY,GAAGxB,CAAC,CAACwB,YAAY,IAAI,CAAC;EACtC,IAAIC,YAAY,GAAGxB,KAAK,CAACG,YAAY,IAAI,CAAC;EAC1C,IAAIsB,OAAO,GAAGzB,KAAK,CAACyB,OAAO,IAAI,KAAK;EACpC,IAAIC,EAAE,GAAGD,OAAO,GAAG,CAAC,GAAG,CAAC,GAAGzB,KAAK,CAAC2B,UAAU,GAAG,CAAC;;EAE/C;EACA,IAAIC,MAAM;EACV,IAAIC,MAAM;EACV,IAAGC,KAAK,CAACC,OAAO,CAAChC,CAAC,CAACG,KAAK,CAAC,EAAE;IACvB0B,MAAM,GAAG7B,CAAC,CAACG,KAAK,CAAC,CAAC,CAAC;IACnB2B,MAAM,GAAG9B,CAAC,CAACG,KAAK,CAAC,CAAC,CAAC;EACvB,CAAC,MAAM;IACH0B,MAAM,GAAG7B,CAAC,CAACG,KAAK;IAChB2B,MAAM,GAAG9B,CAAC,CAACG,KAAK;EACpB;EAEA,IAAI8B,KAAK,GAAGf,GAAG,CAACgB,SAAS,CAAC,UAAU,CAAC,CAACC,IAAI,CACtClC,KAAK,CAACmC,IAAI,KAAK,QAAQ,IACvBnC,KAAK,CAACoC,GAAG,CAAChC,OAAO,GACjB3B,GAAG,CAAC4D,QAAQ,GAAG,EAAE,CAAC;EAEtBL,KAAK,CAACM,KAAK,EAAE,CAACC,MAAM,CAAC,MAAM,CAAC,CACvBC,KAAK,CAAC,eAAe,EAAEtD,QAAQ,GAAG,MAAM,GAAG,oBAAoB,CAAC,CAChEuD,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC;EAEzBT,KAAK,CAACU,IAAI,EAAE,CAACpC,MAAM,EAAE;EAErB0B,KAAK,CAACtC,IAAI,CAAC,UAASiD,CAAC,EAAE;IACnB,IAAGA,CAAC,CAACtC,KAAK,EAAE,OAAO,OAAO;IAE1B,IAAIuC,OAAO,GAAGrC,OAAO,CAACsC,GAAG,CAACF,CAAC,CAAChC,GAAG,GAAGW,IAAI,EAAE,IAAI,CAAC;IAE7C,IAAIwB,IAAI,GAAGvC,OAAO,CAACwC,GAAG,CAACH,OAAO,GAAGhB,MAAM,CAAC,GAAGL,YAAY;IACvD,IAAIyB,IAAI,GAAGzC,OAAO,CAACwC,GAAG,CAACH,OAAO,GAAGf,MAAM,CAAC,GAAGN,YAAY;IACvD,IAAI0B,IAAI,GAAG7B,iBAAiB,GAAG,CAAC0B,IAAI,GAAGE,IAAI,IAAI,CAAC,GAAGzC,OAAO,CAACwC,GAAG,CAACH,OAAO,CAAC,GAAGrB,YAAY;IAEtF,IAAI2B,CAAC,GAAGlD,KAAK,CAACG,YAAY;IAC1B,IAAIgD,KAAK,GAAG/B,iBAAiB,GAAG0B,IAAI,GAAGI,CAAC,GAAG,CAAC,CAAC,GAAGA,CAAC,IAAID,IAAI,GAAG1C,OAAO,CAACwC,GAAG,CAACH,OAAO,GAAG3C,KAAK,CAAC,GAAGsB,YAAY;IACvG,IAAI6B,KAAK,GAAGhC,iBAAiB,GAAG4B,IAAI,GAAGE,CAAC,GAAG,CAAC,CAAC,GAAGA,CAAC,IAAID,IAAI,GAAG1C,OAAO,CAACwC,GAAG,CAACH,OAAO,GAAG3C,KAAK,CAAC,GAAGsB,YAAY;IAEvG,IAAI8B,KAAK,GAAG9C,OAAO,CAACwC,GAAG,CAACH,OAAO,GAAGhB,MAAM,GAAGF,EAAE,CAAC,GAAGH,YAAY;IAC7D,IAAI+B,KAAK,GAAG/C,OAAO,CAACwC,GAAG,CAACH,OAAO,GAAGf,MAAM,GAAGH,EAAE,CAAC,GAAGH,YAAY;IAC7D,IAAIgC,EAAE,GAAG/C,OAAO,CAACgD,GAAG,CAACb,CAAC,CAACY,EAAE,EAAE,IAAI,CAAC;IAChC,IAAIE,EAAE,GAAGjD,OAAO,CAACgD,GAAG,CAACb,CAAC,CAACc,EAAE,EAAE,IAAI,CAAC;IAChC;IACA;IACA,IAAIC,CAAC,GAAGjF,GAAG,CAACkF,SAAS,CACjBnD,OAAO,CAACgD,GAAG,CAACb,CAAC,CAACiB,GAAG,EAAE,IAAI,CAAC,EACxBC,IAAI,CAACC,GAAG,CAACP,EAAE,EAAEE,EAAE,CAAC,GAAG,CAAC,EAAEI,IAAI,CAACE,GAAG,CAACR,EAAE,EAAEE,EAAE,CAAC,GAAG,CAAC,CAC7C;;IAED;IACA;IACA;IACA;IACA;IACA;IACA,IAAIO,WAAW,GAAIrB,CAAC,CAACsB,EAAE,KAAKC,SAAS,IAAMlE,KAAK,CAACmE,SAAS,KAAK,KAAM;IACrE,IAAIF,EAAE,GAAGzD,OAAO,CAACgD,GAAG,CAACQ,WAAW,GAAGrB,CAAC,CAACmB,GAAG,GAAGnB,CAAC,CAACsB,EAAE,EAAE,IAAI,CAAC;IACtD,IAAIG,EAAE,GAAG5D,OAAO,CAACgD,GAAG,CAACQ,WAAW,GAAGrB,CAAC,CAACoB,GAAG,GAAGpB,CAAC,CAACyB,EAAE,EAAE,IAAI,CAAC;IACtD,IAAIC,EAAE,GAAG7D,OAAO,CAACgD,GAAG,CAACb,CAAC,CAAC0B,EAAE,EAAE,IAAI,CAAC;IAChC,IAAIC,EAAE,GAAG9D,OAAO,CAACgD,GAAG,CAACb,CAAC,CAAC2B,EAAE,EAAE,IAAI,CAAC;IAEhC,IAAGnD,YAAY,EAAE;MACb5C,EAAE,CAACsB,MAAM,CAAC,IAAI,CAAC,CAAC4C,IAAI,CAAC,GAAG,EACpB,GAAG,GAAGiB,CAAC,GAAG,GAAG,GAAGL,KAAK,GAAG,GAAG,GAAGC,KAAK;MAAG;MACtC,GAAG,GAAGC,EAAE,GAAG,GAAG,GAAGT,IAAI,GAAG,GAAG,GAAGE,IAAI;MAAG;MACpCvB,OAAO,GACJ,GAAG,GAAG4C,EAAE,GAAG,GAAG,GAAGX,CAAC,GAAG,GAAG,GAAGJ,KAAK,GAAG,GAAG,GAAGgB,EAAE,GAAG,GAAG,GAAGtB,IAAI,GACxD,EAAE,CACL;MAAG;MACJ,GAAG,GAAGS,EAAE;MAAG;MACX,GAAG,GAAGX,IAAI;MAAG;MACZrB,OAAO,GAAG,GAAG,GAAG6C,EAAE,GAAG,GAAG,GAAGZ,CAAC,GAAG,GAAG,GAAGL,KAAK,GAAG,GAAG,GAAGgB,EAAE,GAAG,GAAG,GAAGvB,IAAI,GAAG,EAAE,CAAC;MAAG;MAC5E,GAAG;MAAG;MACN,GAAG,GAAGS,EAAE,GAAG,GAAG,GAAGN,IAAI,GAAG,GAAG,GAAGgB,EAAE,GAAG,GAAG,GAAGR,EAAE,GAAG,GAAG,GAAGR,IAAI,GAAG,GAAG,GAAGmB,EAAE;MAAG;MACrE5C,YAAY,KAAK,CAAC,GACf,EAAE;MAAG;MACL,GAAG,GAAGyC,EAAE,GAAG,GAAG,GAAGd,KAAK,GAAG,GAAG,GAAGC,KAAK,GAAG,GAAG,GAAGgB,EAAE,GAAG,GAAG,GAAGjB,KAAK,GAAG,GAAG,GAAGC,KAAK,CAC9E,CACJ;IACL,CAAC,MAAM;MACH7E,EAAE,CAACsB,MAAM,CAAC,IAAI,CAAC,CAAC4C,IAAI,CAAC,GAAG,EACpB,GAAG,GAAGY,KAAK,GAAG,GAAG,GAAGK,CAAC,GAAG,GAAG,GAAGJ,KAAK;MAAG;MACtC,GAAG,GAAGR,IAAI,GAAG,GAAG,GAAGS,EAAE,GAAG,GAAG,GAAGP,IAAI;MAAG;MACpCvB,OAAO,GACJ,GAAG,GAAG4C,EAAE,GAAG,GAAG,GAAGf,KAAK,GAAG,GAAG,GAAGI,CAAC,GAAG,GAAG,GAAGV,IAAI,GAAG,GAAG,GAAGsB,EAAE,GACxD,EAAE,CACL;MAAG;MACJ,GAAG,GAAGb,EAAE;MAAG;MACX,GAAG,GAAGX,IAAI;MAAG;MACZrB,OAAO,GACJ,GAAG,GAAG6C,EAAE,GAAG,GAAG,GAAGjB,KAAK,GAAG,GAAG,GAAGK,CAAC,GAAG,GAAG,GAAGZ,IAAI,GAAG,GAAG,GAAGuB,EAAE,GACxD,EAAE,CACL;MAAG;MACJ,GAAG;MAAG;MACN,GAAG,GAAGpB,IAAI,GAAG,GAAG,GAAGM,EAAE,GAAG,GAAG,GAAGU,EAAE,GAAG,GAAG,GAAGhB,IAAI,GAAG,GAAG,GAAGQ,EAAE,GAAG,GAAG,GAAGW,EAAE;MAAG;MACrE5C,YAAY,KAAK,CAAC,GACf,EAAE;MAAG;MACL,GAAG,GAAG2B,KAAK,GAAG,GAAG,GAAGc,EAAE,GAAG,GAAG,GAAGb,KAAK,GAAG,GAAG,GAAGD,KAAK,GAAG,GAAG,GAAGiB,EAAE,GAAG,GAAG,GAAGhB,KAAK,CAC9E,CACJ;IACL;EACJ,CAAC,CAAC;AACN;AAEA,SAASvC,UAAUA,CAACI,GAAG,EAAEC,IAAI,EAAElB,KAAK,EAAED,CAAC,EAAE;EACrC,IAAIV,EAAE,GAAG6B,IAAI,CAACJ,CAAC;EACf,IAAIvB,EAAE,GAAG2B,IAAI,CAACH,CAAC;EACf,IAAIb,KAAK,GAAGH,CAAC,CAACG,KAAK;EACnB,IAAIoB,IAAI,GAAGvB,CAAC,CAACuB,IAAI;;EAEjB;EACA,IAAIiD,IAAI,GAAGvE,KAAK,CAACmE,SAAS,IAAInE,KAAK,CAACwE,MAAM;;EAE1C;EACA/F,GAAG,CAACgG,gBAAgB,EAAE;;EAEtB;EACA;EACA,IAAIC,EAAE,GAAG,SAAAA,CAAS/B,CAAC,EAAE;IACjBA,CAAC,CAACgC,OAAO,CAAC,UAASC,CAAC,EAAE;MAClBA,CAAC,CAAC7E,CAAC,GAAGA,CAAC;MACP6E,CAAC,CAAC5E,KAAK,GAAGA,KAAK;IACnB,CAAC,CAAC;IACF,OAAO2C,CAAC;EACZ,CAAC;EAED,IAAIkC,OAAO,GAAG5D,GAAG,CAACgB,SAAS,CAAC,UAAU,CAAC,CAClCC,IAAI,CAACqC,IAAI,GAAGG,EAAE,GAAG,EAAE,CAAC;EAEzBG,OAAO,CAACvC,KAAK,EAAE,CAACC,MAAM,CAAC,GAAG,CAAC,CACtBE,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC;EAE5BoC,OAAO,CAACnC,IAAI,EAAE,CAACpC,MAAM,EAAE;EAEvB,IAAI0B,KAAK,GAAG6C,OAAO,CAAC5C,SAAS,CAAC,MAAM,CAAC,CAChCC,IAAI,CAAC,UAASS,CAAC,EAAE;IACd,IAAImC,CAAC;IACL,IAAIC,GAAG,GAAGpC,CAAC,CAACqC,IAAI;;IAEhB;IACA,IAAIC,aAAa,GAAGpB,IAAI,CAACE,GAAG,CAAC,CAACpB,CAAC,CAACoB,GAAG,GAAGpB,CAAC,CAACmB,GAAG,IAAI,EAAE,EAAEnB,CAAC,CAACc,EAAE,GAAGd,CAAC,CAACY,EAAE,CAAC;IAC/D,IAAI2B,SAAS,GAAGD,aAAa,GAAG,IAAI;IACpC,IAAIE,WAAW,GAAGF,aAAa,GAAGrG,YAAY;IAC9C,IAAIwG,aAAa,GAAG,EAAE;IACtB,IAAIC,eAAe,GAAG,CAAC;IACvB,IAAIC,SAAS;;IAEb;IACA,IAAGtF,KAAK,CAACuF,MAAM,EAAE;MACb,IAAGN,aAAa,KAAK,CAAC,EAAE;QACpB;QACAI,eAAe,GAAG,CAAC;QACnBD,aAAa,GAAG,IAAItD,KAAK,CAACiD,GAAG,CAACS,MAAM,CAAC;QACrC,KAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,GAAG,CAACS,MAAM,EAAEV,CAAC,EAAE,EAAE;UAC5BM,aAAa,CAACN,CAAC,CAAC,GAAG,CAAC;QACxB;MACJ,CAAC,MAAM;QACH,KAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,GAAG,CAACS,MAAM,EAAEV,CAAC,EAAE,EAAE;UAC5B,IAAIW,EAAE,GAAG5B,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEe,CAAC,GAAGnG,WAAW,CAAC;UACrC,IAAI+G,IAAI,GAAGX,GAAG,CAACU,EAAE,CAAC,CAACb,CAAC;UACpB,IAAIe,EAAE,GAAG9B,IAAI,CAACC,GAAG,CAACiB,GAAG,CAACS,MAAM,GAAG,CAAC,EAAEV,CAAC,GAAGnG,WAAW,CAAC;UAClD,IAAIiH,IAAI,GAAGb,GAAG,CAACY,EAAE,CAAC,CAACf,CAAC;UAEpB,IAAGL,IAAI,KAAK,KAAK,EAAE;YACf,IAAGQ,GAAG,CAACD,CAAC,CAAC,CAACF,CAAC,GAAGjC,CAAC,CAACsB,EAAE,EAAE2B,IAAI,GAAG/B,IAAI,CAACC,GAAG,CAAC8B,IAAI,EAAEjD,CAAC,CAACsB,EAAE,CAAC,CAAC,KAC3CyB,IAAI,GAAG7B,IAAI,CAACE,GAAG,CAAC2B,IAAI,EAAE/C,CAAC,CAACyB,EAAE,CAAC;UACpC;UAEA,IAAIyB,YAAY,GAAGhC,IAAI,CAACiC,IAAI,CAACX,WAAW,IAAIQ,EAAE,GAAGF,EAAE,CAAC,IAAIG,IAAI,GAAGF,IAAI,GAAGR,SAAS,CAAC,CAAC,IAAI,CAAC;UACtFW,YAAY,GAAGpH,GAAG,CAACkF,SAAS,CAACE,IAAI,CAACkC,GAAG,CAACF,YAAY,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;UAE1DT,aAAa,CAACY,IAAI,CAACH,YAAY,CAAC;UAChCR,eAAe,GAAGxB,IAAI,CAACE,GAAG,CAAC8B,YAAY,EAAER,eAAe,CAAC;QAC7D;MACJ;MACAC,SAAS,GAAGtF,KAAK,CAACuF,MAAM,GAAG,CAAC,IAAIF,eAAe,IAAI,CAAC,CAAC;IACzD;;IAEA;IACA,KAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,GAAG,CAACS,MAAM,EAAEV,CAAC,EAAE,EAAE;MAC5B,IAAImB,EAAE,GAAGlB,GAAG,CAACD,CAAC,CAAC;MACf,IAAIF,CAAC,GAAGqB,EAAE,CAACrB,CAAC;MAEZ,IAAIsB,YAAY,GAAGlG,KAAK,CAACuF,MAAM,GAC1BD,SAAS,GAAGF,aAAa,CAACN,CAAC,CAAC,IAAIrG,GAAG,CAAC0H,YAAY,EAAE,GAAG,GAAG,CAAC,GAC1D,CAAC;MAEL,IAAIC,KAAK,GAAGzD,CAAC,CAAChC,GAAG,GAAGW,IAAI,GAAGpB,KAAK,IAAIF,KAAK,CAACqG,QAAQ,GAAGH,YAAY,CAAC;MAElE,IAAGlG,KAAK,CAACS,WAAW,KAAK,GAAG,EAAE;QAC1BwF,EAAE,CAAClF,CAAC,GAAGqF,KAAK;QACZH,EAAE,CAACnF,CAAC,GAAG8D,CAAC;MACZ,CAAC,MAAM;QACHqB,EAAE,CAACnF,CAAC,GAAGsF,KAAK;QACZH,EAAE,CAAClF,CAAC,GAAG6D,CAAC;MACZ;;MAEA;MACA,IAAGL,IAAI,KAAK,mBAAmB,IAAIK,CAAC,GAAGjC,CAAC,CAAC2D,EAAE,IAAI1B,CAAC,GAAGjC,CAAC,CAAC4D,EAAE,EAAE;QACrDN,EAAE,CAACO,EAAE,GAAG,IAAI;MAChB;IACJ;IAEA,OAAOzB,GAAG;EACd,CAAC,CAAC;EAEN/C,KAAK,CAACM,KAAK,EAAE,CAACC,MAAM,CAAC,MAAM,CAAC,CACvBkE,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC;EAE3BzE,KAAK,CAACU,IAAI,EAAE,CAACpC,MAAM,EAAE;EAErB0B,KAAK,CAAC0E,IAAI,CAAChI,OAAO,CAACiI,eAAe,EAAEtH,EAAE,EAAEE,EAAE,CAAC;AAC/C;AAEA,SAASyB,WAAWA,CAACC,GAAG,EAAEC,IAAI,EAAElB,KAAK,EAAED,CAAC,EAAE;EACtC,IAAIS,OAAO,GAAGU,IAAI,CAACN,GAAG;EACtB,IAAIL,OAAO,GAAGW,IAAI,CAACP,GAAG;EACtB,IAAIS,iBAAiB,GAAG,CAAC,CAACb,OAAO,CAACc,WAAW;EAE7C,IAAIC,IAAI,GAAGvB,CAAC,CAACuB,IAAI;EACjB,IAAIC,YAAY,GAAGxB,CAAC,CAACwB,YAAY,IAAI,CAAC;;EAEtC;EACA,IAAIgD,IAAI,GAAGvE,KAAK,CAAC4G,OAAO,IAAI,CAAC5G,KAAK,CAAC6G,QAAQ,IAAI,CAAC,CAAC,EAAEzG,OAAO;;EAE1D;EACA,IAAIwB,MAAM;EACV,IAAIC,MAAM;EACV,IAAGC,KAAK,CAACC,OAAO,CAAChC,CAAC,CAACG,KAAK,CAAC,EAAE;IACvB0B,MAAM,GAAG7B,CAAC,CAACG,KAAK,CAAC,CAAC,CAAC;IACnB2B,MAAM,GAAG9B,CAAC,CAACG,KAAK,CAAC,CAAC,CAAC;EACvB,CAAC,MAAM;IACH0B,MAAM,GAAG7B,CAAC,CAACG,KAAK;IAChB2B,MAAM,GAAG9B,CAAC,CAACG,KAAK;EACpB;EAEA,IAAI8B,KAAK,GAAGf,GAAG,CAACgB,SAAS,CAAC,WAAW,CAAC,CAACC,IAAI,CACtClC,KAAK,CAACmC,IAAI,KAAK,KAAK,IAAInC,KAAK,CAAC4G,OAAO,IACrC5G,KAAK,CAACmC,IAAI,KAAK,QAAQ,IAAInC,KAAK,CAACoC,GAAG,CAAChC,OAAO,IAAIJ,KAAK,CAAC6G,QAAQ,CAACzG,OAAQ,GACxE3B,GAAG,CAAC4D,QAAQ,GAAG,EAAE,CAAC;EAEtBL,KAAK,CAACM,KAAK,EAAE,CAACC,MAAM,CAAC,MAAM,CAAC,CACvBE,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CACrBD,KAAK,CAAC;IACHsE,IAAI,EAAE,MAAM;IACZ,eAAe,EAAE;EACrB,CAAC,CAAC;EAEN9E,KAAK,CAACU,IAAI,EAAE,CAACpC,MAAM,EAAE;EAErB0B,KAAK,CAACtC,IAAI,CAAC,UAASiD,CAAC,EAAE;IACnB,IAAIC,OAAO,GAAGrC,OAAO,CAACsC,GAAG,CAACF,CAAC,CAAChC,GAAG,GAAGW,IAAI,EAAE,IAAI,CAAC;IAE7C,IAAIwB,IAAI,GAAGvC,OAAO,CAACwC,GAAG,CAACH,OAAO,GAAGhB,MAAM,CAAC,GAAGL,YAAY;IACvD,IAAIyB,IAAI,GAAGzC,OAAO,CAACwC,GAAG,CAACH,OAAO,GAAGf,MAAM,CAAC,GAAGN,YAAY;IACvD,IAAI0B,IAAI,GAAG7B,iBAAiB,GAAG,CAAC0B,IAAI,GAAGE,IAAI,IAAI,CAAC,GAAGzC,OAAO,CAACwC,GAAG,CAACH,OAAO,CAAC,GAAGrB,YAAY;IAEtF,IAAImC,CAAC,GAAGlD,OAAO,CAACgD,GAAG,CAACb,CAAC,CAACoE,IAAI,EAAE,IAAI,CAAC;IACjC,IAAIC,EAAE,GAAGxG,OAAO,CAACgD,GAAG,CAACb,CAAC,CAACoE,IAAI,GAAGpE,CAAC,CAACsE,EAAE,EAAE,IAAI,CAAC;IACzC,IAAIC,EAAE,GAAG1G,OAAO,CAACgD,GAAG,CAACb,CAAC,CAACoE,IAAI,GAAGpE,CAAC,CAACsE,EAAE,EAAE,IAAI,CAAC;IAEzC,IAAGjH,KAAK,CAACS,WAAW,KAAK,GAAG,EAAE;MAC1BlC,EAAE,CAACsB,MAAM,CAAC,IAAI,CAAC,CAAC4C,IAAI,CAAC,GAAG,EACpB,GAAG,GAAGiB,CAAC,GAAG,GAAG,GAAGZ,IAAI,GAAG,GAAG,GAAGE,IAAI,IAChCuB,IAAI,KAAK,IAAI,GACV,OAAO,GAAGyC,EAAE,GAAG,GAAG,GAAG/D,IAAI,GAAG,GAAG,GAAGS,CAAC,GAAG,GAAG,GAAGZ,IAAI,GAAG,GAAG,GAAGoE,EAAE,GAAG,GAAG,GAAGjE,IAAI,GAAG,GAAG,GAC9E,EAAE,CAAC,CACV;IACL,CAAC,MAAM;MACH1E,EAAE,CAACsB,MAAM,CAAC,IAAI,CAAC,CAAC4C,IAAI,CAAC,GAAG,EACpB,GAAG,GAAGK,IAAI,GAAG,GAAG,GAAGY,CAAC,GAAG,GAAG,GAAGV,IAAI,IAChCuB,IAAI,KAAK,IAAI,GACV,OAAO,GAAGtB,IAAI,GAAG,GAAG,GAAG+D,EAAE,GAAG,GAAG,GAAGlE,IAAI,GAAG,GAAG,GAAGY,CAAC,GAAG,GAAG,GAAGT,IAAI,GAAG,GAAG,GAAGiE,EAAE,GAAG,GAAG,GAC9E,EAAE,CAAC,CACV;IACL;EACJ,CAAC,CAAC;AACN;AAEAC,MAAM,CAACC,OAAO,GAAG;EACbvI,IAAI,EAAEA,IAAI;EACV6B,kBAAkB,EAAEA,kBAAkB;EACtCG,UAAU,EAAEA,UAAU;EACtBG,WAAW,EAAEA;AACjB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}