{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar axisIds = require('../../plots/cartesian/axis_ids');\nvar traceIs = require('../../registry').traceIs;\nvar handleGroupingDefaults = require('../scatter/grouping_defaults');\nvar nestedProperty = Lib.nestedProperty;\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\nvar BINATTRS = [{\n  aStr: {\n    x: 'xbins.start',\n    y: 'ybins.start'\n  },\n  name: 'start'\n}, {\n  aStr: {\n    x: 'xbins.end',\n    y: 'ybins.end'\n  },\n  name: 'end'\n}, {\n  aStr: {\n    x: 'xbins.size',\n    y: 'ybins.size'\n  },\n  name: 'size'\n}, {\n  aStr: {\n    x: 'nbinsx',\n    y: 'nbinsy'\n  },\n  name: 'nbins'\n}];\nvar BINDIRECTIONS = ['x', 'y'];\n\n// handle bin attrs and relink auto-determined values so fullData is complete\nmodule.exports = function crossTraceDefaults(fullData, fullLayout) {\n  var allBinOpts = fullLayout._histogramBinOpts = {};\n  var histTraces = [];\n  var mustMatchTracesLookup = {};\n  var otherTracesList = [];\n  var traceOut, traces, groupName, binDir;\n  var i, j, k;\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceOut._input, traceOut, traceOut._module.attributes, attr, dflt);\n  }\n  function orientation2binDir(traceOut) {\n    return traceOut.orientation === 'v' ? 'x' : 'y';\n  }\n  function getAxisType(traceOut, binDir) {\n    var ax = axisIds.getFromTrace({\n      _fullLayout: fullLayout\n    }, traceOut, binDir);\n    return ax.type;\n  }\n  function fillBinOpts(traceOut, groupName, binDir) {\n    // N.B. group traces that don't have a bingroup with themselves\n    var fallbackGroupName = traceOut.uid + '__' + binDir;\n    if (!groupName) groupName = fallbackGroupName;\n    var axType = getAxisType(traceOut, binDir);\n    var calendar = traceOut[binDir + 'calendar'] || '';\n    var binOpts = allBinOpts[groupName];\n    var needsNewItem = true;\n    if (binOpts) {\n      if (axType === binOpts.axType && calendar === binOpts.calendar) {\n        needsNewItem = false;\n        binOpts.traces.push(traceOut);\n        binOpts.dirs.push(binDir);\n      } else {\n        groupName = fallbackGroupName;\n        if (axType !== binOpts.axType) {\n          Lib.warn(['Attempted to group the bins of trace', traceOut.index, 'set on a', 'type:' + axType, 'axis', 'with bins on', 'type:' + binOpts.axType, 'axis.'].join(' '));\n        }\n        if (calendar !== binOpts.calendar) {\n          // prohibit bingroup for traces using different calendar,\n          // there's probably a way to make this work, but skip for now\n          Lib.warn(['Attempted to group the bins of trace', traceOut.index, 'set with a', calendar, 'calendar', 'with bins', binOpts.calendar ? 'on a ' + binOpts.calendar + ' calendar' : 'w/o a set calendar'].join(' '));\n        }\n      }\n    }\n    if (needsNewItem) {\n      allBinOpts[groupName] = {\n        traces: [traceOut],\n        dirs: [binDir],\n        axType: axType,\n        calendar: traceOut[binDir + 'calendar'] || ''\n      };\n    }\n    traceOut['_' + binDir + 'bingroup'] = groupName;\n  }\n  for (i = 0; i < fullData.length; i++) {\n    traceOut = fullData[i];\n    if (traceIs(traceOut, 'histogram')) {\n      histTraces.push(traceOut);\n\n      // TODO: this shouldn't be relinked as it's only used within calc\n      // https://github.com/plotly/plotly.js/issues/749\n      delete traceOut._xautoBinFinished;\n      delete traceOut._yautoBinFinished;\n\n      // N.B. need to coerce *alignmentgroup* before *bingroup*, as traces\n      // in same alignmentgroup \"have to match\"\n      if (!traceIs(traceOut, '2dMap')) {\n        handleGroupingDefaults(traceOut._input, traceOut, fullLayout, coerce);\n      }\n    }\n  }\n  var alignmentOpts = fullLayout._alignmentOpts || {};\n\n  // Look for traces that \"have to match\", that is:\n  // - 1d histogram traces on the same subplot with same orientation under barmode:stack,\n  // - 1d histogram traces on the same subplot with same orientation under barmode:group\n  // - 1d histogram traces on the same position axis with the same orientation\n  //   and the same *alignmentgroup* (coerced under barmode:group)\n  // - Once `stackgroup` gets implemented (see https://github.com/plotly/plotly.js/issues/3614),\n  //   traces within the same stackgroup will also \"have to match\"\n  for (i = 0; i < histTraces.length; i++) {\n    traceOut = histTraces[i];\n    groupName = '';\n    if (!traceIs(traceOut, '2dMap')) {\n      binDir = orientation2binDir(traceOut);\n      if (fullLayout.barmode === 'group' && traceOut.alignmentgroup) {\n        var pa = traceOut[binDir + 'axis'];\n        var aGroupId = getAxisGroup(fullLayout, pa) + traceOut.orientation;\n        if ((alignmentOpts[aGroupId] || {})[traceOut.alignmentgroup]) {\n          groupName = aGroupId;\n        }\n      }\n      if (!groupName && fullLayout.barmode !== 'overlay') {\n        groupName = getAxisGroup(fullLayout, traceOut.xaxis) + getAxisGroup(fullLayout, traceOut.yaxis) + orientation2binDir(traceOut);\n      }\n    }\n    if (groupName) {\n      if (!mustMatchTracesLookup[groupName]) {\n        mustMatchTracesLookup[groupName] = [];\n      }\n      mustMatchTracesLookup[groupName].push(traceOut);\n    } else {\n      otherTracesList.push(traceOut);\n    }\n  }\n\n  // Setup binOpts for traces that have to match,\n  // if the traces have a valid bingroup, use that\n  // if not use axis+binDir groupName\n  for (groupName in mustMatchTracesLookup) {\n    traces = mustMatchTracesLookup[groupName];\n\n    // no need to 'force' anything when a single\n    // trace is detected as \"must match\"\n    if (traces.length === 1) {\n      otherTracesList.push(traces[0]);\n      continue;\n    }\n    var binGroupFound = false;\n    if (traces.length) {\n      traceOut = traces[0];\n      binGroupFound = coerce('bingroup');\n    }\n    groupName = binGroupFound || groupName;\n    for (i = 0; i < traces.length; i++) {\n      traceOut = traces[i];\n      var bingroupIn = traceOut._input.bingroup;\n      if (bingroupIn && bingroupIn !== groupName) {\n        Lib.warn(['Trace', traceOut.index, 'must match', 'within bingroup', groupName + '.', 'Ignoring its bingroup:', bingroupIn, 'setting.'].join(' '));\n      }\n      traceOut.bingroup = groupName;\n\n      // N.B. no need to worry about 2dMap case\n      // (where both bin direction are set in each trace)\n      // as 2dMap trace never \"have to match\"\n      fillBinOpts(traceOut, groupName, orientation2binDir(traceOut));\n    }\n  }\n\n  // setup binOpts for traces that can but don't have to match,\n  // notice that these traces can be matched with traces that have to match\n  for (i = 0; i < otherTracesList.length; i++) {\n    traceOut = otherTracesList[i];\n    var binGroup = coerce('bingroup');\n    if (traceIs(traceOut, '2dMap')) {\n      for (k = 0; k < 2; k++) {\n        binDir = BINDIRECTIONS[k];\n        var binGroupInDir = coerce(binDir + 'bingroup', binGroup ? binGroup + '__' + binDir : null);\n        fillBinOpts(traceOut, binGroupInDir, binDir);\n      }\n    } else {\n      fillBinOpts(traceOut, binGroup, orientation2binDir(traceOut));\n    }\n  }\n\n  // coerce bin attrs!\n  for (groupName in allBinOpts) {\n    var binOpts = allBinOpts[groupName];\n    traces = binOpts.traces;\n    for (j = 0; j < BINATTRS.length; j++) {\n      var attrSpec = BINATTRS[j];\n      var attr = attrSpec.name;\n      var aStr;\n      var autoVals;\n\n      // nbins(x|y) is moot if we have a size. This depends on\n      // nbins coming after size in binAttrs.\n      if (attr === 'nbins' && binOpts.sizeFound) continue;\n      for (i = 0; i < traces.length; i++) {\n        traceOut = traces[i];\n        binDir = binOpts.dirs[i];\n        aStr = attrSpec.aStr[binDir];\n        if (nestedProperty(traceOut._input, aStr).get() !== undefined) {\n          binOpts[attr] = coerce(aStr);\n          binOpts[attr + 'Found'] = true;\n          break;\n        }\n        autoVals = (traceOut._autoBin || {})[binDir] || {};\n        if (autoVals[attr]) {\n          // if this is the *first* autoval\n          nestedProperty(traceOut, aStr).set(autoVals[attr]);\n        }\n      }\n\n      // start and end we need to coerce anyway, after having collected the\n      // first of each into binOpts, in case a trace wants to restrict its\n      // data to a certain range\n      if (attr === 'start' || attr === 'end') {\n        for (; i < traces.length; i++) {\n          traceOut = traces[i];\n          if (traceOut['_' + binDir + 'bingroup']) {\n            autoVals = (traceOut._autoBin || {})[binDir] || {};\n            coerce(aStr, autoVals[attr]);\n          }\n        }\n      }\n      if (attr === 'nbins' && !binOpts.sizeFound && !binOpts.nbinsFound) {\n        traceOut = traces[0];\n        binOpts[attr] = coerce(aStr);\n      }\n    }\n  }\n};","map":{"version":3,"names":["Lib","require","axisIds","traceIs","handleGroupingDefaults","nestedProperty","getAxisGroup","BINATTRS","aStr","x","y","name","BINDIRECTIONS","module","exports","crossTraceDefaults","fullData","fullLayout","allBinOpts","_histogramBinOpts","histTraces","mustMatchTracesLookup","otherTracesList","traceOut","traces","groupName","binDir","i","j","k","coerce","attr","dflt","_input","_module","attributes","orientation2binDir","orientation","getAxisType","ax","getFromTrace","_fullLayout","type","fillBinOpts","fallbackGroupName","uid","axType","calendar","binOpts","needsNewItem","push","dirs","warn","index","join","length","_xautoBinFinished","_yautoBinFinished","alignmentOpts","_alignmentOpts","barmode","alignmentgroup","pa","aGroupId","xaxis","yaxis","binGroupFound","bingroupIn","bingroup","binGroup","binGroupInDir","attrSpec","autoVals","sizeFound","get","undefined","_autoBin","set","nbinsFound"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/traces/histogram/cross_trace_defaults.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar axisIds = require('../../plots/cartesian/axis_ids');\n\nvar traceIs = require('../../registry').traceIs;\nvar handleGroupingDefaults = require('../scatter/grouping_defaults');\n\nvar nestedProperty = Lib.nestedProperty;\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\n\nvar BINATTRS = [\n    {aStr: {x: 'xbins.start', y: 'ybins.start'}, name: 'start'},\n    {aStr: {x: 'xbins.end', y: 'ybins.end'}, name: 'end'},\n    {aStr: {x: 'xbins.size', y: 'ybins.size'}, name: 'size'},\n    {aStr: {x: 'nbinsx', y: 'nbinsy'}, name: 'nbins'}\n];\n\nvar BINDIRECTIONS = ['x', 'y'];\n\n// handle bin attrs and relink auto-determined values so fullData is complete\nmodule.exports = function crossTraceDefaults(fullData, fullLayout) {\n    var allBinOpts = fullLayout._histogramBinOpts = {};\n    var histTraces = [];\n    var mustMatchTracesLookup = {};\n    var otherTracesList = [];\n\n    var traceOut, traces, groupName, binDir;\n    var i, j, k;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceOut._input, traceOut, traceOut._module.attributes, attr, dflt);\n    }\n\n    function orientation2binDir(traceOut) {\n        return traceOut.orientation === 'v' ? 'x' : 'y';\n    }\n\n    function getAxisType(traceOut, binDir) {\n        var ax = axisIds.getFromTrace({_fullLayout: fullLayout}, traceOut, binDir);\n        return ax.type;\n    }\n\n    function fillBinOpts(traceOut, groupName, binDir) {\n        // N.B. group traces that don't have a bingroup with themselves\n        var fallbackGroupName = traceOut.uid + '__' + binDir;\n        if(!groupName) groupName = fallbackGroupName;\n\n        var axType = getAxisType(traceOut, binDir);\n        var calendar = traceOut[binDir + 'calendar'] || '';\n        var binOpts = allBinOpts[groupName];\n        var needsNewItem = true;\n\n        if(binOpts) {\n            if(axType === binOpts.axType && calendar === binOpts.calendar) {\n                needsNewItem = false;\n                binOpts.traces.push(traceOut);\n                binOpts.dirs.push(binDir);\n            } else {\n                groupName = fallbackGroupName;\n\n                if(axType !== binOpts.axType) {\n                    Lib.warn([\n                        'Attempted to group the bins of trace', traceOut.index,\n                        'set on a', 'type:' + axType, 'axis',\n                        'with bins on', 'type:' + binOpts.axType, 'axis.'\n                    ].join(' '));\n                }\n                if(calendar !== binOpts.calendar) {\n                    // prohibit bingroup for traces using different calendar,\n                    // there's probably a way to make this work, but skip for now\n                    Lib.warn([\n                        'Attempted to group the bins of trace', traceOut.index,\n                        'set with a', calendar, 'calendar',\n                        'with bins',\n                        (binOpts.calendar ? 'on a ' + binOpts.calendar + ' calendar' : 'w/o a set calendar')\n                    ].join(' '));\n                }\n            }\n        }\n\n        if(needsNewItem) {\n            allBinOpts[groupName] = {\n                traces: [traceOut],\n                dirs: [binDir],\n                axType: axType,\n                calendar: traceOut[binDir + 'calendar'] || ''\n            };\n        }\n        traceOut['_' + binDir + 'bingroup'] = groupName;\n    }\n\n    for(i = 0; i < fullData.length; i++) {\n        traceOut = fullData[i];\n\n        if(traceIs(traceOut, 'histogram')) {\n            histTraces.push(traceOut);\n\n            // TODO: this shouldn't be relinked as it's only used within calc\n            // https://github.com/plotly/plotly.js/issues/749\n            delete traceOut._xautoBinFinished;\n            delete traceOut._yautoBinFinished;\n\n            // N.B. need to coerce *alignmentgroup* before *bingroup*, as traces\n            // in same alignmentgroup \"have to match\"\n            if(!traceIs(traceOut, '2dMap')) {\n                handleGroupingDefaults(traceOut._input, traceOut, fullLayout, coerce);\n            }\n        }\n    }\n\n    var alignmentOpts = fullLayout._alignmentOpts || {};\n\n    // Look for traces that \"have to match\", that is:\n    // - 1d histogram traces on the same subplot with same orientation under barmode:stack,\n    // - 1d histogram traces on the same subplot with same orientation under barmode:group\n    // - 1d histogram traces on the same position axis with the same orientation\n    //   and the same *alignmentgroup* (coerced under barmode:group)\n    // - Once `stackgroup` gets implemented (see https://github.com/plotly/plotly.js/issues/3614),\n    //   traces within the same stackgroup will also \"have to match\"\n    for(i = 0; i < histTraces.length; i++) {\n        traceOut = histTraces[i];\n        groupName = '';\n\n        if(!traceIs(traceOut, '2dMap')) {\n            binDir = orientation2binDir(traceOut);\n\n            if(fullLayout.barmode === 'group' && traceOut.alignmentgroup) {\n                var pa = traceOut[binDir + 'axis'];\n                var aGroupId = getAxisGroup(fullLayout, pa) + traceOut.orientation;\n                if((alignmentOpts[aGroupId] || {})[traceOut.alignmentgroup]) {\n                    groupName = aGroupId;\n                }\n            }\n\n            if(!groupName && fullLayout.barmode !== 'overlay') {\n                groupName = (\n                    getAxisGroup(fullLayout, traceOut.xaxis) +\n                    getAxisGroup(fullLayout, traceOut.yaxis) +\n                    orientation2binDir(traceOut)\n                );\n            }\n        }\n\n        if(groupName) {\n            if(!mustMatchTracesLookup[groupName]) {\n                mustMatchTracesLookup[groupName] = [];\n            }\n            mustMatchTracesLookup[groupName].push(traceOut);\n        } else {\n            otherTracesList.push(traceOut);\n        }\n    }\n\n    // Setup binOpts for traces that have to match,\n    // if the traces have a valid bingroup, use that\n    // if not use axis+binDir groupName\n    for(groupName in mustMatchTracesLookup) {\n        traces = mustMatchTracesLookup[groupName];\n\n        // no need to 'force' anything when a single\n        // trace is detected as \"must match\"\n        if(traces.length === 1) {\n            otherTracesList.push(traces[0]);\n            continue;\n        }\n\n        var binGroupFound = false;\n        if(traces.length) {\n            traceOut = traces[0];\n            binGroupFound = coerce('bingroup');\n        }\n\n        groupName = binGroupFound || groupName;\n\n        for(i = 0; i < traces.length; i++) {\n            traceOut = traces[i];\n            var bingroupIn = traceOut._input.bingroup;\n            if(bingroupIn && bingroupIn !== groupName) {\n                Lib.warn([\n                    'Trace', traceOut.index, 'must match',\n                    'within bingroup', groupName + '.',\n                    'Ignoring its bingroup:', bingroupIn, 'setting.'\n                ].join(' '));\n            }\n            traceOut.bingroup = groupName;\n\n            // N.B. no need to worry about 2dMap case\n            // (where both bin direction are set in each trace)\n            // as 2dMap trace never \"have to match\"\n            fillBinOpts(traceOut, groupName, orientation2binDir(traceOut));\n        }\n    }\n\n    // setup binOpts for traces that can but don't have to match,\n    // notice that these traces can be matched with traces that have to match\n    for(i = 0; i < otherTracesList.length; i++) {\n        traceOut = otherTracesList[i];\n\n        var binGroup = coerce('bingroup');\n\n        if(traceIs(traceOut, '2dMap')) {\n            for(k = 0; k < 2; k++) {\n                binDir = BINDIRECTIONS[k];\n                var binGroupInDir = coerce(binDir + 'bingroup',\n                    binGroup ? binGroup + '__' + binDir : null\n                );\n                fillBinOpts(traceOut, binGroupInDir, binDir);\n            }\n        } else {\n            fillBinOpts(traceOut, binGroup, orientation2binDir(traceOut));\n        }\n    }\n\n    // coerce bin attrs!\n    for(groupName in allBinOpts) {\n        var binOpts = allBinOpts[groupName];\n        traces = binOpts.traces;\n\n        for(j = 0; j < BINATTRS.length; j++) {\n            var attrSpec = BINATTRS[j];\n            var attr = attrSpec.name;\n            var aStr;\n            var autoVals;\n\n            // nbins(x|y) is moot if we have a size. This depends on\n            // nbins coming after size in binAttrs.\n            if(attr === 'nbins' && binOpts.sizeFound) continue;\n\n            for(i = 0; i < traces.length; i++) {\n                traceOut = traces[i];\n                binDir = binOpts.dirs[i];\n                aStr = attrSpec.aStr[binDir];\n\n                if(nestedProperty(traceOut._input, aStr).get() !== undefined) {\n                    binOpts[attr] = coerce(aStr);\n                    binOpts[attr + 'Found'] = true;\n                    break;\n                }\n\n                autoVals = (traceOut._autoBin || {})[binDir] || {};\n                if(autoVals[attr]) {\n                    // if this is the *first* autoval\n                    nestedProperty(traceOut, aStr).set(autoVals[attr]);\n                }\n            }\n\n            // start and end we need to coerce anyway, after having collected the\n            // first of each into binOpts, in case a trace wants to restrict its\n            // data to a certain range\n            if(attr === 'start' || attr === 'end') {\n                for(; i < traces.length; i++) {\n                    traceOut = traces[i];\n                    if(traceOut['_' + binDir + 'bingroup']) {\n                        autoVals = (traceOut._autoBin || {})[binDir] || {};\n                        coerce(aStr, autoVals[attr]);\n                    }\n                }\n            }\n\n            if(attr === 'nbins' && !binOpts.sizeFound && !binOpts.nbinsFound) {\n                traceOut = traces[0];\n                binOpts[attr] = coerce(aStr);\n            }\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}