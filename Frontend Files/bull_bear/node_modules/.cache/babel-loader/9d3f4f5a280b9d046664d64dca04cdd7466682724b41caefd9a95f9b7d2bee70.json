{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar readPaths = require('./draw_newshape/helpers').readPaths;\nvar displayOutlines = require('./display_outlines');\nvar clearOutlineControllers = require('./handle_outline').clearOutlineControllers;\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar constants = require('./constants');\nvar helpers = require('./helpers');\nvar getPathString = helpers.getPathString;\nvar FROM_TL = require('../../constants/alignment').FROM_TL;\n\n// Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne,\n  eraseActiveShape: eraseActiveShape\n};\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n\n  // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n  fullLayout._shapeUpperLayer.selectAll('path').remove();\n  fullLayout._shapeLowerLayer.selectAll('path').remove();\n  fullLayout._shapeUpperLayer.selectAll('text').remove();\n  fullLayout._shapeLowerLayer.selectAll('text').remove();\n  for (var k in fullLayout._plots) {\n    var shapelayer = fullLayout._plots[k].shapelayer;\n    if (shapelayer) {\n      shapelayer.selectAll('path').remove();\n      shapelayer.selectAll('text').remove();\n    }\n  }\n  for (var i = 0; i < fullLayout.shapes.length; i++) {\n    if (fullLayout.shapes[i].visible) {\n      drawOne(gd, i);\n    }\n  }\n\n  // may need to resurrect this if we put text (LaTeX) in shapes\n  // return Plots.previousPromises(gd);\n}\n\nfunction shouldSkipEdits(gd) {\n  return !!gd._fullLayout._outlining;\n}\nfunction couldHaveActiveShape(gd) {\n  // for now keep config.editable: true as it was before shape-drawing PR\n  return !gd._context.edits.shapePosition;\n}\nfunction drawOne(gd, index) {\n  // remove the existing shape if there is one.\n  // because indices can change, we need to look in all shape layers\n  gd._fullLayout._paperdiv.selectAll('.shapelayer [data-index=\"' + index + '\"]').remove();\n  var o = helpers.makeShapesOptionsAndPlotinfo(gd, index);\n  var options = o.options;\n  var plotinfo = o.plotinfo;\n\n  // this shape is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n  if (!options._input || options.visible === false) return;\n  if (options.layer !== 'below') {\n    drawShape(gd._fullLayout._shapeUpperLayer);\n  } else if (options.xref === 'paper' || options.yref === 'paper') {\n    drawShape(gd._fullLayout._shapeLowerLayer);\n  } else {\n    if (plotinfo._hadPlotinfo) {\n      var mainPlot = plotinfo.mainplotinfo || plotinfo;\n      drawShape(mainPlot.shapelayer);\n    } else {\n      // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n      // This can happen if you reference the shape to an x / y axis combination\n      // that doesn't have any data on it (and layer is below)\n      drawShape(gd._fullLayout._shapeLowerLayer);\n    }\n  }\n  function drawShape(shapeLayer) {\n    var d = getPathString(gd, options);\n    var attrs = {\n      'data-index': index,\n      'fill-rule': options.fillrule,\n      d: d\n    };\n    var opacity = options.opacity;\n    var fillColor = options.fillcolor;\n    var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';\n    var lineWidth = options.line.width;\n    var lineDash = options.line.dash;\n    if (!lineWidth && options.editable === true) {\n      // ensure invisible border to activate the shape\n      lineWidth = 5;\n      lineDash = 'solid';\n    }\n    var isOpen = d[d.length - 1] !== 'Z';\n    var isActiveShape = couldHaveActiveShape(gd) && options.editable && gd._fullLayout._activeShapeIndex === index;\n    if (isActiveShape) {\n      fillColor = isOpen ? 'rgba(0,0,0,0)' : gd._fullLayout.activeshape.fillcolor;\n      opacity = gd._fullLayout.activeshape.opacity;\n    }\n    var shapeGroup = shapeLayer.append('g').classed('shape-group', true).attr({\n      'data-index': index\n    });\n    var path = shapeGroup.append('path').attr(attrs).style('opacity', opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(Drawing.dashLine, lineDash, lineWidth);\n    setClipPath(shapeGroup, gd, options);\n\n    // Draw or clear the label\n    drawLabel(gd, index, options, shapeGroup);\n    var editHelpers;\n    if (isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, 'shapes', options);\n    if (isActiveShape) {\n      path.style({\n        cursor: 'move'\n      });\n      var dragOptions = {\n        element: path.node(),\n        plotinfo: plotinfo,\n        gd: gd,\n        editHelpers: editHelpers,\n        hasText: options.label.text,\n        isActiveShape: true // i.e. to enable controllers\n      };\n\n      var polygons = readPaths(d, gd);\n      // display polygons on the screen\n      displayOutlines(polygons, path, dragOptions);\n    } else {\n      if (gd._context.edits.shapePosition) {\n        setupDragElement(gd, path, options, index, shapeLayer, editHelpers);\n      } else if (options.editable === true) {\n        path.style('pointer-events', isOpen || Color.opacity(fillColor) * opacity <= 0.5 ? 'stroke' : 'all');\n      }\n    }\n    path.node().addEventListener('click', function () {\n      return activateShape(gd, path);\n    });\n  }\n}\nfunction setClipPath(shapePath, gd, shapeOptions) {\n  // note that for layer=\"below\" the clipAxes can be different from the\n  // subplot we're drawing this in. This could cause problems if the shape\n  // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n  //\n  // if axis is 'paper' or an axis with \" domain\" appended, then there is no\n  // clip axis\n  var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '').replace(/[xyz][1-9]* *domain/g, '');\n  Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n}\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {\n  var MINWIDTH = 10;\n  var MINHEIGHT = 10;\n  var xPixelSized = shapeOptions.xsizemode === 'pixel';\n  var yPixelSized = shapeOptions.ysizemode === 'pixel';\n  var isLine = shapeOptions.type === 'line';\n  var isPath = shapeOptions.type === 'path';\n  var modifyItem = editHelpers.modifyItem;\n  var x0, y0, x1, y1, xAnchor, yAnchor;\n  var n0, s0, w0, e0, optN, optS, optW, optE;\n  var pathIn;\n  var shapeGroup = d3.select(shapePath.node().parentNode);\n\n  // setup conversion functions\n  var xa = Axes.getFromId(gd, shapeOptions.xref);\n  var xRefType = Axes.getRefType(shapeOptions.xref);\n  var ya = Axes.getFromId(gd, shapeOptions.yref);\n  var yRefType = Axes.getRefType(shapeOptions.yref);\n  var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);\n  var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);\n  var p2x = helpers.getPixelToData(gd, xa, false, xRefType);\n  var p2y = helpers.getPixelToData(gd, ya, true, yRefType);\n  var sensoryElement = obtainSensoryElement();\n  var dragOptions = {\n    element: sensoryElement.node(),\n    gd: gd,\n    prepFn: startDrag,\n    doneFn: endDrag,\n    clickFn: abortDrag\n  };\n  var dragMode;\n  dragElement.init(dragOptions);\n  sensoryElement.node().onmousemove = updateDragMode;\n  function obtainSensoryElement() {\n    return isLine ? createLineDragHandles() : shapePath;\n  }\n  function createLineDragHandles() {\n    var minSensoryWidth = 10;\n    var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);\n\n    // Helper shapes group\n    // Note that by setting the `data-index` attr, it is ensured that\n    // the helper group is purged in this modules `draw` function\n    var g = shapeLayer.append('g').attr('data-index', index).attr('drag-helper', true);\n\n    // Helper path for moving\n    g.append('path').attr('d', shapePath.attr('d')).style({\n      cursor: 'move',\n      'stroke-width': sensoryWidth,\n      'stroke-opacity': '0' // ensure not visible\n    });\n\n    // Helper circles for resizing\n    var circleStyle = {\n      'fill-opacity': '0' // ensure not visible\n    };\n\n    var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);\n    g.append('circle').attr({\n      'data-line-point': 'start-point',\n      cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n      cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n      r: circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    g.append('circle').attr({\n      'data-line-point': 'end-point',\n      cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n      cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n      r: circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    return g;\n  }\n  function updateDragMode(evt) {\n    if (shouldSkipEdits(gd)) {\n      dragMode = null;\n      return;\n    }\n    if (isLine) {\n      if (evt.target.tagName === 'path') {\n        dragMode = 'move';\n      } else {\n        dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ? 'resize-over-start-point' : 'resize-over-end-point';\n      }\n    } else {\n      // element might not be on screen at time of setup,\n      // so obtain bounding box here\n      var dragBBox = dragOptions.element.getBoundingClientRect();\n\n      // choose 'move' or 'resize'\n      // based on initial position of cursor within the drag element\n      var w = dragBBox.right - dragBBox.left;\n      var h = dragBBox.bottom - dragBBox.top;\n      var x = evt.clientX - dragBBox.left;\n      var y = evt.clientY - dragBBox.top;\n      var cursor = !isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey ? dragElement.getCursor(x / w, 1 - y / h) : 'move';\n      setCursor(shapePath, cursor);\n\n      // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n      dragMode = cursor.split('-')[0];\n    }\n  }\n  function startDrag(evt) {\n    if (shouldSkipEdits(gd)) return;\n\n    // setup update strings and initial values\n    if (xPixelSized) {\n      xAnchor = x2p(shapeOptions.xanchor);\n    }\n    if (yPixelSized) {\n      yAnchor = y2p(shapeOptions.yanchor);\n    }\n    if (shapeOptions.type === 'path') {\n      pathIn = shapeOptions.path;\n    } else {\n      x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n      y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n      x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n      y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n    }\n    if (x0 < x1) {\n      w0 = x0;\n      optW = 'x0';\n      e0 = x1;\n      optE = 'x1';\n    } else {\n      w0 = x1;\n      optW = 'x1';\n      e0 = x0;\n      optE = 'x0';\n    }\n\n    // For fixed size shapes take opposing direction of y-axis into account.\n    // Hint: For data sized shapes this is done by the y2p function.\n    if (!yPixelSized && y0 < y1 || yPixelSized && y0 > y1) {\n      n0 = y0;\n      optN = 'y0';\n      s0 = y1;\n      optS = 'y1';\n    } else {\n      n0 = y1;\n      optN = 'y1';\n      s0 = y0;\n      optS = 'y0';\n    }\n\n    // setup dragMode and the corresponding handler\n    updateDragMode(evt);\n    renderVisualCues(shapeLayer, shapeOptions);\n    deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n    dragOptions.moveFn = dragMode === 'move' ? moveShape : resizeShape;\n    dragOptions.altKey = evt.altKey;\n  }\n  function endDrag() {\n    if (shouldSkipEdits(gd)) return;\n    setCursor(shapePath);\n    removeVisualCues(shapeLayer);\n\n    // Don't rely on clipPath being activated during re-layout\n    setClipPath(shapePath, gd, shapeOptions);\n    Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());\n  }\n  function abortDrag() {\n    if (shouldSkipEdits(gd)) return;\n    removeVisualCues(shapeLayer);\n  }\n  function moveShape(dx, dy) {\n    if (shapeOptions.type === 'path') {\n      var noOp = function (coord) {\n        return coord;\n      };\n      var moveX = noOp;\n      var moveY = noOp;\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else {\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));\n        modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));\n      }\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));\n        modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));\n      }\n    }\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n    drawLabel(gd, index, shapeOptions, shapeGroup);\n  }\n  function resizeShape(dx, dy) {\n    if (isPath) {\n      // TODO: implement path resize, don't forget to update dragMode code\n      var noOp = function (coord) {\n        return coord;\n      };\n      var moveX = noOp;\n      var moveY = noOp;\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else if (isLine) {\n      if (dragMode === 'resize-over-start-point') {\n        var newX0 = x0 + dx;\n        var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n        modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));\n        modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));\n      } else if (dragMode === 'resize-over-end-point') {\n        var newX1 = x1 + dx;\n        var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n        modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));\n        modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));\n      }\n    } else {\n      var has = function (str) {\n        return dragMode.indexOf(str) !== -1;\n      };\n      var hasN = has('n');\n      var hasS = has('s');\n      var hasW = has('w');\n      var hasE = has('e');\n      var newN = hasN ? n0 + dy : n0;\n      var newS = hasS ? s0 + dy : s0;\n      var newW = hasW ? w0 + dx : w0;\n      var newE = hasE ? e0 + dx : e0;\n      if (yPixelSized) {\n        // Do things in opposing direction for y-axis.\n        // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n        if (hasN) newN = n0 - dy;\n        if (hasS) newS = s0 - dy;\n      }\n\n      // Update shape eventually. Again, be aware of the\n      // opposing direction of the y-axis of fixed size shapes.\n      if (!yPixelSized && newS - newN > MINHEIGHT || yPixelSized && newN - newS > MINHEIGHT) {\n        modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));\n        modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));\n      }\n      if (newE - newW > MINWIDTH) {\n        modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));\n        modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));\n      }\n    }\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n    drawLabel(gd, index, shapeOptions, shapeGroup);\n  }\n  function renderVisualCues(shapeLayer, shapeOptions) {\n    if (xPixelSized || yPixelSized) {\n      renderAnchor();\n    }\n    function renderAnchor() {\n      var isNotPath = shapeOptions.type !== 'path';\n\n      // d3 join with dummy data to satisfy d3 data-binding\n      var visualCues = shapeLayer.selectAll('.visual-cue').data([0]);\n\n      // Enter\n      var strokeWidth = 1;\n      visualCues.enter().append('path').attr({\n        fill: '#fff',\n        'fill-rule': 'evenodd',\n        stroke: '#000',\n        'stroke-width': strokeWidth\n      }).classed('visual-cue', true);\n\n      // Update\n      var posX = x2p(xPixelSized ? shapeOptions.xanchor : Lib.midRange(isNotPath ? [shapeOptions.x0, shapeOptions.x1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsX)));\n      var posY = y2p(yPixelSized ? shapeOptions.yanchor : Lib.midRange(isNotPath ? [shapeOptions.y0, shapeOptions.y1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsY)));\n      posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n      posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n      if (xPixelSized && yPixelSized) {\n        var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n        visualCues.attr('d', crossPath);\n      } else if (xPixelSized) {\n        var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) + 'v18 h2 v-18 Z';\n        visualCues.attr('d', vBarPath);\n      } else {\n        var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h18 v2 h-18 Z';\n        visualCues.attr('d', hBarPath);\n      }\n    }\n  }\n  function removeVisualCues(shapeLayer) {\n    shapeLayer.selectAll('.visual-cue').remove();\n  }\n  function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n    var xref = shapeOptions.xref;\n    var yref = shapeOptions.yref;\n    var xa = Axes.getFromId(gd, xref);\n    var ya = Axes.getFromId(gd, yref);\n    var clipAxes = '';\n    if (xref !== 'paper' && !xa.autorange) clipAxes += xref;\n    if (yref !== 'paper' && !ya.autorange) clipAxes += yref;\n    Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n  }\n}\nfunction drawLabel(gd, index, options, shapeGroup) {\n  // Remove existing label\n  shapeGroup.selectAll('.shape-label').remove();\n\n  // If no label, return\n  if (!options.label.text) return;\n  var labelGroupAttrs = {\n    'data-index': index\n  };\n  var text = options.label.text;\n  var font = options.label.font;\n  var labelTextAttrs = {\n    'data-notex': 1\n  };\n  var labelGroup = shapeGroup.append('g').attr(labelGroupAttrs).classed('shape-label', true);\n  var labelText = labelGroup.append('text').attr(labelTextAttrs).classed('shape-label-text', true).text(text);\n\n  // Get x and y bounds of shape\n  var shapex0, shapex1, shapey0, shapey1;\n  if (options.path) {\n    // If shape is defined as a path, get the\n    // min and max bounds across all polygons in path\n    var d = getPathString(gd, options);\n    var polygons = readPaths(d, gd);\n    shapex0 = Infinity;\n    shapey0 = Infinity;\n    shapex1 = -Infinity;\n    shapey1 = -Infinity;\n    for (var i = 0; i < polygons.length; i++) {\n      for (var j = 0; j < polygons[i].length; j++) {\n        var p = polygons[i][j];\n        for (var k = 1; k < p.length; k += 2) {\n          var _x = p[k];\n          var _y = p[k + 1];\n          shapex0 = Math.min(shapex0, _x);\n          shapex1 = Math.max(shapex1, _x);\n          shapey0 = Math.min(shapey0, _y);\n          shapey1 = Math.max(shapey1, _y);\n        }\n      }\n    }\n  } else {\n    // Otherwise, we use the x and y bounds defined in the shape options\n    // and convert them to pixel coordinates\n    // Setup conversion functions\n    var xa = Axes.getFromId(gd, options.xref);\n    var xRefType = Axes.getRefType(options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n    var yRefType = Axes.getRefType(options.yref);\n    var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);\n    var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);\n    shapex0 = x2p(options.x0);\n    shapex1 = x2p(options.x1);\n    shapey0 = y2p(options.y0);\n    shapey1 = y2p(options.y1);\n  }\n\n  // Handle `auto` angle\n  var textangle = options.label.textangle;\n  if (textangle === 'auto') {\n    if (options.type === 'line') {\n      // Auto angle for line is same angle as line\n      textangle = calcTextAngle(shapex0, shapey0, shapex1, shapey1);\n    } else {\n      // Auto angle for all other shapes is 0\n      textangle = 0;\n    }\n  }\n\n  // Do an initial render so we can get the text bounding box height\n  labelText.call(function (s) {\n    s.call(Drawing.font, font).attr({});\n    svgTextUtils.convertToTspans(s, gd);\n    return s;\n  });\n  var textBB = Drawing.bBox(labelText.node());\n\n  // Calculate correct (x,y) for text\n  // We also determine true xanchor since xanchor depends on position when set to 'auto'\n  var textPos = calcTextPosition(shapex0, shapey0, shapex1, shapey1, options, textangle, textBB);\n  var textx = textPos.textx;\n  var texty = textPos.texty;\n  var xanchor = textPos.xanchor;\n\n  // Update (x,y) position, xanchor, and angle\n  labelText.attr({\n    'text-anchor': {\n      left: 'start',\n      center: 'middle',\n      right: 'end'\n    }[xanchor],\n    y: texty,\n    x: textx,\n    transform: 'rotate(' + textangle + ',' + textx + ',' + texty + ')'\n  }).call(svgTextUtils.positionText, textx, texty);\n}\nfunction calcTextAngle(shapex0, shapey0, shapex1, shapey1) {\n  var dy, dx;\n  dx = Math.abs(shapex1 - shapex0);\n  if (shapex1 >= shapex0) {\n    dy = shapey0 - shapey1;\n  } else {\n    dy = shapey1 - shapey0;\n  }\n  return -180 / Math.PI * Math.atan2(dy, dx);\n}\nfunction calcTextPosition(shapex0, shapey0, shapex1, shapey1, shapeOptions, actualTextAngle, textBB) {\n  var textPosition = shapeOptions.label.textposition;\n  var textAngle = shapeOptions.label.textangle;\n  var textPadding = shapeOptions.label.padding;\n  var shapeType = shapeOptions.type;\n  var textAngleRad = Math.PI / 180 * actualTextAngle;\n  var sinA = Math.sin(textAngleRad);\n  var cosA = Math.cos(textAngleRad);\n  var xanchor = shapeOptions.label.xanchor;\n  var yanchor = shapeOptions.label.yanchor;\n  var textx, texty, paddingX, paddingY;\n\n  // Text position functions differently for lines vs. other shapes\n  if (shapeType === 'line') {\n    // Set base position for start vs. center vs. end of line (default is 'center')\n    if (textPosition === 'start') {\n      textx = shapex0;\n      texty = shapey0;\n    } else if (textPosition === 'end') {\n      textx = shapex1;\n      texty = shapey1;\n    } else {\n      // Default: center\n      textx = (shapex0 + shapex1) / 2;\n      texty = (shapey0 + shapey1) / 2;\n    }\n\n    // Set xanchor if xanchor is 'auto'\n    if (xanchor === 'auto') {\n      if (textPosition === 'start') {\n        if (textAngle === 'auto') {\n          if (shapex1 > shapex0) xanchor = 'left';else if (shapex1 < shapex0) xanchor = 'right';else xanchor = 'center';\n        } else {\n          if (shapex1 > shapex0) xanchor = 'right';else if (shapex1 < shapex0) xanchor = 'left';else xanchor = 'center';\n        }\n      } else if (textPosition === 'end') {\n        if (textAngle === 'auto') {\n          if (shapex1 > shapex0) xanchor = 'right';else if (shapex1 < shapex0) xanchor = 'left';else xanchor = 'center';\n        } else {\n          if (shapex1 > shapex0) xanchor = 'left';else if (shapex1 < shapex0) xanchor = 'right';else xanchor = 'center';\n        }\n      } else {\n        xanchor = 'center';\n      }\n    }\n\n    // Special case for padding when angle is 'auto' for lines\n    // Padding should be treated as an orthogonal offset in this case\n    // Otherwise, padding is just a simple x and y offset\n    var paddingConstantsX = {\n      left: 1,\n      center: 0,\n      right: -1\n    };\n    var paddingConstantsY = {\n      bottom: -1,\n      middle: 0,\n      top: 1\n    };\n    if (textAngle === 'auto') {\n      // Set direction to apply padding (based on `yanchor` only)\n      var paddingDirection = paddingConstantsY[yanchor];\n      paddingX = -textPadding * sinA * paddingDirection;\n      paddingY = textPadding * cosA * paddingDirection;\n    } else {\n      // Set direction to apply padding (based on `xanchor` and `yanchor`)\n      var paddingDirectionX = paddingConstantsX[xanchor];\n      var paddingDirectionY = paddingConstantsY[yanchor];\n      paddingX = textPadding * paddingDirectionX;\n      paddingY = textPadding * paddingDirectionY;\n    }\n    textx = textx + paddingX;\n    texty = texty + paddingY;\n  } else {\n    // Text position for shapes that are not lines\n    // calc horizontal position\n    // Horizontal needs a little extra padding to look balanced\n    paddingX = textPadding + 3;\n    if (textPosition.indexOf('right') !== -1) {\n      textx = Math.max(shapex0, shapex1) - paddingX;\n      if (xanchor === 'auto') xanchor = 'right';\n    } else if (textPosition.indexOf('left') !== -1) {\n      textx = Math.min(shapex0, shapex1) + paddingX;\n      if (xanchor === 'auto') xanchor = 'left';\n    } else {\n      // Default: center\n      textx = (shapex0 + shapex1) / 2;\n      if (xanchor === 'auto') xanchor = 'center';\n    }\n\n    // calc vertical position\n    if (textPosition.indexOf('top') !== -1) {\n      texty = Math.min(shapey0, shapey1);\n    } else if (textPosition.indexOf('bottom') !== -1) {\n      texty = Math.max(shapey0, shapey1);\n    } else {\n      texty = (shapey0 + shapey1) / 2;\n    }\n    // Apply padding\n    paddingY = textPadding;\n    if (yanchor === 'bottom') {\n      texty = texty - paddingY;\n    } else if (yanchor === 'top') {\n      texty = texty + paddingY;\n    }\n  }\n\n  // Shift vertical (& horizontal) position according to `yanchor`\n  var shiftFraction = FROM_TL[yanchor];\n  // Adjust so that text is anchored at top of first line rather than at baseline of first line\n  var baselineAdjust = shapeOptions.label.font.size;\n  var textHeight = textBB.height;\n  var xshift = (textHeight * shiftFraction - baselineAdjust) * sinA;\n  var yshift = -(textHeight * shiftFraction - baselineAdjust) * cosA;\n  return {\n    textx: textx + xshift,\n    texty: texty + yshift,\n    xanchor: xanchor\n  };\n}\nfunction movePath(pathIn, moveX, moveY) {\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (paramNumber >= nParams) return param;\n      if (xParams[paramNumber]) param = moveX(param);else if (yParams[paramNumber]) param = moveY(param);\n      paramNumber++;\n      return param;\n    });\n    return segmentType + paramString;\n  });\n}\nfunction activateShape(gd, path) {\n  if (!couldHaveActiveShape(gd)) return;\n  var element = path.node();\n  var id = +element.getAttribute('data-index');\n  if (id >= 0) {\n    // deactivate if already active\n    if (id === gd._fullLayout._activeShapeIndex) {\n      deactivateShape(gd);\n      return;\n    }\n    gd._fullLayout._activeShapeIndex = id;\n    gd._fullLayout._deactivateShape = deactivateShape;\n    draw(gd);\n  }\n}\nfunction deactivateShape(gd) {\n  if (!couldHaveActiveShape(gd)) return;\n  var id = gd._fullLayout._activeShapeIndex;\n  if (id >= 0) {\n    clearOutlineControllers(gd);\n    delete gd._fullLayout._activeShapeIndex;\n    draw(gd);\n  }\n}\nfunction eraseActiveShape(gd) {\n  if (!couldHaveActiveShape(gd)) return;\n  clearOutlineControllers(gd);\n  var id = gd._fullLayout._activeShapeIndex;\n  var shapes = (gd.layout || {}).shapes || [];\n  if (id < shapes.length) {\n    var list = [];\n    for (var q = 0; q < shapes.length; q++) {\n      if (q !== id) {\n        list.push(shapes[q]);\n      }\n    }\n    delete gd._fullLayout._activeShapeIndex;\n    Registry.call('_guiRelayout', gd, {\n      shapes: list\n    });\n  }\n}","map":{"version":3,"names":["d3","require","Registry","Lib","Axes","readPaths","displayOutlines","clearOutlineControllers","Color","Drawing","arrayEditor","dragElement","setCursor","svgTextUtils","constants","helpers","getPathString","FROM_TL","module","exports","draw","drawOne","eraseActiveShape","gd","fullLayout","_fullLayout","_shapeUpperLayer","selectAll","remove","_shapeLowerLayer","k","_plots","shapelayer","i","shapes","length","visible","shouldSkipEdits","_outlining","couldHaveActiveShape","_context","edits","shapePosition","index","_paperdiv","o","makeShapesOptionsAndPlotinfo","options","plotinfo","_input","layer","drawShape","xref","yref","_hadPlotinfo","mainPlot","mainplotinfo","shapeLayer","d","attrs","fillrule","opacity","fillColor","fillcolor","lineColor","line","width","color","lineWidth","lineDash","dash","editable","isOpen","isActiveShape","_activeShapeIndex","activeshape","shapeGroup","append","classed","attr","path","style","call","stroke","fill","dashLine","setClipPath","drawLabel","editHelpers","layout","cursor","dragOptions","element","node","hasText","label","text","polygons","setupDragElement","addEventListener","activateShape","shapePath","shapeOptions","clipAxes","replace","setClipUrl","_uid","MINWIDTH","MINHEIGHT","xPixelSized","xsizemode","yPixelSized","ysizemode","isLine","type","isPath","modifyItem","x0","y0","x1","y1","xAnchor","yAnchor","n0","s0","w0","e0","optN","optS","optW","optE","pathIn","select","parentNode","xa","getFromId","xRefType","getRefType","ya","yRefType","x2p","getDataToPixel","y2p","p2x","getPixelToData","p2y","sensoryElement","obtainSensoryElement","prepFn","startDrag","doneFn","endDrag","clickFn","abortDrag","dragMode","init","onmousemove","updateDragMode","createLineDragHandles","minSensoryWidth","sensoryWidth","Math","max","g","circleStyle","circleRadius","cx","xanchor","cy","yanchor","r","evt","target","tagName","attributes","value","dragBBox","getBoundingClientRect","w","right","left","h","bottom","top","x","clientX","y","clientY","shiftKey","getCursor","split","renderVisualCues","deactivateClipPathTemporarily","moveFn","moveShape","resizeShape","altKey","removeVisualCues","getUpdateObj","dx","dy","noOp","coord","moveX","moveY","encodeDate","movePath","newX0","newY0","newX1","newY1","has","str","indexOf","hasN","hasS","hasW","hasE","newN","newS","newW","newE","renderAnchor","isNotPath","visualCues","data","strokeWidth","enter","posX","midRange","extractPathCoords","paramIsX","posY","paramIsY","roundPositionForSharpStrokeRendering","crossPath","vBarPath","hBarPath","autorange","labelGroupAttrs","font","labelTextAttrs","labelGroup","labelText","shapex0","shapex1","shapey0","shapey1","Infinity","j","p","_x","_y","min","textangle","calcTextAngle","s","convertToTspans","textBB","bBox","textPos","calcTextPosition","textx","texty","center","transform","positionText","abs","PI","atan2","actualTextAngle","textPosition","textposition","textAngle","textPadding","padding","shapeType","textAngleRad","sinA","sin","cosA","cos","paddingX","paddingY","paddingConstantsX","paddingConstantsY","middle","paddingDirection","paddingDirectionX","paddingDirectionY","shiftFraction","baselineAdjust","size","textHeight","height","xshift","yshift","segmentRE","segment","paramNumber","segmentType","charAt","xParams","yParams","nParams","numParams","paramString","substr","paramRE","param","id","getAttribute","deactivateShape","_deactivateShape","list","q","push"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/components/shapes/draw.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar readPaths = require('./draw_newshape/helpers').readPaths;\nvar displayOutlines = require('./display_outlines');\n\nvar clearOutlineControllers = require('./handle_outline').clearOutlineControllers;\n\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar constants = require('./constants');\nvar helpers = require('./helpers');\nvar getPathString = helpers.getPathString;\nvar FROM_TL = require('../../constants/alignment').FROM_TL;\n\n\n// Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne,\n    eraseActiveShape: eraseActiveShape\n};\n\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n    fullLayout._shapeUpperLayer.selectAll('path').remove();\n    fullLayout._shapeLowerLayer.selectAll('path').remove();\n    fullLayout._shapeUpperLayer.selectAll('text').remove();\n    fullLayout._shapeLowerLayer.selectAll('text').remove();\n\n    for(var k in fullLayout._plots) {\n        var shapelayer = fullLayout._plots[k].shapelayer;\n        if(shapelayer) {\n            shapelayer.selectAll('path').remove();\n            shapelayer.selectAll('text').remove();\n        }\n    }\n\n    for(var i = 0; i < fullLayout.shapes.length; i++) {\n        if(fullLayout.shapes[i].visible) {\n            drawOne(gd, i);\n        }\n    }\n\n    // may need to resurrect this if we put text (LaTeX) in shapes\n    // return Plots.previousPromises(gd);\n}\n\nfunction shouldSkipEdits(gd) {\n    return !!gd._fullLayout._outlining;\n}\n\nfunction couldHaveActiveShape(gd) {\n    // for now keep config.editable: true as it was before shape-drawing PR\n    return !gd._context.edits.shapePosition;\n}\n\nfunction drawOne(gd, index) {\n    // remove the existing shape if there is one.\n    // because indices can change, we need to look in all shape layers\n    gd._fullLayout._paperdiv\n        .selectAll('.shapelayer [data-index=\"' + index + '\"]')\n        .remove();\n\n    var o = helpers.makeShapesOptionsAndPlotinfo(gd, index);\n    var options = o.options;\n    var plotinfo = o.plotinfo;\n\n    // this shape is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!options._input || options.visible === false) return;\n\n    if(options.layer !== 'below') {\n        drawShape(gd._fullLayout._shapeUpperLayer);\n    } else if(options.xref === 'paper' || options.yref === 'paper') {\n        drawShape(gd._fullLayout._shapeLowerLayer);\n    } else {\n        if(plotinfo._hadPlotinfo) {\n            var mainPlot = plotinfo.mainplotinfo || plotinfo;\n            drawShape(mainPlot.shapelayer);\n        } else {\n            // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n            // This can happen if you reference the shape to an x / y axis combination\n            // that doesn't have any data on it (and layer is below)\n            drawShape(gd._fullLayout._shapeLowerLayer);\n        }\n    }\n\n    function drawShape(shapeLayer) {\n        var d = getPathString(gd, options);\n        var attrs = {\n            'data-index': index,\n            'fill-rule': options.fillrule,\n            d: d\n        };\n\n        var opacity = options.opacity;\n        var fillColor = options.fillcolor;\n        var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';\n        var lineWidth = options.line.width;\n        var lineDash = options.line.dash;\n        if(!lineWidth && options.editable === true) {\n            // ensure invisible border to activate the shape\n            lineWidth = 5;\n            lineDash = 'solid';\n        }\n\n        var isOpen = d[d.length - 1] !== 'Z';\n\n        var isActiveShape = couldHaveActiveShape(gd) &&\n            options.editable && gd._fullLayout._activeShapeIndex === index;\n\n        if(isActiveShape) {\n            fillColor = isOpen ? 'rgba(0,0,0,0)' :\n                gd._fullLayout.activeshape.fillcolor;\n\n            opacity = gd._fullLayout.activeshape.opacity;\n        }\n\n        var shapeGroup = shapeLayer.append('g')\n            .classed('shape-group', true)\n            .attr({ 'data-index': index });\n\n        var path = shapeGroup.append('path')\n            .attr(attrs)\n            .style('opacity', opacity)\n            .call(Color.stroke, lineColor)\n            .call(Color.fill, fillColor)\n            .call(Drawing.dashLine, lineDash, lineWidth);\n\n        setClipPath(shapeGroup, gd, options);\n\n        // Draw or clear the label\n        drawLabel(gd, index, options, shapeGroup);\n\n        var editHelpers;\n        if(isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, 'shapes', options);\n\n        if(isActiveShape) {\n            path.style({\n                cursor: 'move',\n            });\n\n            var dragOptions = {\n                element: path.node(),\n                plotinfo: plotinfo,\n                gd: gd,\n                editHelpers: editHelpers,\n                hasText: options.label.text,\n                isActiveShape: true // i.e. to enable controllers\n            };\n\n            var polygons = readPaths(d, gd);\n            // display polygons on the screen\n            displayOutlines(polygons, path, dragOptions);\n        } else {\n            if(gd._context.edits.shapePosition) {\n                setupDragElement(gd, path, options, index, shapeLayer, editHelpers);\n            } else if(options.editable === true) {\n                path.style('pointer-events',\n                    (isOpen || Color.opacity(fillColor) * opacity <= 0.5) ? 'stroke' : 'all'\n                );\n            }\n        }\n        path.node().addEventListener('click', function() { return activateShape(gd, path); });\n    }\n}\n\nfunction setClipPath(shapePath, gd, shapeOptions) {\n    // note that for layer=\"below\" the clipAxes can be different from the\n    // subplot we're drawing this in. This could cause problems if the shape\n    // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n    //\n    // if axis is 'paper' or an axis with \" domain\" appended, then there is no\n    // clip axis\n    var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '').replace(/[xyz][1-9]* *domain/g, '');\n\n    Drawing.setClipUrl(\n        shapePath,\n        clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null,\n        gd\n    );\n}\n\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {\n    var MINWIDTH = 10;\n    var MINHEIGHT = 10;\n\n    var xPixelSized = shapeOptions.xsizemode === 'pixel';\n    var yPixelSized = shapeOptions.ysizemode === 'pixel';\n    var isLine = shapeOptions.type === 'line';\n    var isPath = shapeOptions.type === 'path';\n\n    var modifyItem = editHelpers.modifyItem;\n\n    var x0, y0, x1, y1, xAnchor, yAnchor;\n    var n0, s0, w0, e0, optN, optS, optW, optE;\n    var pathIn;\n\n    var shapeGroup = d3.select(shapePath.node().parentNode);\n\n    // setup conversion functions\n    var xa = Axes.getFromId(gd, shapeOptions.xref);\n    var xRefType = Axes.getRefType(shapeOptions.xref);\n    var ya = Axes.getFromId(gd, shapeOptions.yref);\n    var yRefType = Axes.getRefType(shapeOptions.yref);\n    var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);\n    var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);\n    var p2x = helpers.getPixelToData(gd, xa, false, xRefType);\n    var p2y = helpers.getPixelToData(gd, ya, true, yRefType);\n\n    var sensoryElement = obtainSensoryElement();\n    var dragOptions = {\n        element: sensoryElement.node(),\n        gd: gd,\n        prepFn: startDrag,\n        doneFn: endDrag,\n        clickFn: abortDrag\n    };\n    var dragMode;\n\n    dragElement.init(dragOptions);\n\n    sensoryElement.node().onmousemove = updateDragMode;\n\n    function obtainSensoryElement() {\n        return isLine ? createLineDragHandles() : shapePath;\n    }\n\n    function createLineDragHandles() {\n        var minSensoryWidth = 10;\n        var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);\n\n        // Helper shapes group\n        // Note that by setting the `data-index` attr, it is ensured that\n        // the helper group is purged in this modules `draw` function\n        var g = shapeLayer.append('g')\n            .attr('data-index', index)\n            .attr('drag-helper', true);\n\n        // Helper path for moving\n        g.append('path')\n          .attr('d', shapePath.attr('d'))\n          .style({\n              cursor: 'move',\n              'stroke-width': sensoryWidth,\n              'stroke-opacity': '0' // ensure not visible\n          });\n\n        // Helper circles for resizing\n        var circleStyle = {\n            'fill-opacity': '0' // ensure not visible\n        };\n        var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'start-point',\n              cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n              cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n              r: circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'end-point',\n              cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n              cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n              r: circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        return g;\n    }\n\n    function updateDragMode(evt) {\n        if(shouldSkipEdits(gd)) {\n            dragMode = null;\n            return;\n        }\n\n        if(isLine) {\n            if(evt.target.tagName === 'path') {\n                dragMode = 'move';\n            } else {\n                dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ?\n                  'resize-over-start-point' : 'resize-over-end-point';\n            }\n        } else {\n            // element might not be on screen at time of setup,\n            // so obtain bounding box here\n            var dragBBox = dragOptions.element.getBoundingClientRect();\n\n            // choose 'move' or 'resize'\n            // based on initial position of cursor within the drag element\n            var w = dragBBox.right - dragBBox.left;\n            var h = dragBBox.bottom - dragBBox.top;\n            var x = evt.clientX - dragBBox.left;\n            var y = evt.clientY - dragBBox.top;\n            var cursor = (!isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey) ?\n                dragElement.getCursor(x / w, 1 - y / h) :\n                'move';\n\n            setCursor(shapePath, cursor);\n\n            // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n            dragMode = cursor.split('-')[0];\n        }\n    }\n\n    function startDrag(evt) {\n        if(shouldSkipEdits(gd)) return;\n\n        // setup update strings and initial values\n        if(xPixelSized) {\n            xAnchor = x2p(shapeOptions.xanchor);\n        }\n        if(yPixelSized) {\n            yAnchor = y2p(shapeOptions.yanchor);\n        }\n\n        if(shapeOptions.type === 'path') {\n            pathIn = shapeOptions.path;\n        } else {\n            x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n            y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n            x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n            y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n        }\n\n        if(x0 < x1) {\n            w0 = x0;\n            optW = 'x0';\n            e0 = x1;\n            optE = 'x1';\n        } else {\n            w0 = x1;\n            optW = 'x1';\n            e0 = x0;\n            optE = 'x0';\n        }\n\n        // For fixed size shapes take opposing direction of y-axis into account.\n        // Hint: For data sized shapes this is done by the y2p function.\n        if((!yPixelSized && y0 < y1) || (yPixelSized && y0 > y1)) {\n            n0 = y0;\n            optN = 'y0';\n            s0 = y1;\n            optS = 'y1';\n        } else {\n            n0 = y1;\n            optN = 'y1';\n            s0 = y0;\n            optS = 'y0';\n        }\n\n        // setup dragMode and the corresponding handler\n        updateDragMode(evt);\n        renderVisualCues(shapeLayer, shapeOptions);\n        deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n        dragOptions.moveFn = (dragMode === 'move') ? moveShape : resizeShape;\n        dragOptions.altKey = evt.altKey;\n    }\n\n    function endDrag() {\n        if(shouldSkipEdits(gd)) return;\n\n        setCursor(shapePath);\n        removeVisualCues(shapeLayer);\n\n        // Don't rely on clipPath being activated during re-layout\n        setClipPath(shapePath, gd, shapeOptions);\n        Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());\n    }\n\n    function abortDrag() {\n        if(shouldSkipEdits(gd)) return;\n\n        removeVisualCues(shapeLayer);\n    }\n\n    function moveShape(dx, dy) {\n        if(shapeOptions.type === 'path') {\n            var noOp = function(coord) { return coord; };\n            var moveX = noOp;\n            var moveY = noOp;\n\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n        } else {\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));\n                modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));\n                modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n        drawLabel(gd, index, shapeOptions, shapeGroup);\n    }\n\n    function resizeShape(dx, dy) {\n        if(isPath) {\n            // TODO: implement path resize, don't forget to update dragMode code\n            var noOp = function(coord) { return coord; };\n            var moveX = noOp;\n            var moveY = noOp;\n\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n        } else if(isLine) {\n            if(dragMode === 'resize-over-start-point') {\n                var newX0 = x0 + dx;\n                var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n                modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));\n                modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));\n            } else if(dragMode === 'resize-over-end-point') {\n                var newX1 = x1 + dx;\n                var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n                modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));\n                modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));\n            }\n        } else {\n            var has = function(str) { return dragMode.indexOf(str) !== -1; };\n            var hasN = has('n');\n            var hasS = has('s');\n            var hasW = has('w');\n            var hasE = has('e');\n\n            var newN = hasN ? n0 + dy : n0;\n            var newS = hasS ? s0 + dy : s0;\n            var newW = hasW ? w0 + dx : w0;\n            var newE = hasE ? e0 + dx : e0;\n\n            if(yPixelSized) {\n                // Do things in opposing direction for y-axis.\n                // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n                if(hasN) newN = n0 - dy;\n                if(hasS) newS = s0 - dy;\n            }\n\n            // Update shape eventually. Again, be aware of the\n            // opposing direction of the y-axis of fixed size shapes.\n            if(\n                (!yPixelSized && newS - newN > MINHEIGHT) ||\n                (yPixelSized && newN - newS > MINHEIGHT)\n            ) {\n                modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));\n                modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));\n            }\n            if(newE - newW > MINWIDTH) {\n                modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));\n                modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n        drawLabel(gd, index, shapeOptions, shapeGroup);\n    }\n\n    function renderVisualCues(shapeLayer, shapeOptions) {\n        if(xPixelSized || yPixelSized) {\n            renderAnchor();\n        }\n\n        function renderAnchor() {\n            var isNotPath = shapeOptions.type !== 'path';\n\n            // d3 join with dummy data to satisfy d3 data-binding\n            var visualCues = shapeLayer.selectAll('.visual-cue').data([0]);\n\n            // Enter\n            var strokeWidth = 1;\n            visualCues.enter()\n              .append('path')\n              .attr({\n                  fill: '#fff',\n                  'fill-rule': 'evenodd',\n                  stroke: '#000',\n                  'stroke-width': strokeWidth\n              })\n              .classed('visual-cue', true);\n\n            // Update\n            var posX = x2p(\n              xPixelSized ?\n                shapeOptions.xanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.x0, shapeOptions.x1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsX))\n            );\n            var posY = y2p(\n              yPixelSized ?\n                shapeOptions.yanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.y0, shapeOptions.y1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsY))\n            );\n\n            posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n            posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n\n            if(xPixelSized && yPixelSized) {\n                var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n                visualCues.attr('d', crossPath);\n            } else if(xPixelSized) {\n                var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) +\n                  'v18 h2 v-18 Z';\n                visualCues.attr('d', vBarPath);\n            } else {\n                var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h18 v2 h-18 Z';\n                visualCues.attr('d', hBarPath);\n            }\n        }\n    }\n\n    function removeVisualCues(shapeLayer) {\n        shapeLayer.selectAll('.visual-cue').remove();\n    }\n\n    function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n        var xref = shapeOptions.xref;\n        var yref = shapeOptions.yref;\n        var xa = Axes.getFromId(gd, xref);\n        var ya = Axes.getFromId(gd, yref);\n\n        var clipAxes = '';\n        if(xref !== 'paper' && !xa.autorange) clipAxes += xref;\n        if(yref !== 'paper' && !ya.autorange) clipAxes += yref;\n\n        Drawing.setClipUrl(\n            shapePath,\n            clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null,\n            gd\n        );\n    }\n}\n\nfunction drawLabel(gd, index, options, shapeGroup) {\n    // Remove existing label\n    shapeGroup.selectAll('.shape-label').remove();\n\n    // If no label, return\n    if(!options.label.text) return;\n\n    var labelGroupAttrs = {\n        'data-index': index,\n    };\n    var text = options.label.text;\n    var font = options.label.font;\n\n    var labelTextAttrs = {\n        'data-notex': 1\n    };\n\n    var labelGroup = shapeGroup.append('g')\n        .attr(labelGroupAttrs)\n        .classed('shape-label', true);\n    var labelText = labelGroup.append('text')\n        .attr(labelTextAttrs)\n        .classed('shape-label-text', true)\n        .text(text);\n\n    // Get x and y bounds of shape\n    var shapex0, shapex1, shapey0, shapey1;\n    if(options.path) {\n        // If shape is defined as a path, get the\n        // min and max bounds across all polygons in path\n        var d = getPathString(gd, options);\n        var polygons = readPaths(d, gd);\n        shapex0 = Infinity;\n        shapey0 = Infinity;\n        shapex1 = -Infinity;\n        shapey1 = -Infinity;\n        for(var i = 0; i < polygons.length; i++) {\n            for(var j = 0; j < polygons[i].length; j++) {\n                var p = polygons[i][j];\n                for(var k = 1; k < p.length; k += 2) {\n                    var _x = p[k];\n                    var _y = p[k + 1];\n\n                    shapex0 = Math.min(shapex0, _x);\n                    shapex1 = Math.max(shapex1, _x);\n                    shapey0 = Math.min(shapey0, _y);\n                    shapey1 = Math.max(shapey1, _y);\n                }\n            }\n        }\n    } else {\n        // Otherwise, we use the x and y bounds defined in the shape options\n        // and convert them to pixel coordinates\n        // Setup conversion functions\n        var xa = Axes.getFromId(gd, options.xref);\n        var xRefType = Axes.getRefType(options.xref);\n        var ya = Axes.getFromId(gd, options.yref);\n        var yRefType = Axes.getRefType(options.yref);\n        var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);\n        var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);\n        shapex0 = x2p(options.x0);\n        shapex1 = x2p(options.x1);\n        shapey0 = y2p(options.y0);\n        shapey1 = y2p(options.y1);\n    }\n\n    // Handle `auto` angle\n    var textangle = options.label.textangle;\n    if(textangle === 'auto') {\n        if(options.type === 'line') {\n            // Auto angle for line is same angle as line\n            textangle = calcTextAngle(shapex0, shapey0, shapex1, shapey1);\n        } else {\n            // Auto angle for all other shapes is 0\n            textangle = 0;\n        }\n    }\n\n    // Do an initial render so we can get the text bounding box height\n    labelText.call(function(s) {\n        s.call(Drawing.font, font).attr({});\n        svgTextUtils.convertToTspans(s, gd);\n        return s;\n    });\n    var textBB = Drawing.bBox(labelText.node());\n\n    // Calculate correct (x,y) for text\n    // We also determine true xanchor since xanchor depends on position when set to 'auto'\n    var textPos = calcTextPosition(shapex0, shapey0, shapex1, shapey1, options, textangle, textBB);\n    var textx = textPos.textx;\n    var texty = textPos.texty;\n    var xanchor = textPos.xanchor;\n\n    // Update (x,y) position, xanchor, and angle\n    labelText.attr({\n        'text-anchor': {\n            left: 'start',\n            center: 'middle',\n            right: 'end'\n        }[xanchor],\n        y: texty,\n        x: textx,\n        transform: 'rotate(' + textangle + ',' + textx + ',' + texty + ')'\n    }).call(svgTextUtils.positionText, textx, texty);\n}\n\nfunction calcTextAngle(shapex0, shapey0, shapex1, shapey1) {\n    var dy, dx;\n    dx = Math.abs(shapex1 - shapex0);\n    if(shapex1 >= shapex0) {\n        dy = shapey0 - shapey1;\n    } else {\n        dy = shapey1 - shapey0;\n    }\n    return -180 / Math.PI * Math.atan2(dy, dx);\n}\n\nfunction calcTextPosition(shapex0, shapey0, shapex1, shapey1, shapeOptions, actualTextAngle, textBB) {\n    var textPosition = shapeOptions.label.textposition;\n    var textAngle = shapeOptions.label.textangle;\n    var textPadding = shapeOptions.label.padding;\n    var shapeType = shapeOptions.type;\n    var textAngleRad = Math.PI / 180 * actualTextAngle;\n    var sinA = Math.sin(textAngleRad);\n    var cosA = Math.cos(textAngleRad);\n    var xanchor = shapeOptions.label.xanchor;\n    var yanchor = shapeOptions.label.yanchor;\n\n    var textx, texty, paddingX, paddingY;\n\n    // Text position functions differently for lines vs. other shapes\n    if(shapeType === 'line') {\n        // Set base position for start vs. center vs. end of line (default is 'center')\n        if(textPosition === 'start') {\n            textx = shapex0;\n            texty = shapey0;\n        } else if(textPosition === 'end') {\n            textx = shapex1;\n            texty = shapey1;\n        } else { // Default: center\n            textx = (shapex0 + shapex1) / 2;\n            texty = (shapey0 + shapey1) / 2;\n        }\n\n        // Set xanchor if xanchor is 'auto'\n        if(xanchor === 'auto') {\n            if(textPosition === 'start') {\n                if(textAngle === 'auto') {\n                    if(shapex1 > shapex0) xanchor = 'left';\n                    else if(shapex1 < shapex0) xanchor = 'right';\n                    else xanchor = 'center';\n                } else {\n                    if(shapex1 > shapex0) xanchor = 'right';\n                    else if(shapex1 < shapex0) xanchor = 'left';\n                    else xanchor = 'center';\n                }\n            } else if(textPosition === 'end') {\n                if(textAngle === 'auto') {\n                    if(shapex1 > shapex0) xanchor = 'right';\n                    else if(shapex1 < shapex0) xanchor = 'left';\n                    else xanchor = 'center';\n                } else {\n                    if(shapex1 > shapex0) xanchor = 'left';\n                    else if(shapex1 < shapex0) xanchor = 'right';\n                    else xanchor = 'center';\n                }\n            } else {\n                xanchor = 'center';\n            }\n        }\n\n        // Special case for padding when angle is 'auto' for lines\n        // Padding should be treated as an orthogonal offset in this case\n        // Otherwise, padding is just a simple x and y offset\n        var paddingConstantsX = { left: 1, center: 0, right: -1 };\n        var paddingConstantsY = { bottom: -1, middle: 0, top: 1 };\n        if(textAngle === 'auto') {\n            // Set direction to apply padding (based on `yanchor` only)\n            var paddingDirection = paddingConstantsY[yanchor];\n            paddingX = -textPadding * sinA * paddingDirection;\n            paddingY = textPadding * cosA * paddingDirection;\n        } else {\n            // Set direction to apply padding (based on `xanchor` and `yanchor`)\n            var paddingDirectionX = paddingConstantsX[xanchor];\n            var paddingDirectionY = paddingConstantsY[yanchor];\n            paddingX = textPadding * paddingDirectionX;\n            paddingY = textPadding * paddingDirectionY;\n        }\n        textx = textx + paddingX;\n        texty = texty + paddingY;\n    } else {\n        // Text position for shapes that are not lines\n        // calc horizontal position\n        // Horizontal needs a little extra padding to look balanced\n        paddingX = textPadding + 3;\n        if(textPosition.indexOf('right') !== -1) {\n            textx = Math.max(shapex0, shapex1) - paddingX;\n            if(xanchor === 'auto') xanchor = 'right';\n        } else if(textPosition.indexOf('left') !== -1) {\n            textx = Math.min(shapex0, shapex1) + paddingX;\n            if(xanchor === 'auto') xanchor = 'left';\n        } else { // Default: center\n            textx = (shapex0 + shapex1) / 2;\n            if(xanchor === 'auto') xanchor = 'center';\n        }\n\n        // calc vertical position\n        if(textPosition.indexOf('top') !== -1) {\n            texty = Math.min(shapey0, shapey1);\n        } else if(textPosition.indexOf('bottom') !== -1) {\n            texty = Math.max(shapey0, shapey1);\n        } else {\n            texty = (shapey0 + shapey1) / 2;\n        }\n        // Apply padding\n        paddingY = textPadding;\n        if(yanchor === 'bottom') {\n            texty = texty - paddingY;\n        } else if(yanchor === 'top') {\n            texty = texty + paddingY;\n        }\n    }\n\n    // Shift vertical (& horizontal) position according to `yanchor`\n    var shiftFraction = FROM_TL[yanchor];\n    // Adjust so that text is anchored at top of first line rather than at baseline of first line\n    var baselineAdjust = shapeOptions.label.font.size;\n    var textHeight = textBB.height;\n    var xshift = (textHeight * shiftFraction - baselineAdjust) * sinA;\n    var yshift = -(textHeight * shiftFraction - baselineAdjust) * cosA;\n\n    return { textx: textx + xshift, texty: texty + yshift, xanchor: xanchor };\n}\n\nfunction movePath(pathIn, moveX, moveY) {\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0;\n        var segmentType = segment.charAt(0);\n        var xParams = constants.paramIsX[segmentType];\n        var yParams = constants.paramIsY[segmentType];\n        var nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(paramNumber >= nParams) return param;\n\n            if(xParams[paramNumber]) param = moveX(param);\n            else if(yParams[paramNumber]) param = moveY(param);\n\n            paramNumber++;\n\n            return param;\n        });\n\n        return segmentType + paramString;\n    });\n}\n\nfunction activateShape(gd, path) {\n    if(!couldHaveActiveShape(gd)) return;\n\n    var element = path.node();\n    var id = +element.getAttribute('data-index');\n    if(id >= 0) {\n        // deactivate if already active\n        if(id === gd._fullLayout._activeShapeIndex) {\n            deactivateShape(gd);\n            return;\n        }\n\n        gd._fullLayout._activeShapeIndex = id;\n        gd._fullLayout._deactivateShape = deactivateShape;\n        draw(gd);\n    }\n}\n\nfunction deactivateShape(gd) {\n    if(!couldHaveActiveShape(gd)) return;\n\n    var id = gd._fullLayout._activeShapeIndex;\n    if(id >= 0) {\n        clearOutlineControllers(gd);\n        delete gd._fullLayout._activeShapeIndex;\n        draw(gd);\n    }\n}\n\nfunction eraseActiveShape(gd) {\n    if(!couldHaveActiveShape(gd)) return;\n\n    clearOutlineControllers(gd);\n\n    var id = gd._fullLayout._activeShapeIndex;\n    var shapes = (gd.layout || {}).shapes || [];\n    if(id < shapes.length) {\n        var list = [];\n        for(var q = 0; q < shapes.length; q++) {\n            if(q !== id) {\n                list.push(shapes[q]);\n            }\n        }\n\n        delete gd._fullLayout._activeShapeIndex;\n\n        Registry.call('_guiRelayout', gd, {\n            shapes: list\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}