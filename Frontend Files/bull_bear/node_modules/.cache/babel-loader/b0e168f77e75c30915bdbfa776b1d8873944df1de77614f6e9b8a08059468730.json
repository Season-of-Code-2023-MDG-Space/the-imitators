{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar Template = require('../../plot_api/plot_template');\nvar handleSubplotDefaults = require('../subplot_defaults');\nvar getSubplotData = require('../get_data').getSubplotData;\nvar handleTickValueDefaults = require('../cartesian/tick_value_defaults');\nvar handleTickMarkDefaults = require('../cartesian/tick_mark_defaults');\nvar handleTickLabelDefaults = require('../cartesian/tick_label_defaults');\nvar handlePrefixSuffixDefaults = require('../cartesian/prefix_suffix_defaults');\nvar handleCategoryOrderDefaults = require('../cartesian/category_order_defaults');\nvar handleLineGridDefaults = require('../cartesian/line_grid_defaults');\nvar autoType = require('../cartesian/axis_autotype');\nvar layoutAttributes = require('./layout_attributes');\nvar setConvert = require('./set_convert');\nvar constants = require('./constants');\nvar axisNames = constants.axisNames;\nfunction handleDefaults(contIn, contOut, coerce, opts) {\n  var bgColor = coerce('bgcolor');\n  opts.bgColor = Color.combine(bgColor, opts.paper_bgcolor);\n  var sector = coerce('sector');\n  coerce('hole');\n\n  // could optimize, subplotData is not always needed!\n  var subplotData = getSubplotData(opts.fullData, constants.name, opts.id);\n  var layoutOut = opts.layoutOut;\n  var axName;\n  function coerceAxis(attr, dflt) {\n    return coerce(axName + '.' + attr, dflt);\n  }\n  for (var i = 0; i < axisNames.length; i++) {\n    axName = axisNames[i];\n    if (!Lib.isPlainObject(contIn[axName])) {\n      contIn[axName] = {};\n    }\n    var axIn = contIn[axName];\n    var axOut = Template.newContainer(contOut, axName);\n    axOut._id = axOut._name = axName;\n    axOut._attr = opts.id + '.' + axName;\n    axOut._traceIndices = subplotData.map(function (t) {\n      return t._expandedIndex;\n    });\n    var dataAttr = constants.axisName2dataArray[axName];\n    var axType = handleAxisTypeDefaults(axIn, axOut, coerceAxis, subplotData, dataAttr, opts);\n    handleCategoryOrderDefaults(axIn, axOut, coerceAxis, {\n      axData: subplotData,\n      dataAttr: dataAttr\n    });\n    var visible = coerceAxis('visible');\n    setConvert(axOut, contOut, layoutOut);\n    coerceAxis('uirevision', contOut.uirevision);\n\n    // We don't want to make downstream code call ax.setScale,\n    // as both radial and angular axes don't have a set domain.\n    // Furthermore, angular axes don't have a set range.\n    //\n    // Mocked domains and ranges are set by the polar subplot instances,\n    // but Axes.findExtremes uses the sign of _m to determine which padding value\n    // to use.\n    //\n    // By setting, _m to 1 here, we make Axes.findExtremes think that\n    // range[1] > range[0], and vice-versa for `autorange: 'reversed'` below.\n    axOut._m = 1;\n    switch (axName) {\n      case 'radialaxis':\n        var autoRange = coerceAxis('autorange', !axOut.isValidRange(axIn.range));\n        axIn.autorange = autoRange;\n        if (autoRange && (axType === 'linear' || axType === '-')) coerceAxis('rangemode');\n        if (autoRange === 'reversed') axOut._m = -1;\n        coerceAxis('range');\n        axOut.cleanRange('range', {\n          dfltRange: [0, 1]\n        });\n        break;\n      case 'angularaxis':\n        // We do not support 'true' date angular axes yet,\n        // users can still plot dates on angular axes by setting\n        // `angularaxis.type: 'category'`.\n        //\n        // Here, if a date angular axes is detected, we make\n        // all its corresponding traces invisible, so that\n        // when we do add support for data angular axes, the new\n        // behavior won't conflict with existing behavior\n        if (axType === 'date') {\n          Lib.log('Polar plots do not support date angular axes yet.');\n          for (var j = 0; j < subplotData.length; j++) {\n            subplotData[j].visible = false;\n          }\n\n          // turn this into a 'dummy' linear axis so that\n          // the subplot still renders ok\n          axType = axIn.type = axOut.type = 'linear';\n        }\n        if (axType === 'linear') {\n          coerceAxis('thetaunit');\n        } else {\n          coerceAxis('period');\n        }\n        var direction = coerceAxis('direction');\n        coerceAxis('rotation', {\n          counterclockwise: 0,\n          clockwise: 90\n        }[direction]);\n        break;\n    }\n    handlePrefixSuffixDefaults(axIn, axOut, coerceAxis, axOut.type, {\n      tickSuffixDflt: axOut.thetaunit === 'degrees' ? 'Â°' : undefined\n    });\n    if (visible) {\n      var dfltColor;\n      var dfltFontColor;\n      var dfltFontSize;\n      var dfltFontFamily;\n      var font = opts.font || {};\n      dfltColor = coerceAxis('color');\n      dfltFontColor = dfltColor === axIn.color ? dfltColor : font.color;\n      dfltFontSize = font.size;\n      dfltFontFamily = font.family;\n      handleTickValueDefaults(axIn, axOut, coerceAxis, axOut.type);\n      handleTickLabelDefaults(axIn, axOut, coerceAxis, axOut.type, {\n        font: {\n          color: dfltFontColor,\n          size: dfltFontSize,\n          family: dfltFontFamily\n        }\n      });\n      handleTickMarkDefaults(axIn, axOut, coerceAxis, {\n        outerTicks: true\n      });\n      handleLineGridDefaults(axIn, axOut, coerceAxis, {\n        dfltColor: dfltColor,\n        bgColor: opts.bgColor,\n        // default grid color is darker here (60%, vs cartesian default ~91%)\n        // because the grid is not square so the eye needs heavier cues to follow\n        blend: 60,\n        showLine: true,\n        showGrid: true,\n        noZeroLine: true,\n        attributes: layoutAttributes[axName]\n      });\n      coerceAxis('layer');\n      if (axName === 'radialaxis') {\n        coerceAxis('side');\n        coerceAxis('angle', sector[0]);\n        coerceAxis('title.text');\n        Lib.coerceFont(coerceAxis, 'title.font', {\n          color: dfltFontColor,\n          size: Lib.bigFont(dfltFontSize),\n          family: dfltFontFamily\n        });\n      }\n    }\n    if (axType !== 'category') coerceAxis('hoverformat');\n    axOut._input = axIn;\n  }\n  if (contOut.angularaxis.type === 'category') {\n    coerce('gridshape');\n  }\n}\nfunction handleAxisTypeDefaults(axIn, axOut, coerce, subplotData, dataAttr, options) {\n  var autotypenumbers = coerce('autotypenumbers', options.autotypenumbersDflt);\n  var axType = coerce('type');\n  if (axType === '-') {\n    var trace;\n    for (var i = 0; i < subplotData.length; i++) {\n      if (subplotData[i].visible) {\n        trace = subplotData[i];\n        break;\n      }\n    }\n    if (trace && trace[dataAttr]) {\n      axOut.type = autoType(trace[dataAttr], 'gregorian', {\n        noMultiCategory: true,\n        autotypenumbers: autotypenumbers\n      });\n    }\n    if (axOut.type === '-') {\n      axOut.type = 'linear';\n    } else {\n      // copy autoType back to input axis\n      // note that if this object didn't exist\n      // in the input layout, we have to put it in\n      // this happens in the main supplyDefaults function\n      axIn.type = axOut.type;\n    }\n  }\n  return axOut.type;\n}\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n    type: constants.name,\n    attributes: layoutAttributes,\n    handleDefaults: handleDefaults,\n    font: layoutOut.font,\n    autotypenumbersDflt: layoutOut.autotypenumbers,\n    paper_bgcolor: layoutOut.paper_bgcolor,\n    fullData: fullData,\n    layoutOut: layoutOut\n  });\n};","map":{"version":3,"names":["Lib","require","Color","Template","handleSubplotDefaults","getSubplotData","handleTickValueDefaults","handleTickMarkDefaults","handleTickLabelDefaults","handlePrefixSuffixDefaults","handleCategoryOrderDefaults","handleLineGridDefaults","autoType","layoutAttributes","setConvert","constants","axisNames","handleDefaults","contIn","contOut","coerce","opts","bgColor","combine","paper_bgcolor","sector","subplotData","fullData","name","id","layoutOut","axName","coerceAxis","attr","dflt","i","length","isPlainObject","axIn","axOut","newContainer","_id","_name","_attr","_traceIndices","map","t","_expandedIndex","dataAttr","axisName2dataArray","axType","handleAxisTypeDefaults","axData","visible","uirevision","_m","autoRange","isValidRange","range","autorange","cleanRange","dfltRange","log","j","type","direction","counterclockwise","clockwise","tickSuffixDflt","thetaunit","undefined","dfltColor","dfltFontColor","dfltFontSize","dfltFontFamily","font","color","size","family","outerTicks","blend","showLine","showGrid","noZeroLine","attributes","coerceFont","bigFont","_input","angularaxis","options","autotypenumbers","autotypenumbersDflt","trace","noMultiCategory","module","exports","supplyLayoutDefaults","layoutIn"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/plots/polar/layout_defaults.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar Template = require('../../plot_api/plot_template');\n\nvar handleSubplotDefaults = require('../subplot_defaults');\nvar getSubplotData = require('../get_data').getSubplotData;\n\nvar handleTickValueDefaults = require('../cartesian/tick_value_defaults');\nvar handleTickMarkDefaults = require('../cartesian/tick_mark_defaults');\nvar handleTickLabelDefaults = require('../cartesian/tick_label_defaults');\nvar handlePrefixSuffixDefaults = require('../cartesian/prefix_suffix_defaults');\nvar handleCategoryOrderDefaults = require('../cartesian/category_order_defaults');\nvar handleLineGridDefaults = require('../cartesian/line_grid_defaults');\nvar autoType = require('../cartesian/axis_autotype');\n\nvar layoutAttributes = require('./layout_attributes');\nvar setConvert = require('./set_convert');\nvar constants = require('./constants');\nvar axisNames = constants.axisNames;\n\nfunction handleDefaults(contIn, contOut, coerce, opts) {\n    var bgColor = coerce('bgcolor');\n    opts.bgColor = Color.combine(bgColor, opts.paper_bgcolor);\n\n    var sector = coerce('sector');\n    coerce('hole');\n\n    // could optimize, subplotData is not always needed!\n    var subplotData = getSubplotData(opts.fullData, constants.name, opts.id);\n    var layoutOut = opts.layoutOut;\n    var axName;\n\n    function coerceAxis(attr, dflt) {\n        return coerce(axName + '.' + attr, dflt);\n    }\n\n    for(var i = 0; i < axisNames.length; i++) {\n        axName = axisNames[i];\n\n        if(!Lib.isPlainObject(contIn[axName])) {\n            contIn[axName] = {};\n        }\n\n        var axIn = contIn[axName];\n        var axOut = Template.newContainer(contOut, axName);\n        axOut._id = axOut._name = axName;\n        axOut._attr = opts.id + '.' + axName;\n        axOut._traceIndices = subplotData.map(function(t) { return t._expandedIndex; });\n\n        var dataAttr = constants.axisName2dataArray[axName];\n        var axType = handleAxisTypeDefaults(axIn, axOut, coerceAxis, subplotData, dataAttr, opts);\n\n        handleCategoryOrderDefaults(axIn, axOut, coerceAxis, {\n            axData: subplotData,\n            dataAttr: dataAttr\n        });\n\n        var visible = coerceAxis('visible');\n        setConvert(axOut, contOut, layoutOut);\n\n        coerceAxis('uirevision', contOut.uirevision);\n\n        // We don't want to make downstream code call ax.setScale,\n        // as both radial and angular axes don't have a set domain.\n        // Furthermore, angular axes don't have a set range.\n        //\n        // Mocked domains and ranges are set by the polar subplot instances,\n        // but Axes.findExtremes uses the sign of _m to determine which padding value\n        // to use.\n        //\n        // By setting, _m to 1 here, we make Axes.findExtremes think that\n        // range[1] > range[0], and vice-versa for `autorange: 'reversed'` below.\n        axOut._m = 1;\n\n        switch(axName) {\n            case 'radialaxis':\n                var autoRange = coerceAxis('autorange', !axOut.isValidRange(axIn.range));\n                axIn.autorange = autoRange;\n                if(autoRange && (axType === 'linear' || axType === '-')) coerceAxis('rangemode');\n                if(autoRange === 'reversed') axOut._m = -1;\n\n                coerceAxis('range');\n                axOut.cleanRange('range', {dfltRange: [0, 1]});\n                break;\n\n            case 'angularaxis':\n                // We do not support 'true' date angular axes yet,\n                // users can still plot dates on angular axes by setting\n                // `angularaxis.type: 'category'`.\n                //\n                // Here, if a date angular axes is detected, we make\n                // all its corresponding traces invisible, so that\n                // when we do add support for data angular axes, the new\n                // behavior won't conflict with existing behavior\n                if(axType === 'date') {\n                    Lib.log('Polar plots do not support date angular axes yet.');\n\n                    for(var j = 0; j < subplotData.length; j++) {\n                        subplotData[j].visible = false;\n                    }\n\n                    // turn this into a 'dummy' linear axis so that\n                    // the subplot still renders ok\n                    axType = axIn.type = axOut.type = 'linear';\n                }\n\n                if(axType === 'linear') {\n                    coerceAxis('thetaunit');\n                } else {\n                    coerceAxis('period');\n                }\n\n                var direction = coerceAxis('direction');\n                coerceAxis('rotation', {counterclockwise: 0, clockwise: 90}[direction]);\n                break;\n        }\n\n        handlePrefixSuffixDefaults(axIn, axOut, coerceAxis, axOut.type, {\n            tickSuffixDflt: axOut.thetaunit === 'degrees' ? 'Â°' : undefined\n        });\n\n        if(visible) {\n            var dfltColor;\n            var dfltFontColor;\n            var dfltFontSize;\n            var dfltFontFamily;\n            var font = opts.font || {};\n\n            dfltColor = coerceAxis('color');\n            dfltFontColor = (dfltColor === axIn.color) ? dfltColor : font.color;\n            dfltFontSize = font.size;\n            dfltFontFamily = font.family;\n\n            handleTickValueDefaults(axIn, axOut, coerceAxis, axOut.type);\n            handleTickLabelDefaults(axIn, axOut, coerceAxis, axOut.type, {\n                font: {\n                    color: dfltFontColor,\n                    size: dfltFontSize,\n                    family: dfltFontFamily\n                }\n            });\n\n            handleTickMarkDefaults(axIn, axOut, coerceAxis, {outerTicks: true});\n\n            handleLineGridDefaults(axIn, axOut, coerceAxis, {\n                dfltColor: dfltColor,\n                bgColor: opts.bgColor,\n                // default grid color is darker here (60%, vs cartesian default ~91%)\n                // because the grid is not square so the eye needs heavier cues to follow\n                blend: 60,\n                showLine: true,\n                showGrid: true,\n                noZeroLine: true,\n                attributes: layoutAttributes[axName]\n            });\n\n            coerceAxis('layer');\n\n            if(axName === 'radialaxis') {\n                coerceAxis('side');\n                coerceAxis('angle', sector[0]);\n\n                coerceAxis('title.text');\n                Lib.coerceFont(coerceAxis, 'title.font', {\n                    color: dfltFontColor,\n                    size: Lib.bigFont(dfltFontSize),\n                    family: dfltFontFamily\n                });\n            }\n        }\n\n        if(axType !== 'category') coerceAxis('hoverformat');\n\n        axOut._input = axIn;\n    }\n\n    if(contOut.angularaxis.type === 'category') {\n        coerce('gridshape');\n    }\n}\n\nfunction handleAxisTypeDefaults(axIn, axOut, coerce, subplotData, dataAttr, options) {\n    var autotypenumbers = coerce('autotypenumbers', options.autotypenumbersDflt);\n    var axType = coerce('type');\n\n    if(axType === '-') {\n        var trace;\n\n        for(var i = 0; i < subplotData.length; i++) {\n            if(subplotData[i].visible) {\n                trace = subplotData[i];\n                break;\n            }\n        }\n\n        if(trace && trace[dataAttr]) {\n            axOut.type = autoType(trace[dataAttr], 'gregorian', {\n                noMultiCategory: true,\n                autotypenumbers: autotypenumbers\n            });\n        }\n\n        if(axOut.type === '-') {\n            axOut.type = 'linear';\n        } else {\n            // copy autoType back to input axis\n            // note that if this object didn't exist\n            // in the input layout, we have to put it in\n            // this happens in the main supplyDefaults function\n            axIn.type = axOut.type;\n        }\n    }\n\n    return axOut.type;\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n        type: constants.name,\n        attributes: layoutAttributes,\n        handleDefaults: handleDefaults,\n        font: layoutOut.font,\n        autotypenumbersDflt: layoutOut.autotypenumbers,\n        paper_bgcolor: layoutOut.paper_bgcolor,\n        fullData: fullData,\n        layoutOut: layoutOut\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}