{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar m4FromQuat = require('gl-mat4/fromQuat');\nvar Registry = require('../registry');\nvar Lib = require('../lib');\nvar Plots = require('../plots/plots');\nvar AxisIds = require('../plots/cartesian/axis_ids');\nvar Color = require('../components/color');\nvar cleanId = AxisIds.cleanId;\nvar getFromTrace = AxisIds.getFromTrace;\nvar traceIs = Registry.traceIs;\n\n// clear the promise queue if one of them got rejected\nexports.clearPromiseQueue = function (gd) {\n  if (Array.isArray(gd._promises) && gd._promises.length > 0) {\n    Lib.log('Clearing previous rejected promises from queue.');\n  }\n  gd._promises = [];\n};\n\n// make a few changes to the layout right away\n// before it gets used for anything\n// backward compatibility and cleanup of nonstandard options\nexports.cleanLayout = function (layout) {\n  var i, j;\n  if (!layout) layout = {};\n\n  // cannot have (x|y)axis1, numbering goes axis, axis2, axis3...\n  if (layout.xaxis1) {\n    if (!layout.xaxis) layout.xaxis = layout.xaxis1;\n    delete layout.xaxis1;\n  }\n  if (layout.yaxis1) {\n    if (!layout.yaxis) layout.yaxis = layout.yaxis1;\n    delete layout.yaxis1;\n  }\n  if (layout.scene1) {\n    if (!layout.scene) layout.scene = layout.scene1;\n    delete layout.scene1;\n  }\n  var axisAttrRegex = (Plots.subplotsRegistry.cartesian || {}).attrRegex;\n  var polarAttrRegex = (Plots.subplotsRegistry.polar || {}).attrRegex;\n  var ternaryAttrRegex = (Plots.subplotsRegistry.ternary || {}).attrRegex;\n  var sceneAttrRegex = (Plots.subplotsRegistry.gl3d || {}).attrRegex;\n  var keys = Object.keys(layout);\n  for (i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (axisAttrRegex && axisAttrRegex.test(key)) {\n      // modifications to cartesian axes\n\n      var ax = layout[key];\n      if (ax.anchor && ax.anchor !== 'free') {\n        ax.anchor = cleanId(ax.anchor);\n      }\n      if (ax.overlaying) ax.overlaying = cleanId(ax.overlaying);\n\n      // old method of axis type - isdate and islog (before category existed)\n      if (!ax.type) {\n        if (ax.isdate) ax.type = 'date';else if (ax.islog) ax.type = 'log';else if (ax.isdate === false && ax.islog === false) ax.type = 'linear';\n      }\n      if (ax.autorange === 'withzero' || ax.autorange === 'tozero') {\n        ax.autorange = true;\n        ax.rangemode = 'tozero';\n      }\n      delete ax.islog;\n      delete ax.isdate;\n      delete ax.categories; // replaced by _categories\n\n      // prune empty domain arrays made before the new nestedProperty\n      if (emptyContainer(ax, 'domain')) delete ax.domain;\n\n      // autotick -> tickmode\n      if (ax.autotick !== undefined) {\n        if (ax.tickmode === undefined) {\n          ax.tickmode = ax.autotick ? 'auto' : 'linear';\n        }\n        delete ax.autotick;\n      }\n      cleanTitle(ax);\n    } else if (polarAttrRegex && polarAttrRegex.test(key)) {\n      // modifications for polar\n\n      var polar = layout[key];\n      cleanTitle(polar.radialaxis);\n    } else if (ternaryAttrRegex && ternaryAttrRegex.test(key)) {\n      // modifications for ternary\n\n      var ternary = layout[key];\n      cleanTitle(ternary.aaxis);\n      cleanTitle(ternary.baxis);\n      cleanTitle(ternary.caxis);\n    } else if (sceneAttrRegex && sceneAttrRegex.test(key)) {\n      // modifications for 3D scenes\n\n      var scene = layout[key];\n\n      // clean old Camera coords\n      var cameraposition = scene.cameraposition;\n      if (Array.isArray(cameraposition) && cameraposition[0].length === 4) {\n        var rotation = cameraposition[0];\n        var center = cameraposition[1];\n        var radius = cameraposition[2];\n        var mat = m4FromQuat([], rotation);\n        var eye = [];\n        for (j = 0; j < 3; ++j) {\n          eye[j] = center[j] + radius * mat[2 + 4 * j];\n        }\n        scene.camera = {\n          eye: {\n            x: eye[0],\n            y: eye[1],\n            z: eye[2]\n          },\n          center: {\n            x: center[0],\n            y: center[1],\n            z: center[2]\n          },\n          up: {\n            x: 0,\n            y: 0,\n            z: 1\n          } // we just ignore calculating camera z up in this case\n        };\n\n        delete scene.cameraposition;\n      }\n\n      // clean axis titles\n      cleanTitle(scene.xaxis);\n      cleanTitle(scene.yaxis);\n      cleanTitle(scene.zaxis);\n    }\n  }\n  var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;\n  for (i = 0; i < annotationsLen; i++) {\n    var ann = layout.annotations[i];\n    if (!Lib.isPlainObject(ann)) continue;\n    if (ann.ref) {\n      if (ann.ref === 'paper') {\n        ann.xref = 'paper';\n        ann.yref = 'paper';\n      } else if (ann.ref === 'data') {\n        ann.xref = 'x';\n        ann.yref = 'y';\n      }\n      delete ann.ref;\n    }\n    cleanAxRef(ann, 'xref');\n    cleanAxRef(ann, 'yref');\n  }\n  var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;\n  for (i = 0; i < shapesLen; i++) {\n    var shape = layout.shapes[i];\n    if (!Lib.isPlainObject(shape)) continue;\n    cleanAxRef(shape, 'xref');\n    cleanAxRef(shape, 'yref');\n  }\n  var imagesLen = Array.isArray(layout.images) ? layout.images.length : 0;\n  for (i = 0; i < imagesLen; i++) {\n    var image = layout.images[i];\n    if (!Lib.isPlainObject(image)) continue;\n    cleanAxRef(image, 'xref');\n    cleanAxRef(image, 'yref');\n  }\n  var legend = layout.legend;\n  if (legend) {\n    // check for old-style legend positioning (x or y is +/- 100)\n    if (legend.x > 3) {\n      legend.x = 1.02;\n      legend.xanchor = 'left';\n    } else if (legend.x < -2) {\n      legend.x = -0.02;\n      legend.xanchor = 'right';\n    }\n    if (legend.y > 3) {\n      legend.y = 1.02;\n      legend.yanchor = 'bottom';\n    } else if (legend.y < -2) {\n      legend.y = -0.02;\n      legend.yanchor = 'top';\n    }\n  }\n\n  // clean plot title\n  cleanTitle(layout);\n\n  /*\n   * Moved from rotate -> orbit for dragmode\n   */\n  if (layout.dragmode === 'rotate') layout.dragmode = 'orbit';\n\n  // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n  // supported, but new tinycolor does not because they're not valid css\n  Color.clean(layout);\n\n  // clean the layout container in layout.template\n  if (layout.template && layout.template.layout) {\n    exports.cleanLayout(layout.template.layout);\n  }\n  return layout;\n};\nfunction cleanAxRef(container, attr) {\n  var valIn = container[attr];\n  var axLetter = attr.charAt(0);\n  if (valIn && valIn !== 'paper') {\n    container[attr] = cleanId(valIn, axLetter, true);\n  }\n}\n\n/**\n * Cleans up old title attribute structure (flat) in favor of the new one (nested).\n *\n * @param {Object} titleContainer - an object potentially including deprecated title attributes\n */\nfunction cleanTitle(titleContainer) {\n  if (titleContainer) {\n    // title -> title.text\n    // (although title used to be a string attribute,\n    // numbers are accepted as well)\n    if (typeof titleContainer.title === 'string' || typeof titleContainer.title === 'number') {\n      titleContainer.title = {\n        text: titleContainer.title\n      };\n    }\n    rewireAttr('titlefont', 'font');\n    rewireAttr('titleposition', 'position');\n    rewireAttr('titleside', 'side');\n    rewireAttr('titleoffset', 'offset');\n  }\n  function rewireAttr(oldAttrName, newAttrName) {\n    var oldAttrSet = titleContainer[oldAttrName];\n    var newAttrSet = titleContainer.title && titleContainer.title[newAttrName];\n    if (oldAttrSet && !newAttrSet) {\n      // Ensure title object exists\n      if (!titleContainer.title) {\n        titleContainer.title = {};\n      }\n      titleContainer.title[newAttrName] = titleContainer[oldAttrName];\n      delete titleContainer[oldAttrName];\n    }\n  }\n}\n\n/*\n * cleanData: Make a few changes to the data for backward compatibility\n * before it gets used for anything. Modifies the data traces users provide.\n *\n * Important: if you're going to add something here that modifies a data array,\n * update it in place so the new array === the old one.\n */\nexports.cleanData = function (data) {\n  for (var tracei = 0; tracei < data.length; tracei++) {\n    var trace = data[tracei];\n    var i;\n\n    // use xbins to bin data in x, and ybins to bin data in y\n    if (trace.type === 'histogramy' && 'xbins' in trace && !('ybins' in trace)) {\n      trace.ybins = trace.xbins;\n      delete trace.xbins;\n    }\n\n    // error_y.opacity is obsolete - merge into color\n    if (trace.error_y && 'opacity' in trace.error_y) {\n      var dc = Color.defaults;\n      var yeColor = trace.error_y.color || (traceIs(trace, 'bar') ? Color.defaultLine : dc[tracei % dc.length]);\n      trace.error_y.color = Color.addOpacity(Color.rgb(yeColor), Color.opacity(yeColor) * trace.error_y.opacity);\n      delete trace.error_y.opacity;\n    }\n\n    // convert bardir to orientation, and put the data into\n    // the axes it's eventually going to be used with\n    if ('bardir' in trace) {\n      if (trace.bardir === 'h' && (traceIs(trace, 'bar') || trace.type.substr(0, 9) === 'histogram')) {\n        trace.orientation = 'h';\n        exports.swapXYData(trace);\n      }\n      delete trace.bardir;\n    }\n\n    // now we have only one 1D histogram type, and whether\n    // it uses x or y data depends on trace.orientation\n    if (trace.type === 'histogramy') exports.swapXYData(trace);\n    if (trace.type === 'histogramx' || trace.type === 'histogramy') {\n      trace.type = 'histogram';\n    }\n\n    // scl->scale, reversescl->reversescale\n    if ('scl' in trace && !('colorscale' in trace)) {\n      trace.colorscale = trace.scl;\n      delete trace.scl;\n    }\n    if ('reversescl' in trace && !('reversescale' in trace)) {\n      trace.reversescale = trace.reversescl;\n      delete trace.reversescl;\n    }\n\n    // axis ids x1 -> x, y1-> y\n    if (trace.xaxis) trace.xaxis = cleanId(trace.xaxis, 'x');\n    if (trace.yaxis) trace.yaxis = cleanId(trace.yaxis, 'y');\n\n    // scene ids scene1 -> scene\n    if (traceIs(trace, 'gl3d') && trace.scene) {\n      trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);\n    }\n    if (!traceIs(trace, 'pie-like') && !traceIs(trace, 'bar-like')) {\n      if (Array.isArray(trace.textposition)) {\n        for (i = 0; i < trace.textposition.length; i++) {\n          trace.textposition[i] = cleanTextPosition(trace.textposition[i]);\n        }\n      } else if (trace.textposition) {\n        trace.textposition = cleanTextPosition(trace.textposition);\n      }\n    }\n\n    // fix typo in colorscale definition\n    var _module = Registry.getModule(trace);\n    if (_module && _module.colorbar) {\n      var containerName = _module.colorbar.container;\n      var container = containerName ? trace[containerName] : trace;\n      if (container && container.colorscale) {\n        if (container.colorscale === 'YIGnBu') container.colorscale = 'YlGnBu';\n        if (container.colorscale === 'YIOrRd') container.colorscale = 'YlOrRd';\n      }\n    }\n\n    // fix typo in surface 'highlight*' definitions\n    if (trace.type === 'surface' && Lib.isPlainObject(trace.contours)) {\n      var dims = ['x', 'y', 'z'];\n      for (i = 0; i < dims.length; i++) {\n        var opts = trace.contours[dims[i]];\n        if (!Lib.isPlainObject(opts)) continue;\n        if (opts.highlightColor) {\n          opts.highlightcolor = opts.highlightColor;\n          delete opts.highlightColor;\n        }\n        if (opts.highlightWidth) {\n          opts.highlightwidth = opts.highlightWidth;\n          delete opts.highlightWidth;\n        }\n      }\n    }\n\n    // fixes from converting finance from transforms to real trace types\n    if (trace.type === 'candlestick' || trace.type === 'ohlc') {\n      var increasingShowlegend = (trace.increasing || {}).showlegend !== false;\n      var decreasingShowlegend = (trace.decreasing || {}).showlegend !== false;\n      var increasingName = cleanFinanceDir(trace.increasing);\n      var decreasingName = cleanFinanceDir(trace.decreasing);\n\n      // now figure out something smart to do with the separate direction\n      // names we removed\n      if (increasingName !== false && decreasingName !== false) {\n        // both sub-names existed: base name previously had no effect\n        // so ignore it and try to find a shared part of the sub-names\n\n        var newName = commonPrefix(increasingName, decreasingName, increasingShowlegend, decreasingShowlegend);\n        // if no common part, leave whatever name was (or wasn't) there\n        if (newName) trace.name = newName;\n      } else if ((increasingName || decreasingName) && !trace.name) {\n        // one sub-name existed but not the base name - just use the sub-name\n        trace.name = increasingName || decreasingName;\n      }\n    }\n\n    // transforms backward compatibility fixes\n    if (Array.isArray(trace.transforms)) {\n      var transforms = trace.transforms;\n      for (i = 0; i < transforms.length; i++) {\n        var transform = transforms[i];\n        if (!Lib.isPlainObject(transform)) continue;\n        switch (transform.type) {\n          case 'filter':\n            if (transform.filtersrc) {\n              transform.target = transform.filtersrc;\n              delete transform.filtersrc;\n            }\n            if (transform.calendar) {\n              if (!transform.valuecalendar) {\n                transform.valuecalendar = transform.calendar;\n              }\n              delete transform.calendar;\n            }\n            break;\n          case 'groupby':\n            // Name has changed from `style` to `styles`, so use `style` but prefer `styles`:\n            transform.styles = transform.styles || transform.style;\n            if (transform.styles && !Array.isArray(transform.styles)) {\n              var prevStyles = transform.styles;\n              var styleKeys = Object.keys(prevStyles);\n              transform.styles = [];\n              for (var j = 0; j < styleKeys.length; j++) {\n                transform.styles.push({\n                  target: styleKeys[j],\n                  value: prevStyles[styleKeys[j]]\n                });\n              }\n            }\n            break;\n        }\n      }\n    }\n\n    // prune empty containers made before the new nestedProperty\n    if (emptyContainer(trace, 'line')) delete trace.line;\n    if ('marker' in trace) {\n      if (emptyContainer(trace.marker, 'line')) delete trace.marker.line;\n      if (emptyContainer(trace, 'marker')) delete trace.marker;\n    }\n\n    // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n    // supported, but new tinycolor does not because they're not valid css\n    Color.clean(trace);\n\n    // remove obsolete autobin(x|y) attributes, but only if true\n    // if false, this needs to happen in Histogram.calc because it\n    // can be a one-time autobin so we need to know the results before\n    // we can push them back into the trace.\n    if (trace.autobinx) {\n      delete trace.autobinx;\n      delete trace.xbins;\n    }\n    if (trace.autobiny) {\n      delete trace.autobiny;\n      delete trace.ybins;\n    }\n    cleanTitle(trace);\n    if (trace.colorbar) cleanTitle(trace.colorbar);\n    if (trace.marker && trace.marker.colorbar) cleanTitle(trace.marker.colorbar);\n    if (trace.line && trace.line.colorbar) cleanTitle(trace.line.colorbar);\n    if (trace.aaxis) cleanTitle(trace.aaxis);\n    if (trace.baxis) cleanTitle(trace.baxis);\n  }\n};\nfunction cleanFinanceDir(dirContainer) {\n  if (!Lib.isPlainObject(dirContainer)) return false;\n  var dirName = dirContainer.name;\n  delete dirContainer.name;\n  delete dirContainer.showlegend;\n  return (typeof dirName === 'string' || typeof dirName === 'number') && String(dirName);\n}\nfunction commonPrefix(name1, name2, show1, show2) {\n  // if only one is shown in the legend, use that\n  if (show1 && !show2) return name1;\n  if (show2 && !show1) return name2;\n\n  // if both or neither are in the legend, check if one is blank (or whitespace)\n  // and use the other one\n  // note that hover labels can still use the name even if the legend doesn't\n  if (!name1.trim()) return name2;\n  if (!name2.trim()) return name1;\n  var minLen = Math.min(name1.length, name2.length);\n  var i;\n  for (i = 0; i < minLen; i++) {\n    if (name1.charAt(i) !== name2.charAt(i)) break;\n  }\n  var out = name1.substr(0, i);\n  return out.trim();\n}\n\n// textposition - support partial attributes (ie just 'top')\n// and incorrect use of middle / center etc.\nfunction cleanTextPosition(textposition) {\n  var posY = 'middle';\n  var posX = 'center';\n  if (typeof textposition === 'string') {\n    if (textposition.indexOf('top') !== -1) posY = 'top';else if (textposition.indexOf('bottom') !== -1) posY = 'bottom';\n    if (textposition.indexOf('left') !== -1) posX = 'left';else if (textposition.indexOf('right') !== -1) posX = 'right';\n  }\n  return posY + ' ' + posX;\n}\nfunction emptyContainer(outer, innerStr) {\n  return innerStr in outer && typeof outer[innerStr] === 'object' && Object.keys(outer[innerStr]).length === 0;\n}\n\n// swap all the data and data attributes associated with x and y\nexports.swapXYData = function (trace) {\n  var i;\n  Lib.swapAttrs(trace, ['?', '?0', 'd?', '?bins', 'nbins?', 'autobin?', '?src', 'error_?']);\n  if (Array.isArray(trace.z) && Array.isArray(trace.z[0])) {\n    if (trace.transpose) delete trace.transpose;else trace.transpose = true;\n  }\n  if (trace.error_x && trace.error_y) {\n    var errorY = trace.error_y;\n    var copyYstyle = 'copy_ystyle' in errorY ? errorY.copy_ystyle : !(errorY.color || errorY.thickness || errorY.width);\n    Lib.swapAttrs(trace, ['error_?.copy_ystyle']);\n    if (copyYstyle) {\n      Lib.swapAttrs(trace, ['error_?.color', 'error_?.thickness', 'error_?.width']);\n    }\n  }\n  if (typeof trace.hoverinfo === 'string') {\n    var hoverInfoParts = trace.hoverinfo.split('+');\n    for (i = 0; i < hoverInfoParts.length; i++) {\n      if (hoverInfoParts[i] === 'x') hoverInfoParts[i] = 'y';else if (hoverInfoParts[i] === 'y') hoverInfoParts[i] = 'x';\n    }\n    trace.hoverinfo = hoverInfoParts.join('+');\n  }\n};\n\n// coerce traceIndices input to array of trace indices\nexports.coerceTraceIndices = function (gd, traceIndices) {\n  if (isNumeric(traceIndices)) {\n    return [traceIndices];\n  } else if (!Array.isArray(traceIndices) || !traceIndices.length) {\n    return gd.data.map(function (_, i) {\n      return i;\n    });\n  } else if (Array.isArray(traceIndices)) {\n    var traceIndicesOut = [];\n    for (var i = 0; i < traceIndices.length; i++) {\n      if (Lib.isIndex(traceIndices[i], gd.data.length)) {\n        traceIndicesOut.push(traceIndices[i]);\n      } else {\n        Lib.warn('trace index (', traceIndices[i], ') is not a number or is out of bounds');\n      }\n    }\n    return traceIndicesOut;\n  }\n  return traceIndices;\n};\n\n/**\n * Manages logic around array container item creation / deletion / update\n * that nested property alone can't handle.\n *\n * @param {Object} np\n *  nested property of update attribute string about trace or layout object\n * @param {*} newVal\n *  update value passed to restyle / relayout / update\n * @param {Object} undoit\n *  undo hash (N.B. undoit may be mutated here).\n *\n */\nexports.manageArrayContainers = function (np, newVal, undoit) {\n  var obj = np.obj;\n  var parts = np.parts;\n  var pLength = parts.length;\n  var pLast = parts[pLength - 1];\n  var pLastIsNumber = isNumeric(pLast);\n  if (pLastIsNumber && newVal === null) {\n    // delete item\n\n    // Clear item in array container when new value is null\n    var contPath = parts.slice(0, pLength - 1).join('.');\n    var cont = Lib.nestedProperty(obj, contPath).get();\n    cont.splice(pLast, 1);\n\n    // Note that nested property clears null / undefined at end of\n    // array container, but not within them.\n  } else if (pLastIsNumber && np.get() === undefined) {\n    // create item\n\n    // When adding a new item, make sure undo command will remove it\n    if (np.get() === undefined) undoit[np.astr] = null;\n    np.set(newVal);\n  } else {\n    // update item\n\n    // If the last part of attribute string isn't a number,\n    // np.set is all we need.\n    np.set(newVal);\n  }\n};\n\n/*\n * Match the part to strip off to turn an attribute into its parent\n * really it should be either '.some_characters' or '[number]'\n * but we're a little more permissive here and match either\n * '.not_brackets_or_dot' or '[not_brackets_or_dot]'\n */\nvar ATTR_TAIL_RE = /(\\.[^\\[\\]\\.]+|\\[[^\\[\\]\\.]+\\])$/;\nfunction getParent(attr) {\n  var tail = attr.search(ATTR_TAIL_RE);\n  if (tail > 0) return attr.substr(0, tail);\n}\n\n/*\n * hasParent: does an attribute object contain a parent of the given attribute?\n * for example, given 'images[2].x' do we also have 'images' or 'images[2]'?\n *\n * @param {Object} aobj\n *  update object, whose keys are attribute strings and values are their new settings\n * @param {string} attr\n *  the attribute string to test against\n * @returns {Boolean}\n *  is a parent of attr present in aobj?\n */\nexports.hasParent = function (aobj, attr) {\n  var attrParent = getParent(attr);\n  while (attrParent) {\n    if (attrParent in aobj) return true;\n    attrParent = getParent(attrParent);\n  }\n  return false;\n};\n\n/**\n * Empty out types for all axes containing these traces so we auto-set them again\n *\n * @param {object} gd\n * @param {[integer]} traces: trace indices to search for axes to clear the types of\n * @param {object} layoutUpdate: any update being done concurrently to the layout,\n *   which may supercede clearing the axis types\n */\nvar axLetters = ['x', 'y', 'z'];\nexports.clearAxisTypes = function (gd, traces, layoutUpdate) {\n  for (var i = 0; i < traces.length; i++) {\n    var trace = gd._fullData[i];\n    for (var j = 0; j < 3; j++) {\n      var ax = getFromTrace(gd, trace, axLetters[j]);\n\n      // do not clear log type - that's never an auto result so must have been intentional\n      if (ax && ax.type !== 'log') {\n        var axAttr = ax._name;\n        var sceneName = ax._id.substr(1);\n        if (sceneName.substr(0, 5) === 'scene') {\n          if (layoutUpdate[sceneName] !== undefined) continue;\n          axAttr = sceneName + '.' + axAttr;\n        }\n        var typeAttr = axAttr + '.type';\n        if (layoutUpdate[axAttr] === undefined && layoutUpdate[typeAttr] === undefined) {\n          Lib.nestedProperty(gd.layout, typeAttr).set(null);\n        }\n      }\n    }\n  }\n};","map":{"version":3,"names":["isNumeric","require","m4FromQuat","Registry","Lib","Plots","AxisIds","Color","cleanId","getFromTrace","traceIs","exports","clearPromiseQueue","gd","Array","isArray","_promises","length","log","cleanLayout","layout","i","j","xaxis1","xaxis","yaxis1","yaxis","scene1","scene","axisAttrRegex","subplotsRegistry","cartesian","attrRegex","polarAttrRegex","polar","ternaryAttrRegex","ternary","sceneAttrRegex","gl3d","keys","Object","key","test","ax","anchor","overlaying","type","isdate","islog","autorange","rangemode","categories","emptyContainer","domain","autotick","undefined","tickmode","cleanTitle","radialaxis","aaxis","baxis","caxis","cameraposition","rotation","center","radius","mat","eye","camera","x","y","z","up","zaxis","annotationsLen","annotations","ann","isPlainObject","ref","xref","yref","cleanAxRef","shapesLen","shapes","shape","imagesLen","images","image","legend","xanchor","yanchor","dragmode","clean","template","container","attr","valIn","axLetter","charAt","titleContainer","title","text","rewireAttr","oldAttrName","newAttrName","oldAttrSet","newAttrSet","cleanData","data","tracei","trace","ybins","xbins","error_y","dc","defaults","yeColor","color","defaultLine","addOpacity","rgb","opacity","bardir","substr","orientation","swapXYData","colorscale","scl","reversescale","reversescl","textposition","cleanTextPosition","_module","getModule","colorbar","containerName","contours","dims","opts","highlightColor","highlightcolor","highlightWidth","highlightwidth","increasingShowlegend","increasing","showlegend","decreasingShowlegend","decreasing","increasingName","cleanFinanceDir","decreasingName","newName","commonPrefix","name","transforms","transform","filtersrc","target","calendar","valuecalendar","styles","style","prevStyles","styleKeys","push","value","line","marker","autobinx","autobiny","dirContainer","dirName","String","name1","name2","show1","show2","trim","minLen","Math","min","out","posY","posX","indexOf","outer","innerStr","swapAttrs","transpose","error_x","errorY","copyYstyle","copy_ystyle","thickness","width","hoverinfo","hoverInfoParts","split","join","coerceTraceIndices","traceIndices","map","_","traceIndicesOut","isIndex","warn","manageArrayContainers","np","newVal","undoit","obj","parts","pLength","pLast","pLastIsNumber","contPath","slice","cont","nestedProperty","get","splice","astr","set","ATTR_TAIL_RE","getParent","tail","search","hasParent","aobj","attrParent","axLetters","clearAxisTypes","traces","layoutUpdate","_fullData","axAttr","_name","sceneName","_id","typeAttr"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/plot_api/helpers.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar m4FromQuat = require('gl-mat4/fromQuat');\n\nvar Registry = require('../registry');\nvar Lib = require('../lib');\nvar Plots = require('../plots/plots');\nvar AxisIds = require('../plots/cartesian/axis_ids');\nvar Color = require('../components/color');\n\nvar cleanId = AxisIds.cleanId;\nvar getFromTrace = AxisIds.getFromTrace;\nvar traceIs = Registry.traceIs;\n\n// clear the promise queue if one of them got rejected\nexports.clearPromiseQueue = function(gd) {\n    if(Array.isArray(gd._promises) && gd._promises.length > 0) {\n        Lib.log('Clearing previous rejected promises from queue.');\n    }\n\n    gd._promises = [];\n};\n\n// make a few changes to the layout right away\n// before it gets used for anything\n// backward compatibility and cleanup of nonstandard options\nexports.cleanLayout = function(layout) {\n    var i, j;\n\n    if(!layout) layout = {};\n\n    // cannot have (x|y)axis1, numbering goes axis, axis2, axis3...\n    if(layout.xaxis1) {\n        if(!layout.xaxis) layout.xaxis = layout.xaxis1;\n        delete layout.xaxis1;\n    }\n    if(layout.yaxis1) {\n        if(!layout.yaxis) layout.yaxis = layout.yaxis1;\n        delete layout.yaxis1;\n    }\n    if(layout.scene1) {\n        if(!layout.scene) layout.scene = layout.scene1;\n        delete layout.scene1;\n    }\n\n    var axisAttrRegex = (Plots.subplotsRegistry.cartesian || {}).attrRegex;\n    var polarAttrRegex = (Plots.subplotsRegistry.polar || {}).attrRegex;\n    var ternaryAttrRegex = (Plots.subplotsRegistry.ternary || {}).attrRegex;\n    var sceneAttrRegex = (Plots.subplotsRegistry.gl3d || {}).attrRegex;\n\n    var keys = Object.keys(layout);\n    for(i = 0; i < keys.length; i++) {\n        var key = keys[i];\n\n        if(axisAttrRegex && axisAttrRegex.test(key)) {\n            // modifications to cartesian axes\n\n            var ax = layout[key];\n            if(ax.anchor && ax.anchor !== 'free') {\n                ax.anchor = cleanId(ax.anchor);\n            }\n            if(ax.overlaying) ax.overlaying = cleanId(ax.overlaying);\n\n            // old method of axis type - isdate and islog (before category existed)\n            if(!ax.type) {\n                if(ax.isdate) ax.type = 'date';\n                else if(ax.islog) ax.type = 'log';\n                else if(ax.isdate === false && ax.islog === false) ax.type = 'linear';\n            }\n            if(ax.autorange === 'withzero' || ax.autorange === 'tozero') {\n                ax.autorange = true;\n                ax.rangemode = 'tozero';\n            }\n            delete ax.islog;\n            delete ax.isdate;\n            delete ax.categories; // replaced by _categories\n\n            // prune empty domain arrays made before the new nestedProperty\n            if(emptyContainer(ax, 'domain')) delete ax.domain;\n\n            // autotick -> tickmode\n            if(ax.autotick !== undefined) {\n                if(ax.tickmode === undefined) {\n                    ax.tickmode = ax.autotick ? 'auto' : 'linear';\n                }\n                delete ax.autotick;\n            }\n\n            cleanTitle(ax);\n        } else if(polarAttrRegex && polarAttrRegex.test(key)) {\n            // modifications for polar\n\n            var polar = layout[key];\n            cleanTitle(polar.radialaxis);\n        } else if(ternaryAttrRegex && ternaryAttrRegex.test(key)) {\n            // modifications for ternary\n\n            var ternary = layout[key];\n            cleanTitle(ternary.aaxis);\n            cleanTitle(ternary.baxis);\n            cleanTitle(ternary.caxis);\n        } else if(sceneAttrRegex && sceneAttrRegex.test(key)) {\n            // modifications for 3D scenes\n\n            var scene = layout[key];\n\n            // clean old Camera coords\n            var cameraposition = scene.cameraposition;\n\n            if(Array.isArray(cameraposition) && cameraposition[0].length === 4) {\n                var rotation = cameraposition[0];\n                var center = cameraposition[1];\n                var radius = cameraposition[2];\n                var mat = m4FromQuat([], rotation);\n                var eye = [];\n\n                for(j = 0; j < 3; ++j) {\n                    eye[j] = center[j] + radius * mat[2 + 4 * j];\n                }\n\n                scene.camera = {\n                    eye: {x: eye[0], y: eye[1], z: eye[2]},\n                    center: {x: center[0], y: center[1], z: center[2]},\n                    up: {x: 0, y: 0, z: 1} // we just ignore calculating camera z up in this case\n                };\n\n                delete scene.cameraposition;\n            }\n\n            // clean axis titles\n            cleanTitle(scene.xaxis);\n            cleanTitle(scene.yaxis);\n            cleanTitle(scene.zaxis);\n        }\n    }\n\n    var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;\n    for(i = 0; i < annotationsLen; i++) {\n        var ann = layout.annotations[i];\n\n        if(!Lib.isPlainObject(ann)) continue;\n\n        if(ann.ref) {\n            if(ann.ref === 'paper') {\n                ann.xref = 'paper';\n                ann.yref = 'paper';\n            } else if(ann.ref === 'data') {\n                ann.xref = 'x';\n                ann.yref = 'y';\n            }\n            delete ann.ref;\n        }\n\n        cleanAxRef(ann, 'xref');\n        cleanAxRef(ann, 'yref');\n    }\n\n    var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;\n    for(i = 0; i < shapesLen; i++) {\n        var shape = layout.shapes[i];\n\n        if(!Lib.isPlainObject(shape)) continue;\n\n        cleanAxRef(shape, 'xref');\n        cleanAxRef(shape, 'yref');\n    }\n\n    var imagesLen = Array.isArray(layout.images) ? layout.images.length : 0;\n    for(i = 0; i < imagesLen; i++) {\n        var image = layout.images[i];\n\n        if(!Lib.isPlainObject(image)) continue;\n\n        cleanAxRef(image, 'xref');\n        cleanAxRef(image, 'yref');\n    }\n\n    var legend = layout.legend;\n    if(legend) {\n        // check for old-style legend positioning (x or y is +/- 100)\n        if(legend.x > 3) {\n            legend.x = 1.02;\n            legend.xanchor = 'left';\n        } else if(legend.x < -2) {\n            legend.x = -0.02;\n            legend.xanchor = 'right';\n        }\n\n        if(legend.y > 3) {\n            legend.y = 1.02;\n            legend.yanchor = 'bottom';\n        } else if(legend.y < -2) {\n            legend.y = -0.02;\n            legend.yanchor = 'top';\n        }\n    }\n\n    // clean plot title\n    cleanTitle(layout);\n\n    /*\n     * Moved from rotate -> orbit for dragmode\n     */\n    if(layout.dragmode === 'rotate') layout.dragmode = 'orbit';\n\n    // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n    // supported, but new tinycolor does not because they're not valid css\n    Color.clean(layout);\n\n    // clean the layout container in layout.template\n    if(layout.template && layout.template.layout) {\n        exports.cleanLayout(layout.template.layout);\n    }\n\n    return layout;\n};\n\nfunction cleanAxRef(container, attr) {\n    var valIn = container[attr];\n    var axLetter = attr.charAt(0);\n    if(valIn && valIn !== 'paper') {\n        container[attr] = cleanId(valIn, axLetter, true);\n    }\n}\n\n/**\n * Cleans up old title attribute structure (flat) in favor of the new one (nested).\n *\n * @param {Object} titleContainer - an object potentially including deprecated title attributes\n */\nfunction cleanTitle(titleContainer) {\n    if(titleContainer) {\n        // title -> title.text\n        // (although title used to be a string attribute,\n        // numbers are accepted as well)\n        if(typeof titleContainer.title === 'string' || typeof titleContainer.title === 'number') {\n            titleContainer.title = {\n                text: titleContainer.title\n            };\n        }\n\n        rewireAttr('titlefont', 'font');\n        rewireAttr('titleposition', 'position');\n        rewireAttr('titleside', 'side');\n        rewireAttr('titleoffset', 'offset');\n    }\n\n    function rewireAttr(oldAttrName, newAttrName) {\n        var oldAttrSet = titleContainer[oldAttrName];\n        var newAttrSet = titleContainer.title && titleContainer.title[newAttrName];\n\n        if(oldAttrSet && !newAttrSet) {\n            // Ensure title object exists\n            if(!titleContainer.title) {\n                titleContainer.title = {};\n            }\n\n            titleContainer.title[newAttrName] = titleContainer[oldAttrName];\n            delete titleContainer[oldAttrName];\n        }\n    }\n}\n\n/*\n * cleanData: Make a few changes to the data for backward compatibility\n * before it gets used for anything. Modifies the data traces users provide.\n *\n * Important: if you're going to add something here that modifies a data array,\n * update it in place so the new array === the old one.\n */\nexports.cleanData = function(data) {\n    for(var tracei = 0; tracei < data.length; tracei++) {\n        var trace = data[tracei];\n        var i;\n\n        // use xbins to bin data in x, and ybins to bin data in y\n        if(trace.type === 'histogramy' && 'xbins' in trace && !('ybins' in trace)) {\n            trace.ybins = trace.xbins;\n            delete trace.xbins;\n        }\n\n        // error_y.opacity is obsolete - merge into color\n        if(trace.error_y && 'opacity' in trace.error_y) {\n            var dc = Color.defaults;\n            var yeColor = trace.error_y.color || (traceIs(trace, 'bar') ?\n                Color.defaultLine :\n                dc[tracei % dc.length]);\n            trace.error_y.color = Color.addOpacity(\n                Color.rgb(yeColor),\n                Color.opacity(yeColor) * trace.error_y.opacity);\n            delete trace.error_y.opacity;\n        }\n\n        // convert bardir to orientation, and put the data into\n        // the axes it's eventually going to be used with\n        if('bardir' in trace) {\n            if(trace.bardir === 'h' && (traceIs(trace, 'bar') ||\n                trace.type.substr(0, 9) === 'histogram')) {\n                trace.orientation = 'h';\n                exports.swapXYData(trace);\n            }\n            delete trace.bardir;\n        }\n\n        // now we have only one 1D histogram type, and whether\n        // it uses x or y data depends on trace.orientation\n        if(trace.type === 'histogramy') exports.swapXYData(trace);\n        if(trace.type === 'histogramx' || trace.type === 'histogramy') {\n            trace.type = 'histogram';\n        }\n\n        // scl->scale, reversescl->reversescale\n        if('scl' in trace && !('colorscale' in trace)) {\n            trace.colorscale = trace.scl;\n            delete trace.scl;\n        }\n        if('reversescl' in trace && !('reversescale' in trace)) {\n            trace.reversescale = trace.reversescl;\n            delete trace.reversescl;\n        }\n\n        // axis ids x1 -> x, y1-> y\n        if(trace.xaxis) trace.xaxis = cleanId(trace.xaxis, 'x');\n        if(trace.yaxis) trace.yaxis = cleanId(trace.yaxis, 'y');\n\n        // scene ids scene1 -> scene\n        if(traceIs(trace, 'gl3d') && trace.scene) {\n            trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);\n        }\n\n        if(!traceIs(trace, 'pie-like') && !traceIs(trace, 'bar-like')) {\n            if(Array.isArray(trace.textposition)) {\n                for(i = 0; i < trace.textposition.length; i++) {\n                    trace.textposition[i] = cleanTextPosition(trace.textposition[i]);\n                }\n            } else if(trace.textposition) {\n                trace.textposition = cleanTextPosition(trace.textposition);\n            }\n        }\n\n        // fix typo in colorscale definition\n        var _module = Registry.getModule(trace);\n        if(_module && _module.colorbar) {\n            var containerName = _module.colorbar.container;\n            var container = containerName ? trace[containerName] : trace;\n            if(container && container.colorscale) {\n                if(container.colorscale === 'YIGnBu') container.colorscale = 'YlGnBu';\n                if(container.colorscale === 'YIOrRd') container.colorscale = 'YlOrRd';\n            }\n        }\n\n        // fix typo in surface 'highlight*' definitions\n        if(trace.type === 'surface' && Lib.isPlainObject(trace.contours)) {\n            var dims = ['x', 'y', 'z'];\n\n            for(i = 0; i < dims.length; i++) {\n                var opts = trace.contours[dims[i]];\n\n                if(!Lib.isPlainObject(opts)) continue;\n\n                if(opts.highlightColor) {\n                    opts.highlightcolor = opts.highlightColor;\n                    delete opts.highlightColor;\n                }\n\n                if(opts.highlightWidth) {\n                    opts.highlightwidth = opts.highlightWidth;\n                    delete opts.highlightWidth;\n                }\n            }\n        }\n\n        // fixes from converting finance from transforms to real trace types\n        if(trace.type === 'candlestick' || trace.type === 'ohlc') {\n            var increasingShowlegend = (trace.increasing || {}).showlegend !== false;\n            var decreasingShowlegend = (trace.decreasing || {}).showlegend !== false;\n            var increasingName = cleanFinanceDir(trace.increasing);\n            var decreasingName = cleanFinanceDir(trace.decreasing);\n\n            // now figure out something smart to do with the separate direction\n            // names we removed\n            if((increasingName !== false) && (decreasingName !== false)) {\n                // both sub-names existed: base name previously had no effect\n                // so ignore it and try to find a shared part of the sub-names\n\n                var newName = commonPrefix(\n                    increasingName, decreasingName,\n                    increasingShowlegend, decreasingShowlegend\n                );\n                // if no common part, leave whatever name was (or wasn't) there\n                if(newName) trace.name = newName;\n            } else if((increasingName || decreasingName) && !trace.name) {\n                // one sub-name existed but not the base name - just use the sub-name\n                trace.name = increasingName || decreasingName;\n            }\n        }\n\n        // transforms backward compatibility fixes\n        if(Array.isArray(trace.transforms)) {\n            var transforms = trace.transforms;\n\n            for(i = 0; i < transforms.length; i++) {\n                var transform = transforms[i];\n\n                if(!Lib.isPlainObject(transform)) continue;\n\n                switch(transform.type) {\n                    case 'filter':\n                        if(transform.filtersrc) {\n                            transform.target = transform.filtersrc;\n                            delete transform.filtersrc;\n                        }\n\n                        if(transform.calendar) {\n                            if(!transform.valuecalendar) {\n                                transform.valuecalendar = transform.calendar;\n                            }\n                            delete transform.calendar;\n                        }\n                        break;\n\n                    case 'groupby':\n                        // Name has changed from `style` to `styles`, so use `style` but prefer `styles`:\n                        transform.styles = transform.styles || transform.style;\n\n                        if(transform.styles && !Array.isArray(transform.styles)) {\n                            var prevStyles = transform.styles;\n                            var styleKeys = Object.keys(prevStyles);\n\n                            transform.styles = [];\n                            for(var j = 0; j < styleKeys.length; j++) {\n                                transform.styles.push({\n                                    target: styleKeys[j],\n                                    value: prevStyles[styleKeys[j]]\n                                });\n                            }\n                        }\n                        break;\n                }\n            }\n        }\n\n        // prune empty containers made before the new nestedProperty\n        if(emptyContainer(trace, 'line')) delete trace.line;\n        if('marker' in trace) {\n            if(emptyContainer(trace.marker, 'line')) delete trace.marker.line;\n            if(emptyContainer(trace, 'marker')) delete trace.marker;\n        }\n\n        // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n        // supported, but new tinycolor does not because they're not valid css\n        Color.clean(trace);\n\n        // remove obsolete autobin(x|y) attributes, but only if true\n        // if false, this needs to happen in Histogram.calc because it\n        // can be a one-time autobin so we need to know the results before\n        // we can push them back into the trace.\n        if(trace.autobinx) {\n            delete trace.autobinx;\n            delete trace.xbins;\n        }\n        if(trace.autobiny) {\n            delete trace.autobiny;\n            delete trace.ybins;\n        }\n\n        cleanTitle(trace);\n        if(trace.colorbar) cleanTitle(trace.colorbar);\n        if(trace.marker && trace.marker.colorbar) cleanTitle(trace.marker.colorbar);\n        if(trace.line && trace.line.colorbar) cleanTitle(trace.line.colorbar);\n        if(trace.aaxis) cleanTitle(trace.aaxis);\n        if(trace.baxis) cleanTitle(trace.baxis);\n    }\n};\n\nfunction cleanFinanceDir(dirContainer) {\n    if(!Lib.isPlainObject(dirContainer)) return false;\n\n    var dirName = dirContainer.name;\n\n    delete dirContainer.name;\n    delete dirContainer.showlegend;\n\n    return (typeof dirName === 'string' || typeof dirName === 'number') && String(dirName);\n}\n\nfunction commonPrefix(name1, name2, show1, show2) {\n    // if only one is shown in the legend, use that\n    if(show1 && !show2) return name1;\n    if(show2 && !show1) return name2;\n\n    // if both or neither are in the legend, check if one is blank (or whitespace)\n    // and use the other one\n    // note that hover labels can still use the name even if the legend doesn't\n    if(!name1.trim()) return name2;\n    if(!name2.trim()) return name1;\n\n    var minLen = Math.min(name1.length, name2.length);\n    var i;\n    for(i = 0; i < minLen; i++) {\n        if(name1.charAt(i) !== name2.charAt(i)) break;\n    }\n\n    var out = name1.substr(0, i);\n    return out.trim();\n}\n\n// textposition - support partial attributes (ie just 'top')\n// and incorrect use of middle / center etc.\nfunction cleanTextPosition(textposition) {\n    var posY = 'middle';\n    var posX = 'center';\n\n    if(typeof textposition === 'string') {\n        if(textposition.indexOf('top') !== -1) posY = 'top';\n        else if(textposition.indexOf('bottom') !== -1) posY = 'bottom';\n\n        if(textposition.indexOf('left') !== -1) posX = 'left';\n        else if(textposition.indexOf('right') !== -1) posX = 'right';\n    }\n\n    return posY + ' ' + posX;\n}\n\nfunction emptyContainer(outer, innerStr) {\n    return (innerStr in outer) &&\n        (typeof outer[innerStr] === 'object') &&\n        (Object.keys(outer[innerStr]).length === 0);\n}\n\n\n// swap all the data and data attributes associated with x and y\nexports.swapXYData = function(trace) {\n    var i;\n    Lib.swapAttrs(trace, ['?', '?0', 'd?', '?bins', 'nbins?', 'autobin?', '?src', 'error_?']);\n    if(Array.isArray(trace.z) && Array.isArray(trace.z[0])) {\n        if(trace.transpose) delete trace.transpose;\n        else trace.transpose = true;\n    }\n    if(trace.error_x && trace.error_y) {\n        var errorY = trace.error_y;\n        var copyYstyle = ('copy_ystyle' in errorY) ?\n            errorY.copy_ystyle :\n            !(errorY.color || errorY.thickness || errorY.width);\n        Lib.swapAttrs(trace, ['error_?.copy_ystyle']);\n        if(copyYstyle) {\n            Lib.swapAttrs(trace, ['error_?.color', 'error_?.thickness', 'error_?.width']);\n        }\n    }\n    if(typeof trace.hoverinfo === 'string') {\n        var hoverInfoParts = trace.hoverinfo.split('+');\n        for(i = 0; i < hoverInfoParts.length; i++) {\n            if(hoverInfoParts[i] === 'x') hoverInfoParts[i] = 'y';\n            else if(hoverInfoParts[i] === 'y') hoverInfoParts[i] = 'x';\n        }\n        trace.hoverinfo = hoverInfoParts.join('+');\n    }\n};\n\n// coerce traceIndices input to array of trace indices\nexports.coerceTraceIndices = function(gd, traceIndices) {\n    if(isNumeric(traceIndices)) {\n        return [traceIndices];\n    } else if(!Array.isArray(traceIndices) || !traceIndices.length) {\n        return gd.data.map(function(_, i) { return i; });\n    } else if(Array.isArray(traceIndices)) {\n        var traceIndicesOut = [];\n        for(var i = 0; i < traceIndices.length; i++) {\n            if(Lib.isIndex(traceIndices[i], gd.data.length)) {\n                traceIndicesOut.push(traceIndices[i]);\n            } else {\n                Lib.warn('trace index (', traceIndices[i], ') is not a number or is out of bounds');\n            }\n        }\n        return traceIndicesOut;\n    }\n\n    return traceIndices;\n};\n\n/**\n * Manages logic around array container item creation / deletion / update\n * that nested property alone can't handle.\n *\n * @param {Object} np\n *  nested property of update attribute string about trace or layout object\n * @param {*} newVal\n *  update value passed to restyle / relayout / update\n * @param {Object} undoit\n *  undo hash (N.B. undoit may be mutated here).\n *\n */\nexports.manageArrayContainers = function(np, newVal, undoit) {\n    var obj = np.obj;\n    var parts = np.parts;\n    var pLength = parts.length;\n    var pLast = parts[pLength - 1];\n\n    var pLastIsNumber = isNumeric(pLast);\n\n    if(pLastIsNumber && newVal === null) {\n        // delete item\n\n        // Clear item in array container when new value is null\n        var contPath = parts.slice(0, pLength - 1).join('.');\n        var cont = Lib.nestedProperty(obj, contPath).get();\n        cont.splice(pLast, 1);\n\n        // Note that nested property clears null / undefined at end of\n        // array container, but not within them.\n    } else if(pLastIsNumber && np.get() === undefined) {\n        // create item\n\n        // When adding a new item, make sure undo command will remove it\n        if(np.get() === undefined) undoit[np.astr] = null;\n\n        np.set(newVal);\n    } else {\n        // update item\n\n        // If the last part of attribute string isn't a number,\n        // np.set is all we need.\n        np.set(newVal);\n    }\n};\n\n/*\n * Match the part to strip off to turn an attribute into its parent\n * really it should be either '.some_characters' or '[number]'\n * but we're a little more permissive here and match either\n * '.not_brackets_or_dot' or '[not_brackets_or_dot]'\n */\nvar ATTR_TAIL_RE = /(\\.[^\\[\\]\\.]+|\\[[^\\[\\]\\.]+\\])$/;\n\nfunction getParent(attr) {\n    var tail = attr.search(ATTR_TAIL_RE);\n    if(tail > 0) return attr.substr(0, tail);\n}\n\n/*\n * hasParent: does an attribute object contain a parent of the given attribute?\n * for example, given 'images[2].x' do we also have 'images' or 'images[2]'?\n *\n * @param {Object} aobj\n *  update object, whose keys are attribute strings and values are their new settings\n * @param {string} attr\n *  the attribute string to test against\n * @returns {Boolean}\n *  is a parent of attr present in aobj?\n */\nexports.hasParent = function(aobj, attr) {\n    var attrParent = getParent(attr);\n    while(attrParent) {\n        if(attrParent in aobj) return true;\n        attrParent = getParent(attrParent);\n    }\n    return false;\n};\n\n/**\n * Empty out types for all axes containing these traces so we auto-set them again\n *\n * @param {object} gd\n * @param {[integer]} traces: trace indices to search for axes to clear the types of\n * @param {object} layoutUpdate: any update being done concurrently to the layout,\n *   which may supercede clearing the axis types\n */\nvar axLetters = ['x', 'y', 'z'];\nexports.clearAxisTypes = function(gd, traces, layoutUpdate) {\n    for(var i = 0; i < traces.length; i++) {\n        var trace = gd._fullData[i];\n        for(var j = 0; j < 3; j++) {\n            var ax = getFromTrace(gd, trace, axLetters[j]);\n\n            // do not clear log type - that's never an auto result so must have been intentional\n            if(ax && ax.type !== 'log') {\n                var axAttr = ax._name;\n                var sceneName = ax._id.substr(1);\n                if(sceneName.substr(0, 5) === 'scene') {\n                    if(layoutUpdate[sceneName] !== undefined) continue;\n                    axAttr = sceneName + '.' + axAttr;\n                }\n                var typeAttr = axAttr + '.type';\n\n                if(layoutUpdate[axAttr] === undefined && layoutUpdate[typeAttr] === undefined) {\n                    Lib.nestedProperty(gd.layout, typeAttr).set(null);\n                }\n            }\n        }\n    }\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AACzC,IAAIC,UAAU,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAE5C,IAAIE,QAAQ,GAAGF,OAAO,CAAC,aAAa,CAAC;AACrC,IAAIG,GAAG,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAC3B,IAAII,KAAK,GAAGJ,OAAO,CAAC,gBAAgB,CAAC;AACrC,IAAIK,OAAO,GAAGL,OAAO,CAAC,6BAA6B,CAAC;AACpD,IAAIM,KAAK,GAAGN,OAAO,CAAC,qBAAqB,CAAC;AAE1C,IAAIO,OAAO,GAAGF,OAAO,CAACE,OAAO;AAC7B,IAAIC,YAAY,GAAGH,OAAO,CAACG,YAAY;AACvC,IAAIC,OAAO,GAAGP,QAAQ,CAACO,OAAO;;AAE9B;AACAC,OAAO,CAACC,iBAAiB,GAAG,UAASC,EAAE,EAAE;EACrC,IAAGC,KAAK,CAACC,OAAO,CAACF,EAAE,CAACG,SAAS,CAAC,IAAIH,EAAE,CAACG,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;IACvDb,GAAG,CAACc,GAAG,CAAC,iDAAiD,CAAC;EAC9D;EAEAL,EAAE,CAACG,SAAS,GAAG,EAAE;AACrB,CAAC;;AAED;AACA;AACA;AACAL,OAAO,CAACQ,WAAW,GAAG,UAASC,MAAM,EAAE;EACnC,IAAIC,CAAC,EAAEC,CAAC;EAER,IAAG,CAACF,MAAM,EAAEA,MAAM,GAAG,CAAC,CAAC;;EAEvB;EACA,IAAGA,MAAM,CAACG,MAAM,EAAE;IACd,IAAG,CAACH,MAAM,CAACI,KAAK,EAAEJ,MAAM,CAACI,KAAK,GAAGJ,MAAM,CAACG,MAAM;IAC9C,OAAOH,MAAM,CAACG,MAAM;EACxB;EACA,IAAGH,MAAM,CAACK,MAAM,EAAE;IACd,IAAG,CAACL,MAAM,CAACM,KAAK,EAAEN,MAAM,CAACM,KAAK,GAAGN,MAAM,CAACK,MAAM;IAC9C,OAAOL,MAAM,CAACK,MAAM;EACxB;EACA,IAAGL,MAAM,CAACO,MAAM,EAAE;IACd,IAAG,CAACP,MAAM,CAACQ,KAAK,EAAER,MAAM,CAACQ,KAAK,GAAGR,MAAM,CAACO,MAAM;IAC9C,OAAOP,MAAM,CAACO,MAAM;EACxB;EAEA,IAAIE,aAAa,GAAG,CAACxB,KAAK,CAACyB,gBAAgB,CAACC,SAAS,IAAI,CAAC,CAAC,EAAEC,SAAS;EACtE,IAAIC,cAAc,GAAG,CAAC5B,KAAK,CAACyB,gBAAgB,CAACI,KAAK,IAAI,CAAC,CAAC,EAAEF,SAAS;EACnE,IAAIG,gBAAgB,GAAG,CAAC9B,KAAK,CAACyB,gBAAgB,CAACM,OAAO,IAAI,CAAC,CAAC,EAAEJ,SAAS;EACvE,IAAIK,cAAc,GAAG,CAAChC,KAAK,CAACyB,gBAAgB,CAACQ,IAAI,IAAI,CAAC,CAAC,EAAEN,SAAS;EAElE,IAAIO,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACnB,MAAM,CAAC;EAC9B,KAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,IAAI,CAACtB,MAAM,EAAEI,CAAC,EAAE,EAAE;IAC7B,IAAIoB,GAAG,GAAGF,IAAI,CAAClB,CAAC,CAAC;IAEjB,IAAGQ,aAAa,IAAIA,aAAa,CAACa,IAAI,CAACD,GAAG,CAAC,EAAE;MACzC;;MAEA,IAAIE,EAAE,GAAGvB,MAAM,CAACqB,GAAG,CAAC;MACpB,IAAGE,EAAE,CAACC,MAAM,IAAID,EAAE,CAACC,MAAM,KAAK,MAAM,EAAE;QAClCD,EAAE,CAACC,MAAM,GAAGpC,OAAO,CAACmC,EAAE,CAACC,MAAM,CAAC;MAClC;MACA,IAAGD,EAAE,CAACE,UAAU,EAAEF,EAAE,CAACE,UAAU,GAAGrC,OAAO,CAACmC,EAAE,CAACE,UAAU,CAAC;;MAExD;MACA,IAAG,CAACF,EAAE,CAACG,IAAI,EAAE;QACT,IAAGH,EAAE,CAACI,MAAM,EAAEJ,EAAE,CAACG,IAAI,GAAG,MAAM,CAAC,KAC1B,IAAGH,EAAE,CAACK,KAAK,EAAEL,EAAE,CAACG,IAAI,GAAG,KAAK,CAAC,KAC7B,IAAGH,EAAE,CAACI,MAAM,KAAK,KAAK,IAAIJ,EAAE,CAACK,KAAK,KAAK,KAAK,EAAEL,EAAE,CAACG,IAAI,GAAG,QAAQ;MACzE;MACA,IAAGH,EAAE,CAACM,SAAS,KAAK,UAAU,IAAIN,EAAE,CAACM,SAAS,KAAK,QAAQ,EAAE;QACzDN,EAAE,CAACM,SAAS,GAAG,IAAI;QACnBN,EAAE,CAACO,SAAS,GAAG,QAAQ;MAC3B;MACA,OAAOP,EAAE,CAACK,KAAK;MACf,OAAOL,EAAE,CAACI,MAAM;MAChB,OAAOJ,EAAE,CAACQ,UAAU,CAAC,CAAC;;MAEtB;MACA,IAAGC,cAAc,CAACT,EAAE,EAAE,QAAQ,CAAC,EAAE,OAAOA,EAAE,CAACU,MAAM;;MAEjD;MACA,IAAGV,EAAE,CAACW,QAAQ,KAAKC,SAAS,EAAE;QAC1B,IAAGZ,EAAE,CAACa,QAAQ,KAAKD,SAAS,EAAE;UAC1BZ,EAAE,CAACa,QAAQ,GAAGb,EAAE,CAACW,QAAQ,GAAG,MAAM,GAAG,QAAQ;QACjD;QACA,OAAOX,EAAE,CAACW,QAAQ;MACtB;MAEAG,UAAU,CAACd,EAAE,CAAC;IAClB,CAAC,MAAM,IAAGV,cAAc,IAAIA,cAAc,CAACS,IAAI,CAACD,GAAG,CAAC,EAAE;MAClD;;MAEA,IAAIP,KAAK,GAAGd,MAAM,CAACqB,GAAG,CAAC;MACvBgB,UAAU,CAACvB,KAAK,CAACwB,UAAU,CAAC;IAChC,CAAC,MAAM,IAAGvB,gBAAgB,IAAIA,gBAAgB,CAACO,IAAI,CAACD,GAAG,CAAC,EAAE;MACtD;;MAEA,IAAIL,OAAO,GAAGhB,MAAM,CAACqB,GAAG,CAAC;MACzBgB,UAAU,CAACrB,OAAO,CAACuB,KAAK,CAAC;MACzBF,UAAU,CAACrB,OAAO,CAACwB,KAAK,CAAC;MACzBH,UAAU,CAACrB,OAAO,CAACyB,KAAK,CAAC;IAC7B,CAAC,MAAM,IAAGxB,cAAc,IAAIA,cAAc,CAACK,IAAI,CAACD,GAAG,CAAC,EAAE;MAClD;;MAEA,IAAIb,KAAK,GAAGR,MAAM,CAACqB,GAAG,CAAC;;MAEvB;MACA,IAAIqB,cAAc,GAAGlC,KAAK,CAACkC,cAAc;MAEzC,IAAGhD,KAAK,CAACC,OAAO,CAAC+C,cAAc,CAAC,IAAIA,cAAc,CAAC,CAAC,CAAC,CAAC7C,MAAM,KAAK,CAAC,EAAE;QAChE,IAAI8C,QAAQ,GAAGD,cAAc,CAAC,CAAC,CAAC;QAChC,IAAIE,MAAM,GAAGF,cAAc,CAAC,CAAC,CAAC;QAC9B,IAAIG,MAAM,GAAGH,cAAc,CAAC,CAAC,CAAC;QAC9B,IAAII,GAAG,GAAGhE,UAAU,CAAC,EAAE,EAAE6D,QAAQ,CAAC;QAClC,IAAII,GAAG,GAAG,EAAE;QAEZ,KAAI7C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;UACnB6C,GAAG,CAAC7C,CAAC,CAAC,GAAG0C,MAAM,CAAC1C,CAAC,CAAC,GAAG2C,MAAM,GAAGC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG5C,CAAC,CAAC;QAChD;QAEAM,KAAK,CAACwC,MAAM,GAAG;UACXD,GAAG,EAAE;YAACE,CAAC,EAAEF,GAAG,CAAC,CAAC,CAAC;YAAEG,CAAC,EAAEH,GAAG,CAAC,CAAC,CAAC;YAAEI,CAAC,EAAEJ,GAAG,CAAC,CAAC;UAAC,CAAC;UACtCH,MAAM,EAAE;YAACK,CAAC,EAAEL,MAAM,CAAC,CAAC,CAAC;YAAEM,CAAC,EAAEN,MAAM,CAAC,CAAC,CAAC;YAAEO,CAAC,EAAEP,MAAM,CAAC,CAAC;UAAC,CAAC;UAClDQ,EAAE,EAAE;YAACH,CAAC,EAAE,CAAC;YAAEC,CAAC,EAAE,CAAC;YAAEC,CAAC,EAAE;UAAC,CAAC,CAAC;QAC3B,CAAC;;QAED,OAAO3C,KAAK,CAACkC,cAAc;MAC/B;;MAEA;MACAL,UAAU,CAAC7B,KAAK,CAACJ,KAAK,CAAC;MACvBiC,UAAU,CAAC7B,KAAK,CAACF,KAAK,CAAC;MACvB+B,UAAU,CAAC7B,KAAK,CAAC6C,KAAK,CAAC;IAC3B;EACJ;EAEA,IAAIC,cAAc,GAAG5D,KAAK,CAACC,OAAO,CAACK,MAAM,CAACuD,WAAW,CAAC,GAAGvD,MAAM,CAACuD,WAAW,CAAC1D,MAAM,GAAG,CAAC;EACtF,KAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqD,cAAc,EAAErD,CAAC,EAAE,EAAE;IAChC,IAAIuD,GAAG,GAAGxD,MAAM,CAACuD,WAAW,CAACtD,CAAC,CAAC;IAE/B,IAAG,CAACjB,GAAG,CAACyE,aAAa,CAACD,GAAG,CAAC,EAAE;IAE5B,IAAGA,GAAG,CAACE,GAAG,EAAE;MACR,IAAGF,GAAG,CAACE,GAAG,KAAK,OAAO,EAAE;QACpBF,GAAG,CAACG,IAAI,GAAG,OAAO;QAClBH,GAAG,CAACI,IAAI,GAAG,OAAO;MACtB,CAAC,MAAM,IAAGJ,GAAG,CAACE,GAAG,KAAK,MAAM,EAAE;QAC1BF,GAAG,CAACG,IAAI,GAAG,GAAG;QACdH,GAAG,CAACI,IAAI,GAAG,GAAG;MAClB;MACA,OAAOJ,GAAG,CAACE,GAAG;IAClB;IAEAG,UAAU,CAACL,GAAG,EAAE,MAAM,CAAC;IACvBK,UAAU,CAACL,GAAG,EAAE,MAAM,CAAC;EAC3B;EAEA,IAAIM,SAAS,GAAGpE,KAAK,CAACC,OAAO,CAACK,MAAM,CAAC+D,MAAM,CAAC,GAAG/D,MAAM,CAAC+D,MAAM,CAAClE,MAAM,GAAG,CAAC;EACvE,KAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6D,SAAS,EAAE7D,CAAC,EAAE,EAAE;IAC3B,IAAI+D,KAAK,GAAGhE,MAAM,CAAC+D,MAAM,CAAC9D,CAAC,CAAC;IAE5B,IAAG,CAACjB,GAAG,CAACyE,aAAa,CAACO,KAAK,CAAC,EAAE;IAE9BH,UAAU,CAACG,KAAK,EAAE,MAAM,CAAC;IACzBH,UAAU,CAACG,KAAK,EAAE,MAAM,CAAC;EAC7B;EAEA,IAAIC,SAAS,GAAGvE,KAAK,CAACC,OAAO,CAACK,MAAM,CAACkE,MAAM,CAAC,GAAGlE,MAAM,CAACkE,MAAM,CAACrE,MAAM,GAAG,CAAC;EACvE,KAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgE,SAAS,EAAEhE,CAAC,EAAE,EAAE;IAC3B,IAAIkE,KAAK,GAAGnE,MAAM,CAACkE,MAAM,CAACjE,CAAC,CAAC;IAE5B,IAAG,CAACjB,GAAG,CAACyE,aAAa,CAACU,KAAK,CAAC,EAAE;IAE9BN,UAAU,CAACM,KAAK,EAAE,MAAM,CAAC;IACzBN,UAAU,CAACM,KAAK,EAAE,MAAM,CAAC;EAC7B;EAEA,IAAIC,MAAM,GAAGpE,MAAM,CAACoE,MAAM;EAC1B,IAAGA,MAAM,EAAE;IACP;IACA,IAAGA,MAAM,CAACnB,CAAC,GAAG,CAAC,EAAE;MACbmB,MAAM,CAACnB,CAAC,GAAG,IAAI;MACfmB,MAAM,CAACC,OAAO,GAAG,MAAM;IAC3B,CAAC,MAAM,IAAGD,MAAM,CAACnB,CAAC,GAAG,CAAC,CAAC,EAAE;MACrBmB,MAAM,CAACnB,CAAC,GAAG,CAAC,IAAI;MAChBmB,MAAM,CAACC,OAAO,GAAG,OAAO;IAC5B;IAEA,IAAGD,MAAM,CAAClB,CAAC,GAAG,CAAC,EAAE;MACbkB,MAAM,CAAClB,CAAC,GAAG,IAAI;MACfkB,MAAM,CAACE,OAAO,GAAG,QAAQ;IAC7B,CAAC,MAAM,IAAGF,MAAM,CAAClB,CAAC,GAAG,CAAC,CAAC,EAAE;MACrBkB,MAAM,CAAClB,CAAC,GAAG,CAAC,IAAI;MAChBkB,MAAM,CAACE,OAAO,GAAG,KAAK;IAC1B;EACJ;;EAEA;EACAjC,UAAU,CAACrC,MAAM,CAAC;;EAElB;AACJ;AACA;EACI,IAAGA,MAAM,CAACuE,QAAQ,KAAK,QAAQ,EAAEvE,MAAM,CAACuE,QAAQ,GAAG,OAAO;;EAE1D;EACA;EACApF,KAAK,CAACqF,KAAK,CAACxE,MAAM,CAAC;;EAEnB;EACA,IAAGA,MAAM,CAACyE,QAAQ,IAAIzE,MAAM,CAACyE,QAAQ,CAACzE,MAAM,EAAE;IAC1CT,OAAO,CAACQ,WAAW,CAACC,MAAM,CAACyE,QAAQ,CAACzE,MAAM,CAAC;EAC/C;EAEA,OAAOA,MAAM;AACjB,CAAC;AAED,SAAS6D,UAAUA,CAACa,SAAS,EAAEC,IAAI,EAAE;EACjC,IAAIC,KAAK,GAAGF,SAAS,CAACC,IAAI,CAAC;EAC3B,IAAIE,QAAQ,GAAGF,IAAI,CAACG,MAAM,CAAC,CAAC,CAAC;EAC7B,IAAGF,KAAK,IAAIA,KAAK,KAAK,OAAO,EAAE;IAC3BF,SAAS,CAACC,IAAI,CAAC,GAAGvF,OAAO,CAACwF,KAAK,EAAEC,QAAQ,EAAE,IAAI,CAAC;EACpD;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASxC,UAAUA,CAAC0C,cAAc,EAAE;EAChC,IAAGA,cAAc,EAAE;IACf;IACA;IACA;IACA,IAAG,OAAOA,cAAc,CAACC,KAAK,KAAK,QAAQ,IAAI,OAAOD,cAAc,CAACC,KAAK,KAAK,QAAQ,EAAE;MACrFD,cAAc,CAACC,KAAK,GAAG;QACnBC,IAAI,EAAEF,cAAc,CAACC;MACzB,CAAC;IACL;IAEAE,UAAU,CAAC,WAAW,EAAE,MAAM,CAAC;IAC/BA,UAAU,CAAC,eAAe,EAAE,UAAU,CAAC;IACvCA,UAAU,CAAC,WAAW,EAAE,MAAM,CAAC;IAC/BA,UAAU,CAAC,aAAa,EAAE,QAAQ,CAAC;EACvC;EAEA,SAASA,UAAUA,CAACC,WAAW,EAAEC,WAAW,EAAE;IAC1C,IAAIC,UAAU,GAAGN,cAAc,CAACI,WAAW,CAAC;IAC5C,IAAIG,UAAU,GAAGP,cAAc,CAACC,KAAK,IAAID,cAAc,CAACC,KAAK,CAACI,WAAW,CAAC;IAE1E,IAAGC,UAAU,IAAI,CAACC,UAAU,EAAE;MAC1B;MACA,IAAG,CAACP,cAAc,CAACC,KAAK,EAAE;QACtBD,cAAc,CAACC,KAAK,GAAG,CAAC,CAAC;MAC7B;MAEAD,cAAc,CAACC,KAAK,CAACI,WAAW,CAAC,GAAGL,cAAc,CAACI,WAAW,CAAC;MAC/D,OAAOJ,cAAc,CAACI,WAAW,CAAC;IACtC;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5F,OAAO,CAACgG,SAAS,GAAG,UAASC,IAAI,EAAE;EAC/B,KAAI,IAAIC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGD,IAAI,CAAC3F,MAAM,EAAE4F,MAAM,EAAE,EAAE;IAChD,IAAIC,KAAK,GAAGF,IAAI,CAACC,MAAM,CAAC;IACxB,IAAIxF,CAAC;;IAEL;IACA,IAAGyF,KAAK,CAAChE,IAAI,KAAK,YAAY,IAAI,OAAO,IAAIgE,KAAK,IAAI,EAAE,OAAO,IAAIA,KAAK,CAAC,EAAE;MACvEA,KAAK,CAACC,KAAK,GAAGD,KAAK,CAACE,KAAK;MACzB,OAAOF,KAAK,CAACE,KAAK;IACtB;;IAEA;IACA,IAAGF,KAAK,CAACG,OAAO,IAAI,SAAS,IAAIH,KAAK,CAACG,OAAO,EAAE;MAC5C,IAAIC,EAAE,GAAG3G,KAAK,CAAC4G,QAAQ;MACvB,IAAIC,OAAO,GAAGN,KAAK,CAACG,OAAO,CAACI,KAAK,KAAK3G,OAAO,CAACoG,KAAK,EAAE,KAAK,CAAC,GACvDvG,KAAK,CAAC+G,WAAW,GACjBJ,EAAE,CAACL,MAAM,GAAGK,EAAE,CAACjG,MAAM,CAAC,CAAC;MAC3B6F,KAAK,CAACG,OAAO,CAACI,KAAK,GAAG9G,KAAK,CAACgH,UAAU,CAClChH,KAAK,CAACiH,GAAG,CAACJ,OAAO,CAAC,EAClB7G,KAAK,CAACkH,OAAO,CAACL,OAAO,CAAC,GAAGN,KAAK,CAACG,OAAO,CAACQ,OAAO,CAAC;MACnD,OAAOX,KAAK,CAACG,OAAO,CAACQ,OAAO;IAChC;;IAEA;IACA;IACA,IAAG,QAAQ,IAAIX,KAAK,EAAE;MAClB,IAAGA,KAAK,CAACY,MAAM,KAAK,GAAG,KAAKhH,OAAO,CAACoG,KAAK,EAAE,KAAK,CAAC,IAC7CA,KAAK,CAAChE,IAAI,CAAC6E,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,WAAW,CAAC,EAAE;QAC1Cb,KAAK,CAACc,WAAW,GAAG,GAAG;QACvBjH,OAAO,CAACkH,UAAU,CAACf,KAAK,CAAC;MAC7B;MACA,OAAOA,KAAK,CAACY,MAAM;IACvB;;IAEA;IACA;IACA,IAAGZ,KAAK,CAAChE,IAAI,KAAK,YAAY,EAAEnC,OAAO,CAACkH,UAAU,CAACf,KAAK,CAAC;IACzD,IAAGA,KAAK,CAAChE,IAAI,KAAK,YAAY,IAAIgE,KAAK,CAAChE,IAAI,KAAK,YAAY,EAAE;MAC3DgE,KAAK,CAAChE,IAAI,GAAG,WAAW;IAC5B;;IAEA;IACA,IAAG,KAAK,IAAIgE,KAAK,IAAI,EAAE,YAAY,IAAIA,KAAK,CAAC,EAAE;MAC3CA,KAAK,CAACgB,UAAU,GAAGhB,KAAK,CAACiB,GAAG;MAC5B,OAAOjB,KAAK,CAACiB,GAAG;IACpB;IACA,IAAG,YAAY,IAAIjB,KAAK,IAAI,EAAE,cAAc,IAAIA,KAAK,CAAC,EAAE;MACpDA,KAAK,CAACkB,YAAY,GAAGlB,KAAK,CAACmB,UAAU;MACrC,OAAOnB,KAAK,CAACmB,UAAU;IAC3B;;IAEA;IACA,IAAGnB,KAAK,CAACtF,KAAK,EAAEsF,KAAK,CAACtF,KAAK,GAAGhB,OAAO,CAACsG,KAAK,CAACtF,KAAK,EAAE,GAAG,CAAC;IACvD,IAAGsF,KAAK,CAACpF,KAAK,EAAEoF,KAAK,CAACpF,KAAK,GAAGlB,OAAO,CAACsG,KAAK,CAACpF,KAAK,EAAE,GAAG,CAAC;;IAEvD;IACA,IAAGhB,OAAO,CAACoG,KAAK,EAAE,MAAM,CAAC,IAAIA,KAAK,CAAClF,KAAK,EAAE;MACtCkF,KAAK,CAAClF,KAAK,GAAGvB,KAAK,CAACyB,gBAAgB,CAACQ,IAAI,CAAC9B,OAAO,CAACsG,KAAK,CAAClF,KAAK,CAAC;IAClE;IAEA,IAAG,CAAClB,OAAO,CAACoG,KAAK,EAAE,UAAU,CAAC,IAAI,CAACpG,OAAO,CAACoG,KAAK,EAAE,UAAU,CAAC,EAAE;MAC3D,IAAGhG,KAAK,CAACC,OAAO,CAAC+F,KAAK,CAACoB,YAAY,CAAC,EAAE;QAClC,KAAI7G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyF,KAAK,CAACoB,YAAY,CAACjH,MAAM,EAAEI,CAAC,EAAE,EAAE;UAC3CyF,KAAK,CAACoB,YAAY,CAAC7G,CAAC,CAAC,GAAG8G,iBAAiB,CAACrB,KAAK,CAACoB,YAAY,CAAC7G,CAAC,CAAC,CAAC;QACpE;MACJ,CAAC,MAAM,IAAGyF,KAAK,CAACoB,YAAY,EAAE;QAC1BpB,KAAK,CAACoB,YAAY,GAAGC,iBAAiB,CAACrB,KAAK,CAACoB,YAAY,CAAC;MAC9D;IACJ;;IAEA;IACA,IAAIE,OAAO,GAAGjI,QAAQ,CAACkI,SAAS,CAACvB,KAAK,CAAC;IACvC,IAAGsB,OAAO,IAAIA,OAAO,CAACE,QAAQ,EAAE;MAC5B,IAAIC,aAAa,GAAGH,OAAO,CAACE,QAAQ,CAACxC,SAAS;MAC9C,IAAIA,SAAS,GAAGyC,aAAa,GAAGzB,KAAK,CAACyB,aAAa,CAAC,GAAGzB,KAAK;MAC5D,IAAGhB,SAAS,IAAIA,SAAS,CAACgC,UAAU,EAAE;QAClC,IAAGhC,SAAS,CAACgC,UAAU,KAAK,QAAQ,EAAEhC,SAAS,CAACgC,UAAU,GAAG,QAAQ;QACrE,IAAGhC,SAAS,CAACgC,UAAU,KAAK,QAAQ,EAAEhC,SAAS,CAACgC,UAAU,GAAG,QAAQ;MACzE;IACJ;;IAEA;IACA,IAAGhB,KAAK,CAAChE,IAAI,KAAK,SAAS,IAAI1C,GAAG,CAACyE,aAAa,CAACiC,KAAK,CAAC0B,QAAQ,CAAC,EAAE;MAC9D,IAAIC,IAAI,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;MAE1B,KAAIpH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoH,IAAI,CAACxH,MAAM,EAAEI,CAAC,EAAE,EAAE;QAC7B,IAAIqH,IAAI,GAAG5B,KAAK,CAAC0B,QAAQ,CAACC,IAAI,CAACpH,CAAC,CAAC,CAAC;QAElC,IAAG,CAACjB,GAAG,CAACyE,aAAa,CAAC6D,IAAI,CAAC,EAAE;QAE7B,IAAGA,IAAI,CAACC,cAAc,EAAE;UACpBD,IAAI,CAACE,cAAc,GAAGF,IAAI,CAACC,cAAc;UACzC,OAAOD,IAAI,CAACC,cAAc;QAC9B;QAEA,IAAGD,IAAI,CAACG,cAAc,EAAE;UACpBH,IAAI,CAACI,cAAc,GAAGJ,IAAI,CAACG,cAAc;UACzC,OAAOH,IAAI,CAACG,cAAc;QAC9B;MACJ;IACJ;;IAEA;IACA,IAAG/B,KAAK,CAAChE,IAAI,KAAK,aAAa,IAAIgE,KAAK,CAAChE,IAAI,KAAK,MAAM,EAAE;MACtD,IAAIiG,oBAAoB,GAAG,CAACjC,KAAK,CAACkC,UAAU,IAAI,CAAC,CAAC,EAAEC,UAAU,KAAK,KAAK;MACxE,IAAIC,oBAAoB,GAAG,CAACpC,KAAK,CAACqC,UAAU,IAAI,CAAC,CAAC,EAAEF,UAAU,KAAK,KAAK;MACxE,IAAIG,cAAc,GAAGC,eAAe,CAACvC,KAAK,CAACkC,UAAU,CAAC;MACtD,IAAIM,cAAc,GAAGD,eAAe,CAACvC,KAAK,CAACqC,UAAU,CAAC;;MAEtD;MACA;MACA,IAAIC,cAAc,KAAK,KAAK,IAAME,cAAc,KAAK,KAAM,EAAE;QACzD;QACA;;QAEA,IAAIC,OAAO,GAAGC,YAAY,CACtBJ,cAAc,EAAEE,cAAc,EAC9BP,oBAAoB,EAAEG,oBAAoB,CAC7C;QACD;QACA,IAAGK,OAAO,EAAEzC,KAAK,CAAC2C,IAAI,GAAGF,OAAO;MACpC,CAAC,MAAM,IAAG,CAACH,cAAc,IAAIE,cAAc,KAAK,CAACxC,KAAK,CAAC2C,IAAI,EAAE;QACzD;QACA3C,KAAK,CAAC2C,IAAI,GAAGL,cAAc,IAAIE,cAAc;MACjD;IACJ;;IAEA;IACA,IAAGxI,KAAK,CAACC,OAAO,CAAC+F,KAAK,CAAC4C,UAAU,CAAC,EAAE;MAChC,IAAIA,UAAU,GAAG5C,KAAK,CAAC4C,UAAU;MAEjC,KAAIrI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqI,UAAU,CAACzI,MAAM,EAAEI,CAAC,EAAE,EAAE;QACnC,IAAIsI,SAAS,GAAGD,UAAU,CAACrI,CAAC,CAAC;QAE7B,IAAG,CAACjB,GAAG,CAACyE,aAAa,CAAC8E,SAAS,CAAC,EAAE;QAElC,QAAOA,SAAS,CAAC7G,IAAI;UACjB,KAAK,QAAQ;YACT,IAAG6G,SAAS,CAACC,SAAS,EAAE;cACpBD,SAAS,CAACE,MAAM,GAAGF,SAAS,CAACC,SAAS;cACtC,OAAOD,SAAS,CAACC,SAAS;YAC9B;YAEA,IAAGD,SAAS,CAACG,QAAQ,EAAE;cACnB,IAAG,CAACH,SAAS,CAACI,aAAa,EAAE;gBACzBJ,SAAS,CAACI,aAAa,GAAGJ,SAAS,CAACG,QAAQ;cAChD;cACA,OAAOH,SAAS,CAACG,QAAQ;YAC7B;YACA;UAEJ,KAAK,SAAS;YACV;YACAH,SAAS,CAACK,MAAM,GAAGL,SAAS,CAACK,MAAM,IAAIL,SAAS,CAACM,KAAK;YAEtD,IAAGN,SAAS,CAACK,MAAM,IAAI,CAAClJ,KAAK,CAACC,OAAO,CAAC4I,SAAS,CAACK,MAAM,CAAC,EAAE;cACrD,IAAIE,UAAU,GAAGP,SAAS,CAACK,MAAM;cACjC,IAAIG,SAAS,GAAG3H,MAAM,CAACD,IAAI,CAAC2H,UAAU,CAAC;cAEvCP,SAAS,CAACK,MAAM,GAAG,EAAE;cACrB,KAAI,IAAI1I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6I,SAAS,CAAClJ,MAAM,EAAEK,CAAC,EAAE,EAAE;gBACtCqI,SAAS,CAACK,MAAM,CAACI,IAAI,CAAC;kBAClBP,MAAM,EAAEM,SAAS,CAAC7I,CAAC,CAAC;kBACpB+I,KAAK,EAAEH,UAAU,CAACC,SAAS,CAAC7I,CAAC,CAAC;gBAClC,CAAC,CAAC;cACN;YACJ;YACA;QAAM;MAElB;IACJ;;IAEA;IACA,IAAG8B,cAAc,CAAC0D,KAAK,EAAE,MAAM,CAAC,EAAE,OAAOA,KAAK,CAACwD,IAAI;IACnD,IAAG,QAAQ,IAAIxD,KAAK,EAAE;MAClB,IAAG1D,cAAc,CAAC0D,KAAK,CAACyD,MAAM,EAAE,MAAM,CAAC,EAAE,OAAOzD,KAAK,CAACyD,MAAM,CAACD,IAAI;MACjE,IAAGlH,cAAc,CAAC0D,KAAK,EAAE,QAAQ,CAAC,EAAE,OAAOA,KAAK,CAACyD,MAAM;IAC3D;;IAEA;IACA;IACAhK,KAAK,CAACqF,KAAK,CAACkB,KAAK,CAAC;;IAElB;IACA;IACA;IACA;IACA,IAAGA,KAAK,CAAC0D,QAAQ,EAAE;MACf,OAAO1D,KAAK,CAAC0D,QAAQ;MACrB,OAAO1D,KAAK,CAACE,KAAK;IACtB;IACA,IAAGF,KAAK,CAAC2D,QAAQ,EAAE;MACf,OAAO3D,KAAK,CAAC2D,QAAQ;MACrB,OAAO3D,KAAK,CAACC,KAAK;IACtB;IAEAtD,UAAU,CAACqD,KAAK,CAAC;IACjB,IAAGA,KAAK,CAACwB,QAAQ,EAAE7E,UAAU,CAACqD,KAAK,CAACwB,QAAQ,CAAC;IAC7C,IAAGxB,KAAK,CAACyD,MAAM,IAAIzD,KAAK,CAACyD,MAAM,CAACjC,QAAQ,EAAE7E,UAAU,CAACqD,KAAK,CAACyD,MAAM,CAACjC,QAAQ,CAAC;IAC3E,IAAGxB,KAAK,CAACwD,IAAI,IAAIxD,KAAK,CAACwD,IAAI,CAAChC,QAAQ,EAAE7E,UAAU,CAACqD,KAAK,CAACwD,IAAI,CAAChC,QAAQ,CAAC;IACrE,IAAGxB,KAAK,CAACnD,KAAK,EAAEF,UAAU,CAACqD,KAAK,CAACnD,KAAK,CAAC;IACvC,IAAGmD,KAAK,CAAClD,KAAK,EAAEH,UAAU,CAACqD,KAAK,CAAClD,KAAK,CAAC;EAC3C;AACJ,CAAC;AAED,SAASyF,eAAeA,CAACqB,YAAY,EAAE;EACnC,IAAG,CAACtK,GAAG,CAACyE,aAAa,CAAC6F,YAAY,CAAC,EAAE,OAAO,KAAK;EAEjD,IAAIC,OAAO,GAAGD,YAAY,CAACjB,IAAI;EAE/B,OAAOiB,YAAY,CAACjB,IAAI;EACxB,OAAOiB,YAAY,CAACzB,UAAU;EAE9B,OAAO,CAAC,OAAO0B,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,KAAK,QAAQ,KAAKC,MAAM,CAACD,OAAO,CAAC;AAC1F;AAEA,SAASnB,YAAYA,CAACqB,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAE;EAC9C;EACA,IAAGD,KAAK,IAAI,CAACC,KAAK,EAAE,OAAOH,KAAK;EAChC,IAAGG,KAAK,IAAI,CAACD,KAAK,EAAE,OAAOD,KAAK;;EAEhC;EACA;EACA;EACA,IAAG,CAACD,KAAK,CAACI,IAAI,EAAE,EAAE,OAAOH,KAAK;EAC9B,IAAG,CAACA,KAAK,CAACG,IAAI,EAAE,EAAE,OAAOJ,KAAK;EAE9B,IAAIK,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACP,KAAK,CAAC5J,MAAM,EAAE6J,KAAK,CAAC7J,MAAM,CAAC;EACjD,IAAII,CAAC;EACL,KAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6J,MAAM,EAAE7J,CAAC,EAAE,EAAE;IACxB,IAAGwJ,KAAK,CAAC3E,MAAM,CAAC7E,CAAC,CAAC,KAAKyJ,KAAK,CAAC5E,MAAM,CAAC7E,CAAC,CAAC,EAAE;EAC5C;EAEA,IAAIgK,GAAG,GAAGR,KAAK,CAAClD,MAAM,CAAC,CAAC,EAAEtG,CAAC,CAAC;EAC5B,OAAOgK,GAAG,CAACJ,IAAI,EAAE;AACrB;;AAEA;AACA;AACA,SAAS9C,iBAAiBA,CAACD,YAAY,EAAE;EACrC,IAAIoD,IAAI,GAAG,QAAQ;EACnB,IAAIC,IAAI,GAAG,QAAQ;EAEnB,IAAG,OAAOrD,YAAY,KAAK,QAAQ,EAAE;IACjC,IAAGA,YAAY,CAACsD,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAEF,IAAI,GAAG,KAAK,CAAC,KAC/C,IAAGpD,YAAY,CAACsD,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAEF,IAAI,GAAG,QAAQ;IAE9D,IAAGpD,YAAY,CAACsD,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAED,IAAI,GAAG,MAAM,CAAC,KACjD,IAAGrD,YAAY,CAACsD,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EAAED,IAAI,GAAG,OAAO;EAChE;EAEA,OAAOD,IAAI,GAAG,GAAG,GAAGC,IAAI;AAC5B;AAEA,SAASnI,cAAcA,CAACqI,KAAK,EAAEC,QAAQ,EAAE;EACrC,OAAQA,QAAQ,IAAID,KAAK,IACpB,OAAOA,KAAK,CAACC,QAAQ,CAAC,KAAK,QAAS,IACpClJ,MAAM,CAACD,IAAI,CAACkJ,KAAK,CAACC,QAAQ,CAAC,CAAC,CAACzK,MAAM,KAAK,CAAE;AACnD;;AAGA;AACAN,OAAO,CAACkH,UAAU,GAAG,UAASf,KAAK,EAAE;EACjC,IAAIzF,CAAC;EACLjB,GAAG,CAACuL,SAAS,CAAC7E,KAAK,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;EACzF,IAAGhG,KAAK,CAACC,OAAO,CAAC+F,KAAK,CAACvC,CAAC,CAAC,IAAIzD,KAAK,CAACC,OAAO,CAAC+F,KAAK,CAACvC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IACpD,IAAGuC,KAAK,CAAC8E,SAAS,EAAE,OAAO9E,KAAK,CAAC8E,SAAS,CAAC,KACtC9E,KAAK,CAAC8E,SAAS,GAAG,IAAI;EAC/B;EACA,IAAG9E,KAAK,CAAC+E,OAAO,IAAI/E,KAAK,CAACG,OAAO,EAAE;IAC/B,IAAI6E,MAAM,GAAGhF,KAAK,CAACG,OAAO;IAC1B,IAAI8E,UAAU,GAAI,aAAa,IAAID,MAAM,GACrCA,MAAM,CAACE,WAAW,GAClB,EAAEF,MAAM,CAACzE,KAAK,IAAIyE,MAAM,CAACG,SAAS,IAAIH,MAAM,CAACI,KAAK,CAAC;IACvD9L,GAAG,CAACuL,SAAS,CAAC7E,KAAK,EAAE,CAAC,qBAAqB,CAAC,CAAC;IAC7C,IAAGiF,UAAU,EAAE;MACX3L,GAAG,CAACuL,SAAS,CAAC7E,KAAK,EAAE,CAAC,eAAe,EAAE,mBAAmB,EAAE,eAAe,CAAC,CAAC;IACjF;EACJ;EACA,IAAG,OAAOA,KAAK,CAACqF,SAAS,KAAK,QAAQ,EAAE;IACpC,IAAIC,cAAc,GAAGtF,KAAK,CAACqF,SAAS,CAACE,KAAK,CAAC,GAAG,CAAC;IAC/C,KAAIhL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+K,cAAc,CAACnL,MAAM,EAAEI,CAAC,EAAE,EAAE;MACvC,IAAG+K,cAAc,CAAC/K,CAAC,CAAC,KAAK,GAAG,EAAE+K,cAAc,CAAC/K,CAAC,CAAC,GAAG,GAAG,CAAC,KACjD,IAAG+K,cAAc,CAAC/K,CAAC,CAAC,KAAK,GAAG,EAAE+K,cAAc,CAAC/K,CAAC,CAAC,GAAG,GAAG;IAC9D;IACAyF,KAAK,CAACqF,SAAS,GAAGC,cAAc,CAACE,IAAI,CAAC,GAAG,CAAC;EAC9C;AACJ,CAAC;;AAED;AACA3L,OAAO,CAAC4L,kBAAkB,GAAG,UAAS1L,EAAE,EAAE2L,YAAY,EAAE;EACpD,IAAGxM,SAAS,CAACwM,YAAY,CAAC,EAAE;IACxB,OAAO,CAACA,YAAY,CAAC;EACzB,CAAC,MAAM,IAAG,CAAC1L,KAAK,CAACC,OAAO,CAACyL,YAAY,CAAC,IAAI,CAACA,YAAY,CAACvL,MAAM,EAAE;IAC5D,OAAOJ,EAAE,CAAC+F,IAAI,CAAC6F,GAAG,CAAC,UAASC,CAAC,EAAErL,CAAC,EAAE;MAAE,OAAOA,CAAC;IAAE,CAAC,CAAC;EACpD,CAAC,MAAM,IAAGP,KAAK,CAACC,OAAO,CAACyL,YAAY,CAAC,EAAE;IACnC,IAAIG,eAAe,GAAG,EAAE;IACxB,KAAI,IAAItL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmL,YAAY,CAACvL,MAAM,EAAEI,CAAC,EAAE,EAAE;MACzC,IAAGjB,GAAG,CAACwM,OAAO,CAACJ,YAAY,CAACnL,CAAC,CAAC,EAAER,EAAE,CAAC+F,IAAI,CAAC3F,MAAM,CAAC,EAAE;QAC7C0L,eAAe,CAACvC,IAAI,CAACoC,YAAY,CAACnL,CAAC,CAAC,CAAC;MACzC,CAAC,MAAM;QACHjB,GAAG,CAACyM,IAAI,CAAC,eAAe,EAAEL,YAAY,CAACnL,CAAC,CAAC,EAAE,uCAAuC,CAAC;MACvF;IACJ;IACA,OAAOsL,eAAe;EAC1B;EAEA,OAAOH,YAAY;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7L,OAAO,CAACmM,qBAAqB,GAAG,UAASC,EAAE,EAAEC,MAAM,EAAEC,MAAM,EAAE;EACzD,IAAIC,GAAG,GAAGH,EAAE,CAACG,GAAG;EAChB,IAAIC,KAAK,GAAGJ,EAAE,CAACI,KAAK;EACpB,IAAIC,OAAO,GAAGD,KAAK,CAAClM,MAAM;EAC1B,IAAIoM,KAAK,GAAGF,KAAK,CAACC,OAAO,GAAG,CAAC,CAAC;EAE9B,IAAIE,aAAa,GAAGtN,SAAS,CAACqN,KAAK,CAAC;EAEpC,IAAGC,aAAa,IAAIN,MAAM,KAAK,IAAI,EAAE;IACjC;;IAEA;IACA,IAAIO,QAAQ,GAAGJ,KAAK,CAACK,KAAK,CAAC,CAAC,EAAEJ,OAAO,GAAG,CAAC,CAAC,CAACd,IAAI,CAAC,GAAG,CAAC;IACpD,IAAImB,IAAI,GAAGrN,GAAG,CAACsN,cAAc,CAACR,GAAG,EAAEK,QAAQ,CAAC,CAACI,GAAG,EAAE;IAClDF,IAAI,CAACG,MAAM,CAACP,KAAK,EAAE,CAAC,CAAC;;IAErB;IACA;EACJ,CAAC,MAAM,IAAGC,aAAa,IAAIP,EAAE,CAACY,GAAG,EAAE,KAAKpK,SAAS,EAAE;IAC/C;;IAEA;IACA,IAAGwJ,EAAE,CAACY,GAAG,EAAE,KAAKpK,SAAS,EAAE0J,MAAM,CAACF,EAAE,CAACc,IAAI,CAAC,GAAG,IAAI;IAEjDd,EAAE,CAACe,GAAG,CAACd,MAAM,CAAC;EAClB,CAAC,MAAM;IACH;;IAEA;IACA;IACAD,EAAE,CAACe,GAAG,CAACd,MAAM,CAAC;EAClB;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAIe,YAAY,GAAG,gCAAgC;AAEnD,SAASC,SAASA,CAACjI,IAAI,EAAE;EACrB,IAAIkI,IAAI,GAAGlI,IAAI,CAACmI,MAAM,CAACH,YAAY,CAAC;EACpC,IAAGE,IAAI,GAAG,CAAC,EAAE,OAAOlI,IAAI,CAAC4B,MAAM,CAAC,CAAC,EAAEsG,IAAI,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtN,OAAO,CAACwN,SAAS,GAAG,UAASC,IAAI,EAAErI,IAAI,EAAE;EACrC,IAAIsI,UAAU,GAAGL,SAAS,CAACjI,IAAI,CAAC;EAChC,OAAMsI,UAAU,EAAE;IACd,IAAGA,UAAU,IAAID,IAAI,EAAE,OAAO,IAAI;IAClCC,UAAU,GAAGL,SAAS,CAACK,UAAU,CAAC;EACtC;EACA,OAAO,KAAK;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,SAAS,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAC/B3N,OAAO,CAAC4N,cAAc,GAAG,UAAS1N,EAAE,EAAE2N,MAAM,EAAEC,YAAY,EAAE;EACxD,KAAI,IAAIpN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmN,MAAM,CAACvN,MAAM,EAAEI,CAAC,EAAE,EAAE;IACnC,IAAIyF,KAAK,GAAGjG,EAAE,CAAC6N,SAAS,CAACrN,CAAC,CAAC;IAC3B,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACvB,IAAIqB,EAAE,GAAGlC,YAAY,CAACI,EAAE,EAAEiG,KAAK,EAAEwH,SAAS,CAAChN,CAAC,CAAC,CAAC;;MAE9C;MACA,IAAGqB,EAAE,IAAIA,EAAE,CAACG,IAAI,KAAK,KAAK,EAAE;QACxB,IAAI6L,MAAM,GAAGhM,EAAE,CAACiM,KAAK;QACrB,IAAIC,SAAS,GAAGlM,EAAE,CAACmM,GAAG,CAACnH,MAAM,CAAC,CAAC,CAAC;QAChC,IAAGkH,SAAS,CAAClH,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,OAAO,EAAE;UACnC,IAAG8G,YAAY,CAACI,SAAS,CAAC,KAAKtL,SAAS,EAAE;UAC1CoL,MAAM,GAAGE,SAAS,GAAG,GAAG,GAAGF,MAAM;QACrC;QACA,IAAII,QAAQ,GAAGJ,MAAM,GAAG,OAAO;QAE/B,IAAGF,YAAY,CAACE,MAAM,CAAC,KAAKpL,SAAS,IAAIkL,YAAY,CAACM,QAAQ,CAAC,KAAKxL,SAAS,EAAE;UAC3EnD,GAAG,CAACsN,cAAc,CAAC7M,EAAE,CAACO,MAAM,EAAE2N,QAAQ,CAAC,CAACjB,GAAG,CAAC,IAAI,CAAC;QACrD;MACJ;IACJ;EACJ;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}