{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Registry = require('../../registry');\nvar tickText = require('../../plots/cartesian/axes').tickText;\nvar uniformText = require('./uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\nvar style = require('./style');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar attributes = require('./attributes');\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\nvar TEXTPAD = constants.TEXTPAD;\nfunction keyFunc(d) {\n  return d.id;\n}\nfunction getKeyFunc(trace) {\n  if (trace.ids) {\n    return keyFunc;\n  }\n}\nfunction dirSign(a, b) {\n  return a < b ? 1 : -1;\n}\nfunction getXY(di, xa, ya, isHorizontal) {\n  var s = [];\n  var p = [];\n  var sAxis = isHorizontal ? xa : ya;\n  var pAxis = isHorizontal ? ya : xa;\n  s[0] = sAxis.c2p(di.s0, true);\n  p[0] = pAxis.c2p(di.p0, true);\n  s[1] = sAxis.c2p(di.s1, true);\n  p[1] = pAxis.c2p(di.p1, true);\n  return isHorizontal ? [s, p] : [p, s];\n}\nfunction transition(selection, fullLayout, opts, makeOnCompleteCallback) {\n  if (!fullLayout.uniformtext.mode && hasTransition(opts)) {\n    var onComplete;\n    if (makeOnCompleteCallback) {\n      onComplete = makeOnCompleteCallback();\n    }\n    return selection.transition().duration(opts.duration).ease(opts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n  } else {\n    return selection;\n  }\n}\nfunction hasTransition(transitionOpts) {\n  return transitionOpts && transitionOpts.duration > 0;\n}\nfunction plot(gd, plotinfo, cdModule, traceLayer, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var isStatic = gd._context.staticPlot;\n  if (!opts) {\n    opts = {\n      mode: fullLayout.barmode,\n      norm: fullLayout.barmode,\n      gap: fullLayout.bargap,\n      groupgap: fullLayout.bargroupgap\n    };\n\n    // don't clear bar when this is called from waterfall or funnel\n    clearMinTextSize('bar', fullLayout);\n  }\n  var bartraces = Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var trace = cd[0].trace;\n    var isWaterfall = trace.type === 'waterfall';\n    var isFunnel = trace.type === 'funnel';\n    var isBar = trace.type === 'bar';\n    var shouldDisplayZeros = isBar || isFunnel;\n    var adjustPixel = 0;\n    if (isWaterfall && trace.connector.visible && trace.connector.mode === 'between') {\n      adjustPixel = trace.connector.line.width / 2;\n    }\n    var isHorizontal = trace.orientation === 'h';\n    var withTransition = hasTransition(opts);\n    var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n    var keyFunc = getKeyFunc(trace);\n    var bars = pointGroup.selectAll('g.point').data(Lib.identity, keyFunc);\n    bars.enter().append('g').classed('point', true);\n    bars.exit().remove();\n    bars.each(function (di, i) {\n      var bar = d3.select(this);\n\n      // now display the bar\n      // clipped xf/yf (2nd arg true): non-positive\n      // log values go off-screen by plotwidth\n      // so you see them continue if you drag the plot\n      var xy = getXY(di, xa, ya, isHorizontal);\n      var x0 = xy[0][0];\n      var x1 = xy[0][1];\n      var y0 = xy[1][0];\n      var y1 = xy[1][1];\n\n      // empty bars\n      var isBlank = (isHorizontal ? x1 - x0 : y1 - y0) === 0;\n\n      // display zeros if line.width > 0\n      if (isBlank && shouldDisplayZeros && helpers.getLineWidth(trace, di)) {\n        isBlank = false;\n      }\n\n      // skip nulls\n      if (!isBlank) {\n        isBlank = !isNumeric(x0) || !isNumeric(x1) || !isNumeric(y0) || !isNumeric(y1);\n      }\n\n      // record isBlank\n      di.isBlank = isBlank;\n\n      // for blank bars, ensure start and end positions are equal - important for smooth transitions\n      if (isBlank) {\n        if (isHorizontal) {\n          x1 = x0;\n        } else {\n          y1 = y0;\n        }\n      }\n\n      // in waterfall mode `between` we need to adjust bar end points to match the connector width\n      if (adjustPixel && !isBlank) {\n        if (isHorizontal) {\n          x0 -= dirSign(x0, x1) * adjustPixel;\n          x1 += dirSign(x0, x1) * adjustPixel;\n        } else {\n          y0 -= dirSign(y0, y1) * adjustPixel;\n          y1 += dirSign(y0, y1) * adjustPixel;\n        }\n      }\n      var lw;\n      var mc;\n      if (trace.type === 'waterfall') {\n        if (!isBlank) {\n          var cont = trace[di.dir].marker;\n          lw = cont.line.width;\n          mc = cont.color;\n        }\n      } else {\n        lw = helpers.getLineWidth(trace, di);\n        mc = di.mc || trace.marker.color;\n      }\n      function roundWithLine(v) {\n        var offset = d3.round(lw / 2 % 1, 2);\n\n        // if there are explicit gaps, don't round,\n        // it can make the gaps look crappy\n        return opts.gap === 0 && opts.groupgap === 0 ? d3.round(Math.round(v) - offset, 2) : v;\n      }\n      function expandToVisible(v, vc, hideZeroSpan) {\n        if (hideZeroSpan && v === vc) {\n          // should not expand zero span bars\n          // when start and end positions are identical\n          // i.e. for vertical when y0 === y1\n          // and for horizontal when x0 === x1\n          return v;\n        }\n\n        // if it's not in danger of disappearing entirely,\n        // round more precisely\n        return Math.abs(v - vc) >= 2 ? roundWithLine(v) :\n        // but if it's very thin, expand it so it's\n        // necessarily visible, even if it might overlap\n        // its neighbor\n        v > vc ? Math.ceil(v) : Math.floor(v);\n      }\n      if (!gd._context.staticPlot) {\n        // if bars are not fully opaque or they have a line\n        // around them, round to integer pixels, mainly for\n        // safari so we prevent overlaps from its expansive\n        // pixelation. if the bars ARE fully opaque and have\n        // no line, expand to a full pixel to make sure we\n        // can see them\n\n        var op = Color.opacity(mc);\n        var fixpx = op < 1 || lw > 0.01 ? roundWithLine : expandToVisible;\n        x0 = fixpx(x0, x1, isHorizontal);\n        x1 = fixpx(x1, x0, isHorizontal);\n        y0 = fixpx(y0, y1, !isHorizontal);\n        y1 = fixpx(y1, y0, !isHorizontal);\n      }\n      var sel = transition(Lib.ensureSingle(bar, 'path'), fullLayout, opts, makeOnCompleteCallback);\n      sel.style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke').attr('d', isNaN((x1 - x0) * (y1 - y0)) || isBlank && gd._context.staticPlot ? 'M0,0Z' : 'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z').call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n      if (!fullLayout.uniformtext.mode && withTransition) {\n        var styleFns = Drawing.makePointStyleFns(trace);\n        Drawing.singlePointStyle(di, sel, trace, styleFns, gd);\n      }\n      appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback);\n      if (plotinfo.layerClipId) {\n        Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n      }\n    });\n\n    // lastly, clip points groups of `cliponaxis !== false` traces\n    // on `plotinfo._hasClipOnAxisFalse === true` subplots\n    var hasClipOnAxisFalse = trace.cliponaxis === false;\n    Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n  });\n\n  // error bars are on the top\n  Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo, opts);\n}\nfunction appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var textPosition;\n  function appendTextNode(bar, text, font) {\n    var textSelection = Lib.ensureSingle(bar, 'text').text(text).attr({\n      class: 'bartext bartext-' + textPosition,\n      'text-anchor': 'middle',\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      'data-notex': 1\n    }).call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd);\n    return textSelection;\n  }\n\n  // get trace attributes\n  var trace = cd[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var text = getText(fullLayout, cd, i, xa, ya);\n  textPosition = getTextPosition(trace, i);\n\n  // compute text position\n  var inStackOrRelativeMode = opts.mode === 'stack' || opts.mode === 'relative';\n  var calcBar = cd[i];\n  var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n  if (!text || textPosition === 'none' || (calcBar.isBlank || x0 === x1 || y0 === y1) && (textPosition === 'auto' || textPosition === 'inside')) {\n    bar.select('text').remove();\n    return;\n  }\n  var layoutFont = fullLayout.font;\n  var barColor = style.getBarColor(cd[i], trace);\n  var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n  var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont);\n\n  // Special case: don't use the c2p(v, true) value on log size axes,\n  // so that we can get correctly inside text scaling\n  var di = bar.datum();\n  if (isHorizontal) {\n    if (xa.type === 'log' && di.s0 <= 0) {\n      if (xa.range[0] < xa.range[1]) {\n        x0 = 0;\n      } else {\n        x0 = xa._length;\n      }\n    }\n  } else {\n    if (ya.type === 'log' && di.s0 <= 0) {\n      if (ya.range[0] < ya.range[1]) {\n        y0 = ya._length;\n      } else {\n        y0 = 0;\n      }\n    }\n  }\n\n  // padding excluded\n  var barWidth = Math.abs(x1 - x0) - 2 * TEXTPAD;\n  var barHeight = Math.abs(y1 - y0) - 2 * TEXTPAD;\n  var textSelection;\n  var textBB;\n  var textWidth;\n  var textHeight;\n  var font;\n  if (textPosition === 'outside') {\n    if (!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n  }\n  if (textPosition === 'auto') {\n    if (isOutmostBar) {\n      // draw text using insideTextFont and check if it fits inside bar\n      textPosition = 'inside';\n      font = Lib.ensureUniformFontSize(gd, insideTextFont);\n      textSelection = appendTextNode(bar, text, font);\n      textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n      var textHasSize = textWidth > 0 && textHeight > 0;\n      var fitsInside = textWidth <= barWidth && textHeight <= barHeight;\n      var fitsInsideIfRotated = textWidth <= barHeight && textHeight <= barWidth;\n      var fitsInsideIfShrunk = isHorizontal ? barWidth >= textWidth * (barHeight / textHeight) : barHeight >= textHeight * (barWidth / textWidth);\n      if (textHasSize && (fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk)) {\n        textPosition = 'inside';\n      } else {\n        textPosition = 'outside';\n        textSelection.remove();\n        textSelection = null;\n      }\n    } else {\n      textPosition = 'inside';\n    }\n  }\n  if (!textSelection) {\n    font = Lib.ensureUniformFontSize(gd, textPosition === 'outside' ? outsideTextFont : insideTextFont);\n    textSelection = appendTextNode(bar, text, font);\n    var currentTransform = textSelection.attr('transform');\n    textSelection.attr('transform', '');\n    textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n    textSelection.attr('transform', currentTransform);\n    if (textWidth <= 0 || textHeight <= 0) {\n      textSelection.remove();\n      return;\n    }\n  }\n  var angle = trace.textangle;\n\n  // compute text transform\n  var transform, constrained;\n  if (textPosition === 'outside') {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'outside';\n    transform = toMoveOutsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: angle\n    });\n  } else {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'inside';\n    transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: angle,\n      anchor: trace.insidetextanchor\n    });\n  }\n  transform.fontSize = font.size;\n  recordMinTextSize(trace.type === 'histogram' ? 'bar' : trace.type, transform, fullLayout);\n  calcBar.transform = transform;\n  var s = transition(textSelection, fullLayout, opts, makeOnCompleteCallback);\n  Lib.setTransormAndDisplay(s, transform);\n}\nfunction getRotateFromAngle(angle) {\n  return angle === 'auto' ? 0 : angle;\n}\nfunction getRotatedTextSize(textBB, rotate) {\n  var a = Math.PI / 180 * rotate;\n  var absSin = Math.abs(Math.sin(a));\n  var absCos = Math.abs(Math.cos(a));\n  return {\n    x: textBB.width * absCos + textBB.height * absSin,\n    y: textBB.width * absSin + textBB.height * absCos\n  };\n}\nfunction toMoveInsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var anchor = opts.anchor || 'end';\n  var isEnd = anchor === 'end';\n  var isStart = anchor === 'start';\n  var leftToRight = opts.leftToRight || 0; // left: -1, center: 0, right: 1\n  var toRight = (leftToRight + 1) / 2;\n  var toLeft = 1 - toRight;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0);\n\n  // compute remaining space\n  var textpad = lx > 2 * TEXTPAD && ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  lx -= 2 * textpad;\n  ly -= 2 * textpad;\n  var rotate = getRotateFromAngle(angle);\n  if (angle === 'auto' && !(textWidth <= lx && textHeight <= ly) && (textWidth > lx || textHeight > ly) && (!(textWidth > ly || textHeight > lx) || textWidth < textHeight !== lx < ly)) {\n    rotate += 90;\n  }\n  var t = getRotatedTextSize(textBB, rotate);\n  var scale = 1;\n  if (constrained) {\n    scale = Math.min(1, lx / t.x, ly / t.y);\n  }\n\n  // compute text and target positions\n  var textX = textBB.left * toLeft + textBB.right * toRight;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var targetX = (x0 + TEXTPAD) * toLeft + (x1 - TEXTPAD) * toRight;\n  var targetY = (y0 + y1) / 2;\n  var anchorX = 0;\n  var anchorY = 0;\n  if (isStart || isEnd) {\n    var extrapad = (isHorizontal ? t.x : t.y) / 2;\n    var dir = isHorizontal ? dirSign(x0, x1) : dirSign(y0, y1);\n    if (isHorizontal) {\n      if (isStart) {\n        targetX = x0 + dir * textpad;\n        anchorX = -dir * extrapad;\n      } else {\n        targetX = x1 - dir * textpad;\n        anchorX = dir * extrapad;\n      }\n    } else {\n      if (isStart) {\n        targetY = y0 + dir * textpad;\n        anchorY = -dir * extrapad;\n      } else {\n        targetY = y1 - dir * textpad;\n        anchorY = dir * extrapad;\n      }\n    }\n  }\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    scale: scale,\n    rotate: rotate\n  };\n}\nfunction toMoveOutsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0);\n  var textpad;\n  // Keep the padding so the text doesn't sit right against\n  // the bars, but don't factor it into barWidth\n  if (isHorizontal) {\n    textpad = ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  } else {\n    textpad = lx > 2 * TEXTPAD ? TEXTPAD : 0;\n  }\n\n  // compute rotate and scale\n  var scale = 1;\n  if (constrained) {\n    scale = isHorizontal ? Math.min(1, ly / textHeight) : Math.min(1, lx / textWidth);\n  }\n  var rotate = getRotateFromAngle(angle);\n  var t = getRotatedTextSize(textBB, rotate);\n\n  // compute text and target positions\n  var extrapad = (isHorizontal ? t.x : t.y) / 2;\n  var textX = (textBB.left + textBB.right) / 2;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var targetX = (x0 + x1) / 2;\n  var targetY = (y0 + y1) / 2;\n  var anchorX = 0;\n  var anchorY = 0;\n  var dir = isHorizontal ? dirSign(x1, x0) : dirSign(y0, y1);\n  if (isHorizontal) {\n    targetX = x1 - dir * textpad;\n    anchorX = dir * extrapad;\n  } else {\n    targetY = y1 + dir * textpad;\n    anchorY = -dir * extrapad;\n  }\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    scale: scale,\n    rotate: rotate\n  };\n}\nfunction getText(fullLayout, cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var texttemplate = trace.texttemplate;\n  var value;\n  if (texttemplate) {\n    value = calcTexttemplate(fullLayout, cd, index, xa, ya);\n  } else if (trace.textinfo) {\n    value = calcTextinfo(cd, index, xa, ya);\n  } else {\n    value = helpers.getValue(trace.text, index);\n  }\n  return helpers.coerceString(attributeText, value);\n}\nfunction getTextPosition(trace, index) {\n  var value = helpers.getValue(trace.textposition, index);\n  return helpers.coerceEnumerated(attributeTextPosition, value);\n}\nfunction calcTexttemplate(fullLayout, cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var texttemplate = Lib.castOption(trace, index, 'texttemplate');\n  if (!texttemplate) return '';\n  var isHistogram = trace.type === 'histogram';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n  var isHorizontal = trace.orientation === 'h';\n  var pLetter, pAxis;\n  var vLetter, vAxis;\n  if (isHorizontal) {\n    pLetter = 'y';\n    pAxis = ya;\n    vLetter = 'x';\n    vAxis = xa;\n  } else {\n    pLetter = 'x';\n    pAxis = xa;\n    vLetter = 'y';\n    vAxis = ya;\n  }\n  function formatLabel(u) {\n    return tickText(pAxis, pAxis.c2l(u), true).text;\n  }\n  function formatNumber(v) {\n    return tickText(vAxis, vAxis.c2l(v), true).text;\n  }\n  var cdi = cd[index];\n  var obj = {};\n  obj.label = cdi.p;\n  obj.labelLabel = obj[pLetter + 'Label'] = formatLabel(cdi.p);\n  var tx = Lib.castOption(trace, cdi.i, 'text');\n  if (tx === 0 || tx) obj.text = tx;\n  obj.value = cdi.s;\n  obj.valueLabel = obj[vLetter + 'Label'] = formatNumber(cdi.s);\n  var pt = {};\n  appendArrayPointValue(pt, trace, cdi.i);\n  if (isHistogram || pt.x === undefined) pt.x = isHorizontal ? obj.value : obj.label;\n  if (isHistogram || pt.y === undefined) pt.y = isHorizontal ? obj.label : obj.value;\n  if (isHistogram || pt.xLabel === undefined) pt.xLabel = isHorizontal ? obj.valueLabel : obj.labelLabel;\n  if (isHistogram || pt.yLabel === undefined) pt.yLabel = isHorizontal ? obj.labelLabel : obj.valueLabel;\n  if (isWaterfall) {\n    obj.delta = +cdi.rawS || cdi.s;\n    obj.deltaLabel = formatNumber(obj.delta);\n    obj.final = cdi.v;\n    obj.finalLabel = formatNumber(obj.final);\n    obj.initial = obj.final - obj.delta;\n    obj.initialLabel = formatNumber(obj.initial);\n  }\n  if (isFunnel) {\n    obj.value = cdi.s;\n    obj.valueLabel = formatNumber(obj.value);\n    obj.percentInitial = cdi.begR;\n    obj.percentInitialLabel = Lib.formatPercent(cdi.begR);\n    obj.percentPrevious = cdi.difR;\n    obj.percentPreviousLabel = Lib.formatPercent(cdi.difR);\n    obj.percentTotal = cdi.sumR;\n    obj.percenTotalLabel = Lib.formatPercent(cdi.sumR);\n  }\n  var customdata = Lib.castOption(trace, cdi.i, 'customdata');\n  if (customdata) obj.customdata = customdata;\n  return Lib.texttemplateString(texttemplate, obj, fullLayout._d3locale, pt, obj, trace._meta || {});\n}\nfunction calcTextinfo(cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n  function formatLabel(u) {\n    var pAxis = isHorizontal ? ya : xa;\n    return tickText(pAxis, u, true).text;\n  }\n  function formatNumber(v) {\n    var sAxis = isHorizontal ? xa : ya;\n    return tickText(sAxis, +v, true).text;\n  }\n  var textinfo = trace.textinfo;\n  var cdi = cd[index];\n  var parts = textinfo.split('+');\n  var text = [];\n  var tx;\n  var hasFlag = function (flag) {\n    return parts.indexOf(flag) !== -1;\n  };\n  if (hasFlag('label')) {\n    text.push(formatLabel(cd[index].p));\n  }\n  if (hasFlag('text')) {\n    tx = Lib.castOption(trace, cdi.i, 'text');\n    if (tx === 0 || tx) text.push(tx);\n  }\n  if (isWaterfall) {\n    var delta = +cdi.rawS || cdi.s;\n    var final = cdi.v;\n    var initial = final - delta;\n    if (hasFlag('initial')) text.push(formatNumber(initial));\n    if (hasFlag('delta')) text.push(formatNumber(delta));\n    if (hasFlag('final')) text.push(formatNumber(final));\n  }\n  if (isFunnel) {\n    if (hasFlag('value')) text.push(formatNumber(cdi.s));\n    var nPercent = 0;\n    if (hasFlag('percent initial')) nPercent++;\n    if (hasFlag('percent previous')) nPercent++;\n    if (hasFlag('percent total')) nPercent++;\n    var hasMultiplePercents = nPercent > 1;\n    if (hasFlag('percent initial')) {\n      tx = Lib.formatPercent(cdi.begR);\n      if (hasMultiplePercents) tx += ' of initial';\n      text.push(tx);\n    }\n    if (hasFlag('percent previous')) {\n      tx = Lib.formatPercent(cdi.difR);\n      if (hasMultiplePercents) tx += ' of previous';\n      text.push(tx);\n    }\n    if (hasFlag('percent total')) {\n      tx = Lib.formatPercent(cdi.sumR);\n      if (hasMultiplePercents) tx += ' of total';\n      text.push(tx);\n    }\n  }\n  return text.join('<br>');\n}\nmodule.exports = {\n  plot: plot,\n  toMoveInsideBar: toMoveInsideBar\n};","map":{"version":3,"names":["d3","require","isNumeric","Lib","svgTextUtils","Color","Drawing","Registry","tickText","uniformText","recordMinTextSize","clearMinTextSize","style","helpers","constants","attributes","attributeText","text","attributeTextPosition","textposition","appendArrayPointValue","TEXTPAD","keyFunc","d","id","getKeyFunc","trace","ids","dirSign","a","b","getXY","di","xa","ya","isHorizontal","s","p","sAxis","pAxis","c2p","s0","p0","s1","p1","transition","selection","fullLayout","opts","makeOnCompleteCallback","uniformtext","mode","hasTransition","onComplete","duration","ease","easing","each","transitionOpts","plot","gd","plotinfo","cdModule","traceLayer","xaxis","yaxis","_fullLayout","isStatic","_context","staticPlot","barmode","norm","gap","bargap","groupgap","bargroupgap","bartraces","makeTraceGroups","cd","plotGroup","select","isWaterfall","type","isFunnel","isBar","shouldDisplayZeros","adjustPixel","connector","visible","line","width","orientation","withTransition","pointGroup","ensureSingle","bars","selectAll","data","identity","enter","append","classed","exit","remove","i","bar","xy","x0","x1","y0","y1","isBlank","getLineWidth","lw","mc","cont","dir","marker","color","roundWithLine","v","offset","round","Math","expandToVisible","vc","hideZeroSpan","abs","ceil","floor","op","opacity","fixpx","sel","attr","isNaN","call","setClipUrl","layerClipId","styleFns","makePointStyleFns","singlePointStyle","appendBarText","hideOutsideRangePoint","xcalendar","ycalendar","hasClipOnAxisFalse","cliponaxis","getComponentMethod","textPosition","appendTextNode","font","textSelection","class","convertToTspans","getText","getTextPosition","inStackOrRelativeMode","calcBar","isOutmostBar","_outmost","layoutFont","barColor","getBarColor","insideTextFont","getInsideTextFont","outsideTextFont","getOutsideTextFont","datum","range","_length","barWidth","barHeight","textBB","textWidth","textHeight","hasB","ensureUniformFontSize","bBox","node","height","textHasSize","fitsInside","fitsInsideIfRotated","fitsInsideIfShrunk","currentTransform","angle","textangle","transform","constrained","constraintext","toMoveOutsideBar","toMoveInsideBar","anchor","insidetextanchor","fontSize","size","setTransormAndDisplay","getRotateFromAngle","getRotatedTextSize","rotate","PI","absSin","sin","absCos","cos","x","y","isEnd","isStart","leftToRight","toRight","toLeft","lx","ly","textpad","t","scale","min","textX","left","right","textY","top","bottom","targetX","targetY","anchorX","anchorY","extrapad","index","texttemplate","value","calcTexttemplate","textinfo","calcTextinfo","getValue","coerceString","coerceEnumerated","castOption","isHistogram","pLetter","vLetter","vAxis","formatLabel","u","c2l","formatNumber","cdi","obj","label","labelLabel","tx","valueLabel","pt","undefined","xLabel","yLabel","delta","rawS","deltaLabel","final","finalLabel","initial","initialLabel","percentInitial","begR","percentInitialLabel","formatPercent","percentPrevious","difR","percentPreviousLabel","percentTotal","sumR","percenTotalLabel","customdata","texttemplateString","_d3locale","_meta","parts","split","hasFlag","flag","indexOf","push","nPercent","hasMultiplePercents","join","module","exports"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/traces/bar/plot.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Registry = require('../../registry');\nvar tickText = require('../../plots/cartesian/axes').tickText;\n\nvar uniformText = require('./uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar style = require('./style');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar attributes = require('./attributes');\n\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar TEXTPAD = constants.TEXTPAD;\n\nfunction keyFunc(d) {return d.id;}\nfunction getKeyFunc(trace) {\n    if(trace.ids) {\n        return keyFunc;\n    }\n}\n\nfunction dirSign(a, b) {\n    return (a < b) ? 1 : -1;\n}\n\nfunction getXY(di, xa, ya, isHorizontal) {\n    var s = [];\n    var p = [];\n\n    var sAxis = isHorizontal ? xa : ya;\n    var pAxis = isHorizontal ? ya : xa;\n\n    s[0] = sAxis.c2p(di.s0, true);\n    p[0] = pAxis.c2p(di.p0, true);\n\n    s[1] = sAxis.c2p(di.s1, true);\n    p[1] = pAxis.c2p(di.p1, true);\n\n    return isHorizontal ? [s, p] : [p, s];\n}\n\nfunction transition(selection, fullLayout, opts, makeOnCompleteCallback) {\n    if(!fullLayout.uniformtext.mode && hasTransition(opts)) {\n        var onComplete;\n        if(makeOnCompleteCallback) {\n            onComplete = makeOnCompleteCallback();\n        }\n        return selection\n          .transition()\n          .duration(opts.duration)\n          .ease(opts.easing)\n          .each('end', function() { onComplete && onComplete(); })\n          .each('interrupt', function() { onComplete && onComplete(); });\n    } else {\n        return selection;\n    }\n}\n\nfunction hasTransition(transitionOpts) {\n    return transitionOpts && transitionOpts.duration > 0;\n}\n\nfunction plot(gd, plotinfo, cdModule, traceLayer, opts, makeOnCompleteCallback) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var fullLayout = gd._fullLayout;\n    var isStatic = gd._context.staticPlot;\n\n    if(!opts) {\n        opts = {\n            mode: fullLayout.barmode,\n            norm: fullLayout.barmode,\n            gap: fullLayout.bargap,\n            groupgap: fullLayout.bargroupgap\n        };\n\n        // don't clear bar when this is called from waterfall or funnel\n        clearMinTextSize('bar', fullLayout);\n    }\n\n    var bartraces = Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var trace = cd[0].trace;\n        var isWaterfall = (trace.type === 'waterfall');\n        var isFunnel = (trace.type === 'funnel');\n        var isBar = (trace.type === 'bar');\n        var shouldDisplayZeros = (isBar || isFunnel);\n\n        var adjustPixel = 0;\n        if(isWaterfall && trace.connector.visible && trace.connector.mode === 'between') {\n            adjustPixel = trace.connector.line.width / 2;\n        }\n\n        var isHorizontal = (trace.orientation === 'h');\n        var withTransition = hasTransition(opts);\n\n        var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n\n        var keyFunc = getKeyFunc(trace);\n        var bars = pointGroup.selectAll('g.point').data(Lib.identity, keyFunc);\n\n        bars.enter().append('g')\n            .classed('point', true);\n\n        bars.exit().remove();\n\n        bars.each(function(di, i) {\n            var bar = d3.select(this);\n\n            // now display the bar\n            // clipped xf/yf (2nd arg true): non-positive\n            // log values go off-screen by plotwidth\n            // so you see them continue if you drag the plot\n            var xy = getXY(di, xa, ya, isHorizontal);\n\n            var x0 = xy[0][0];\n            var x1 = xy[0][1];\n            var y0 = xy[1][0];\n            var y1 = xy[1][1];\n\n            // empty bars\n            var isBlank = (isHorizontal ? x1 - x0 : y1 - y0) === 0;\n\n            // display zeros if line.width > 0\n            if(isBlank && shouldDisplayZeros && helpers.getLineWidth(trace, di)) {\n                isBlank = false;\n            }\n\n            // skip nulls\n            if(!isBlank) {\n                isBlank = (\n                    !isNumeric(x0) ||\n                    !isNumeric(x1) ||\n                    !isNumeric(y0) ||\n                    !isNumeric(y1)\n                );\n            }\n\n            // record isBlank\n            di.isBlank = isBlank;\n\n            // for blank bars, ensure start and end positions are equal - important for smooth transitions\n            if(isBlank) {\n                if(isHorizontal) {\n                    x1 = x0;\n                } else {\n                    y1 = y0;\n                }\n            }\n\n            // in waterfall mode `between` we need to adjust bar end points to match the connector width\n            if(adjustPixel && !isBlank) {\n                if(isHorizontal) {\n                    x0 -= dirSign(x0, x1) * adjustPixel;\n                    x1 += dirSign(x0, x1) * adjustPixel;\n                } else {\n                    y0 -= dirSign(y0, y1) * adjustPixel;\n                    y1 += dirSign(y0, y1) * adjustPixel;\n                }\n            }\n\n            var lw;\n            var mc;\n\n            if(trace.type === 'waterfall') {\n                if(!isBlank) {\n                    var cont = trace[di.dir].marker;\n                    lw = cont.line.width;\n                    mc = cont.color;\n                }\n            } else {\n                lw = helpers.getLineWidth(trace, di);\n                mc = di.mc || trace.marker.color;\n            }\n\n            function roundWithLine(v) {\n                var offset = d3.round((lw / 2) % 1, 2);\n\n                // if there are explicit gaps, don't round,\n                // it can make the gaps look crappy\n                return (opts.gap === 0 && opts.groupgap === 0) ?\n                    d3.round(Math.round(v) - offset, 2) : v;\n            }\n\n            function expandToVisible(v, vc, hideZeroSpan) {\n                if(hideZeroSpan && v === vc) {\n                    // should not expand zero span bars\n                    // when start and end positions are identical\n                    // i.e. for vertical when y0 === y1\n                    // and for horizontal when x0 === x1\n                    return v;\n                }\n\n                // if it's not in danger of disappearing entirely,\n                // round more precisely\n                return Math.abs(v - vc) >= 2 ? roundWithLine(v) :\n                // but if it's very thin, expand it so it's\n                // necessarily visible, even if it might overlap\n                // its neighbor\n                (v > vc ? Math.ceil(v) : Math.floor(v));\n            }\n\n            if(!gd._context.staticPlot) {\n                // if bars are not fully opaque or they have a line\n                // around them, round to integer pixels, mainly for\n                // safari so we prevent overlaps from its expansive\n                // pixelation. if the bars ARE fully opaque and have\n                // no line, expand to a full pixel to make sure we\n                // can see them\n\n                var op = Color.opacity(mc);\n                var fixpx = (op < 1 || lw > 0.01) ? roundWithLine : expandToVisible;\n\n                x0 = fixpx(x0, x1, isHorizontal);\n                x1 = fixpx(x1, x0, isHorizontal);\n                y0 = fixpx(y0, y1, !isHorizontal);\n                y1 = fixpx(y1, y0, !isHorizontal);\n            }\n\n            var sel = transition(Lib.ensureSingle(bar, 'path'), fullLayout, opts, makeOnCompleteCallback);\n            sel\n                .style('vector-effect', isStatic ? 'none' : 'non-scaling-stroke')\n                .attr('d', (isNaN((x1 - x0) * (y1 - y0)) || (isBlank && gd._context.staticPlot)) ? 'M0,0Z' : 'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z')\n                .call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n\n            if(!fullLayout.uniformtext.mode && withTransition) {\n                var styleFns = Drawing.makePointStyleFns(trace);\n                Drawing.singlePointStyle(di, sel, trace, styleFns, gd);\n            }\n\n            appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback);\n\n            if(plotinfo.layerClipId) {\n                Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n            }\n        });\n\n        // lastly, clip points groups of `cliponaxis !== false` traces\n        // on `plotinfo._hasClipOnAxisFalse === true` subplots\n        var hasClipOnAxisFalse = trace.cliponaxis === false;\n        Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n    });\n\n    // error bars are on the top\n    Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo, opts);\n}\n\nfunction appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var fullLayout = gd._fullLayout;\n    var textPosition;\n\n    function appendTextNode(bar, text, font) {\n        var textSelection = Lib.ensureSingle(bar, 'text')\n            .text(text)\n            .attr({\n                class: 'bartext bartext-' + textPosition,\n                'text-anchor': 'middle',\n                // prohibit tex interpretation until we can handle\n                // tex and regular text together\n                'data-notex': 1\n            })\n            .call(Drawing.font, font)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        return textSelection;\n    }\n\n    // get trace attributes\n    var trace = cd[0].trace;\n    var isHorizontal = (trace.orientation === 'h');\n\n    var text = getText(fullLayout, cd, i, xa, ya);\n    textPosition = getTextPosition(trace, i);\n\n    // compute text position\n    var inStackOrRelativeMode =\n        opts.mode === 'stack' ||\n        opts.mode === 'relative';\n\n    var calcBar = cd[i];\n    var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n\n    if(!text ||\n        textPosition === 'none' ||\n        ((calcBar.isBlank || x0 === x1 || y0 === y1) && (\n            textPosition === 'auto' ||\n            textPosition === 'inside'))) {\n        bar.select('text').remove();\n        return;\n    }\n\n    var layoutFont = fullLayout.font;\n    var barColor = style.getBarColor(cd[i], trace);\n    var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n    var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont);\n\n    // Special case: don't use the c2p(v, true) value on log size axes,\n    // so that we can get correctly inside text scaling\n    var di = bar.datum();\n    if(isHorizontal) {\n        if(xa.type === 'log' && di.s0 <= 0) {\n            if(xa.range[0] < xa.range[1]) {\n                x0 = 0;\n            } else {\n                x0 = xa._length;\n            }\n        }\n    } else {\n        if(ya.type === 'log' && di.s0 <= 0) {\n            if(ya.range[0] < ya.range[1]) {\n                y0 = ya._length;\n            } else {\n                y0 = 0;\n            }\n        }\n    }\n\n    // padding excluded\n    var barWidth = Math.abs(x1 - x0) - 2 * TEXTPAD;\n    var barHeight = Math.abs(y1 - y0) - 2 * TEXTPAD;\n\n    var textSelection;\n    var textBB;\n    var textWidth;\n    var textHeight;\n    var font;\n\n    if(textPosition === 'outside') {\n        if(!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n    }\n\n    if(textPosition === 'auto') {\n        if(isOutmostBar) {\n            // draw text using insideTextFont and check if it fits inside bar\n            textPosition = 'inside';\n\n            font = Lib.ensureUniformFontSize(gd, insideTextFont);\n\n            textSelection = appendTextNode(bar, text, font);\n\n            textBB = Drawing.bBox(textSelection.node()),\n            textWidth = textBB.width,\n            textHeight = textBB.height;\n\n            var textHasSize = (textWidth > 0 && textHeight > 0);\n            var fitsInside = (textWidth <= barWidth && textHeight <= barHeight);\n            var fitsInsideIfRotated = (textWidth <= barHeight && textHeight <= barWidth);\n            var fitsInsideIfShrunk = (isHorizontal) ?\n                (barWidth >= textWidth * (barHeight / textHeight)) :\n                (barHeight >= textHeight * (barWidth / textWidth));\n\n            if(textHasSize && (\n                fitsInside ||\n                fitsInsideIfRotated ||\n                fitsInsideIfShrunk)\n            ) {\n                textPosition = 'inside';\n            } else {\n                textPosition = 'outside';\n                textSelection.remove();\n                textSelection = null;\n            }\n        } else {\n            textPosition = 'inside';\n        }\n    }\n\n    if(!textSelection) {\n        font = Lib.ensureUniformFontSize(gd, (textPosition === 'outside') ? outsideTextFont : insideTextFont);\n\n        textSelection = appendTextNode(bar, text, font);\n\n        var currentTransform = textSelection.attr('transform');\n        textSelection.attr('transform', '');\n        textBB = Drawing.bBox(textSelection.node()),\n        textWidth = textBB.width,\n        textHeight = textBB.height;\n        textSelection.attr('transform', currentTransform);\n\n        if(textWidth <= 0 || textHeight <= 0) {\n            textSelection.remove();\n            return;\n        }\n    }\n\n    var angle = trace.textangle;\n\n    // compute text transform\n    var transform, constrained;\n    if(textPosition === 'outside') {\n        constrained =\n            trace.constraintext === 'both' ||\n            trace.constraintext === 'outside';\n\n        transform = toMoveOutsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: isHorizontal,\n            constrained: constrained,\n            angle: angle\n        });\n    } else {\n        constrained =\n            trace.constraintext === 'both' ||\n            trace.constraintext === 'inside';\n\n        transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: isHorizontal,\n            constrained: constrained,\n            angle: angle,\n            anchor: trace.insidetextanchor\n        });\n    }\n\n    transform.fontSize = font.size;\n    recordMinTextSize(trace.type === 'histogram' ? 'bar' : trace.type, transform, fullLayout);\n    calcBar.transform = transform;\n\n    var s = transition(textSelection, fullLayout, opts, makeOnCompleteCallback);\n    Lib.setTransormAndDisplay(s, transform);\n}\n\nfunction getRotateFromAngle(angle) {\n    return (angle === 'auto') ? 0 : angle;\n}\n\nfunction getRotatedTextSize(textBB, rotate) {\n    var a = Math.PI / 180 * rotate;\n    var absSin = Math.abs(Math.sin(a));\n    var absCos = Math.abs(Math.cos(a));\n\n    return {\n        x: textBB.width * absCos + textBB.height * absSin,\n        y: textBB.width * absSin + textBB.height * absCos\n    };\n}\n\nfunction toMoveInsideBar(x0, x1, y0, y1, textBB, opts) {\n    var isHorizontal = !!opts.isHorizontal;\n    var constrained = !!opts.constrained;\n    var angle = opts.angle || 0;\n    var anchor = opts.anchor || 'end';\n    var isEnd = anchor === 'end';\n    var isStart = anchor === 'start';\n    var leftToRight = opts.leftToRight || 0; // left: -1, center: 0, right: 1\n    var toRight = (leftToRight + 1) / 2;\n    var toLeft = 1 - toRight;\n\n    var textWidth = textBB.width;\n    var textHeight = textBB.height;\n    var lx = Math.abs(x1 - x0);\n    var ly = Math.abs(y1 - y0);\n\n    // compute remaining space\n    var textpad = (\n        lx > (2 * TEXTPAD) &&\n        ly > (2 * TEXTPAD)\n    ) ? TEXTPAD : 0;\n\n    lx -= 2 * textpad;\n    ly -= 2 * textpad;\n\n    var rotate = getRotateFromAngle(angle);\n    if((angle === 'auto') &&\n        !(textWidth <= lx && textHeight <= ly) &&\n        (textWidth > lx || textHeight > ly) && (\n        !(textWidth > ly || textHeight > lx) ||\n        ((textWidth < textHeight) !== (lx < ly))\n    )) {\n        rotate += 90;\n    }\n\n    var t = getRotatedTextSize(textBB, rotate);\n\n    var scale = 1;\n    if(constrained) {\n        scale = Math.min(\n            1,\n            lx / t.x,\n            ly / t.y\n        );\n    }\n\n    // compute text and target positions\n    var textX = (\n        textBB.left * toLeft +\n        textBB.right * toRight\n    );\n    var textY = (textBB.top + textBB.bottom) / 2;\n    var targetX = (\n        (x0 + TEXTPAD) * toLeft +\n        (x1 - TEXTPAD) * toRight\n    );\n    var targetY = (y0 + y1) / 2;\n    var anchorX = 0;\n    var anchorY = 0;\n    if(isStart || isEnd) {\n        var extrapad = (isHorizontal ? t.x : t.y) / 2;\n        var dir = isHorizontal ? dirSign(x0, x1) : dirSign(y0, y1);\n\n        if(isHorizontal) {\n            if(isStart) {\n                targetX = x0 + dir * textpad;\n                anchorX = -dir * extrapad;\n            } else {\n                targetX = x1 - dir * textpad;\n                anchorX = dir * extrapad;\n            }\n        } else {\n            if(isStart) {\n                targetY = y0 + dir * textpad;\n                anchorY = -dir * extrapad;\n            } else {\n                targetY = y1 - dir * textpad;\n                anchorY = dir * extrapad;\n            }\n        }\n    }\n\n    return {\n        textX: textX,\n        textY: textY,\n        targetX: targetX,\n        targetY: targetY,\n        anchorX: anchorX,\n        anchorY: anchorY,\n        scale: scale,\n        rotate: rotate\n    };\n}\n\nfunction toMoveOutsideBar(x0, x1, y0, y1, textBB, opts) {\n    var isHorizontal = !!opts.isHorizontal;\n    var constrained = !!opts.constrained;\n    var angle = opts.angle || 0;\n\n    var textWidth = textBB.width;\n    var textHeight = textBB.height;\n    var lx = Math.abs(x1 - x0);\n    var ly = Math.abs(y1 - y0);\n\n    var textpad;\n    // Keep the padding so the text doesn't sit right against\n    // the bars, but don't factor it into barWidth\n    if(isHorizontal) {\n        textpad = (ly > 2 * TEXTPAD) ? TEXTPAD : 0;\n    } else {\n        textpad = (lx > 2 * TEXTPAD) ? TEXTPAD : 0;\n    }\n\n    // compute rotate and scale\n    var scale = 1;\n    if(constrained) {\n        scale = (isHorizontal) ?\n            Math.min(1, ly / textHeight) :\n            Math.min(1, lx / textWidth);\n    }\n\n    var rotate = getRotateFromAngle(angle);\n    var t = getRotatedTextSize(textBB, rotate);\n\n    // compute text and target positions\n    var extrapad = (isHorizontal ? t.x : t.y) / 2;\n    var textX = (textBB.left + textBB.right) / 2;\n    var textY = (textBB.top + textBB.bottom) / 2;\n    var targetX = (x0 + x1) / 2;\n    var targetY = (y0 + y1) / 2;\n    var anchorX = 0;\n    var anchorY = 0;\n\n    var dir = isHorizontal ? dirSign(x1, x0) : dirSign(y0, y1);\n    if(isHorizontal) {\n        targetX = x1 - dir * textpad;\n        anchorX = dir * extrapad;\n    } else {\n        targetY = y1 + dir * textpad;\n        anchorY = -dir * extrapad;\n    }\n\n    return {\n        textX: textX,\n        textY: textY,\n        targetX: targetX,\n        targetY: targetY,\n        anchorX: anchorX,\n        anchorY: anchorY,\n        scale: scale,\n        rotate: rotate\n    };\n}\n\nfunction getText(fullLayout, cd, index, xa, ya) {\n    var trace = cd[0].trace;\n    var texttemplate = trace.texttemplate;\n\n    var value;\n    if(texttemplate) {\n        value = calcTexttemplate(fullLayout, cd, index, xa, ya);\n    } else if(trace.textinfo) {\n        value = calcTextinfo(cd, index, xa, ya);\n    } else {\n        value = helpers.getValue(trace.text, index);\n    }\n\n    return helpers.coerceString(attributeText, value);\n}\n\nfunction getTextPosition(trace, index) {\n    var value = helpers.getValue(trace.textposition, index);\n    return helpers.coerceEnumerated(attributeTextPosition, value);\n}\n\nfunction calcTexttemplate(fullLayout, cd, index, xa, ya) {\n    var trace = cd[0].trace;\n    var texttemplate = Lib.castOption(trace, index, 'texttemplate');\n    if(!texttemplate) return '';\n    var isHistogram = (trace.type === 'histogram');\n    var isWaterfall = (trace.type === 'waterfall');\n    var isFunnel = (trace.type === 'funnel');\n    var isHorizontal = trace.orientation === 'h';\n\n    var pLetter, pAxis;\n    var vLetter, vAxis;\n    if(isHorizontal) {\n        pLetter = 'y';\n        pAxis = ya;\n        vLetter = 'x';\n        vAxis = xa;\n    } else {\n        pLetter = 'x';\n        pAxis = xa;\n        vLetter = 'y';\n        vAxis = ya;\n    }\n\n    function formatLabel(u) {\n        return tickText(pAxis, pAxis.c2l(u), true).text;\n    }\n\n    function formatNumber(v) {\n        return tickText(vAxis, vAxis.c2l(v), true).text;\n    }\n\n    var cdi = cd[index];\n    var obj = {};\n\n    obj.label = cdi.p;\n    obj.labelLabel = obj[pLetter + 'Label'] = formatLabel(cdi.p);\n\n    var tx = Lib.castOption(trace, cdi.i, 'text');\n    if(tx === 0 || tx) obj.text = tx;\n\n    obj.value = cdi.s;\n    obj.valueLabel = obj[vLetter + 'Label'] = formatNumber(cdi.s);\n\n    var pt = {};\n    appendArrayPointValue(pt, trace, cdi.i);\n\n    if(isHistogram || pt.x === undefined) pt.x = isHorizontal ? obj.value : obj.label;\n    if(isHistogram || pt.y === undefined) pt.y = isHorizontal ? obj.label : obj.value;\n    if(isHistogram || pt.xLabel === undefined) pt.xLabel = isHorizontal ? obj.valueLabel : obj.labelLabel;\n    if(isHistogram || pt.yLabel === undefined) pt.yLabel = isHorizontal ? obj.labelLabel : obj.valueLabel;\n\n    if(isWaterfall) {\n        obj.delta = +cdi.rawS || cdi.s;\n        obj.deltaLabel = formatNumber(obj.delta);\n        obj.final = cdi.v;\n        obj.finalLabel = formatNumber(obj.final);\n        obj.initial = obj.final - obj.delta;\n        obj.initialLabel = formatNumber(obj.initial);\n    }\n\n    if(isFunnel) {\n        obj.value = cdi.s;\n        obj.valueLabel = formatNumber(obj.value);\n\n        obj.percentInitial = cdi.begR;\n        obj.percentInitialLabel = Lib.formatPercent(cdi.begR);\n        obj.percentPrevious = cdi.difR;\n        obj.percentPreviousLabel = Lib.formatPercent(cdi.difR);\n        obj.percentTotal = cdi.sumR;\n        obj.percenTotalLabel = Lib.formatPercent(cdi.sumR);\n    }\n\n    var customdata = Lib.castOption(trace, cdi.i, 'customdata');\n    if(customdata) obj.customdata = customdata;\n    return Lib.texttemplateString(texttemplate, obj, fullLayout._d3locale, pt, obj, trace._meta || {});\n}\n\nfunction calcTextinfo(cd, index, xa, ya) {\n    var trace = cd[0].trace;\n    var isHorizontal = (trace.orientation === 'h');\n    var isWaterfall = (trace.type === 'waterfall');\n    var isFunnel = (trace.type === 'funnel');\n\n    function formatLabel(u) {\n        var pAxis = isHorizontal ? ya : xa;\n        return tickText(pAxis, u, true).text;\n    }\n\n    function formatNumber(v) {\n        var sAxis = isHorizontal ? xa : ya;\n        return tickText(sAxis, +v, true).text;\n    }\n\n    var textinfo = trace.textinfo;\n    var cdi = cd[index];\n\n    var parts = textinfo.split('+');\n    var text = [];\n    var tx;\n\n    var hasFlag = function(flag) { return parts.indexOf(flag) !== -1; };\n\n    if(hasFlag('label')) {\n        text.push(formatLabel(cd[index].p));\n    }\n\n    if(hasFlag('text')) {\n        tx = Lib.castOption(trace, cdi.i, 'text');\n        if(tx === 0 || tx) text.push(tx);\n    }\n\n    if(isWaterfall) {\n        var delta = +cdi.rawS || cdi.s;\n        var final = cdi.v;\n        var initial = final - delta;\n\n        if(hasFlag('initial')) text.push(formatNumber(initial));\n        if(hasFlag('delta')) text.push(formatNumber(delta));\n        if(hasFlag('final')) text.push(formatNumber(final));\n    }\n\n    if(isFunnel) {\n        if(hasFlag('value')) text.push(formatNumber(cdi.s));\n\n        var nPercent = 0;\n        if(hasFlag('percent initial')) nPercent++;\n        if(hasFlag('percent previous')) nPercent++;\n        if(hasFlag('percent total')) nPercent++;\n\n        var hasMultiplePercents = nPercent > 1;\n\n        if(hasFlag('percent initial')) {\n            tx = Lib.formatPercent(cdi.begR);\n            if(hasMultiplePercents) tx += ' of initial';\n            text.push(tx);\n        }\n        if(hasFlag('percent previous')) {\n            tx = Lib.formatPercent(cdi.difR);\n            if(hasMultiplePercents) tx += ' of previous';\n            text.push(tx);\n        }\n        if(hasFlag('percent total')) {\n            tx = Lib.formatPercent(cdi.sumR);\n            if(hasMultiplePercents) tx += ' of total';\n            text.push(tx);\n        }\n    }\n\n    return text.join('<br>');\n}\n\nmodule.exports = {\n    plot: plot,\n    toMoveInsideBar: toMoveInsideBar\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}