{"ast":null,"code":"'use strict';\n\nvar polybool = require('polybooljs');\nvar pointInPolygon = require('point-in-polygon/nested'); // could we use contains lib/polygon instead?\n\nvar Registry = require('../../registry');\nvar dashStyle = require('../drawing').dashStyle;\nvar Color = require('../color');\nvar Fx = require('../fx');\nvar makeEventData = require('../fx/helpers').makeEventData;\nvar dragHelpers = require('../dragelement/helpers');\nvar freeMode = dragHelpers.freeMode;\nvar rectMode = dragHelpers.rectMode;\nvar drawMode = dragHelpers.drawMode;\nvar openMode = dragHelpers.openMode;\nvar selectMode = dragHelpers.selectMode;\nvar shapeHelpers = require('../shapes/helpers');\nvar shapeConstants = require('../shapes/constants');\nvar displayOutlines = require('../shapes/display_outlines');\nvar clearOutline = require('../shapes/handle_outline').clearOutline;\nvar newShapeHelpers = require('../shapes/draw_newshape/helpers');\nvar handleEllipse = newShapeHelpers.handleEllipse;\nvar readPaths = newShapeHelpers.readPaths;\nvar newShapes = require('../shapes/draw_newshape/newshapes');\nvar newSelections = require('./draw_newselection/newselections');\nvar activateLastSelection = require('./draw').activateLastSelection;\nvar Lib = require('../../lib');\nvar ascending = Lib.sorterAsc;\nvar libPolygon = require('../../lib/polygon');\nvar throttle = require('../../lib/throttle');\nvar getFromId = require('../../plots/cartesian/axis_ids').getFromId;\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\nvar constants = require('./constants');\nvar MINSELECT = constants.MINSELECT;\nvar filteredPolygon = libPolygon.filter;\nvar polygonTester = libPolygon.tester;\nvar helpers = require('./helpers');\nvar p2r = helpers.p2r;\nvar axValue = helpers.axValue;\nvar getTransform = helpers.getTransform;\nfunction hasSubplot(dragOptions) {\n  // N.B. subplot may be falsy e.g zero sankey index!\n  return dragOptions.subplot !== undefined;\n}\nfunction prepSelect(evt, startX, startY, dragOptions, mode) {\n  var isCartesian = !hasSubplot(dragOptions);\n  var isFreeMode = freeMode(mode);\n  var isRectMode = rectMode(mode);\n  var isOpenMode = openMode(mode);\n  var isDrawMode = drawMode(mode);\n  var isSelectMode = selectMode(mode);\n  var isLine = mode === 'drawline';\n  var isEllipse = mode === 'drawcircle';\n  var isLineOrEllipse = isLine || isEllipse; // cases with two start & end positions\n\n  var gd = dragOptions.gd;\n  var fullLayout = gd._fullLayout;\n  var immediateSelect = isSelectMode && fullLayout.newselection.mode === 'immediate' && isCartesian; // N.B. only cartesian subplots have persistent selection\n\n  var zoomLayer = fullLayout._zoomlayer;\n  var dragBBox = dragOptions.element.getBoundingClientRect();\n  var plotinfo = dragOptions.plotinfo;\n  var transform = getTransform(plotinfo);\n  var x0 = startX - dragBBox.left;\n  var y0 = startY - dragBBox.top;\n  fullLayout._calcInverseTransform(gd);\n  var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n  x0 = transformedCoords[0];\n  y0 = transformedCoords[1];\n  var scaleX = fullLayout._invScaleX;\n  var scaleY = fullLayout._invScaleY;\n  var x1 = x0;\n  var y1 = y0;\n  var path0 = 'M' + x0 + ',' + y0;\n  var xAxis = dragOptions.xaxes[0];\n  var yAxis = dragOptions.yaxes[0];\n  var pw = xAxis._length;\n  var ph = yAxis._length;\n  var subtract = evt.altKey && !(drawMode(mode) && isOpenMode);\n  var filterPoly, selectionTesters, mergedPolygons, currentPolygon;\n  var i, searchInfo, eventData;\n  coerceSelectionsCache(evt, gd, dragOptions);\n  if (isFreeMode) {\n    filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n  }\n  var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data([1]);\n  var newStyle = isDrawMode ? fullLayout.newshape : fullLayout.newselection;\n  var fillC = isDrawMode && !isOpenMode ? newStyle.fillcolor : 'rgba(0,0,0,0)';\n  var strokeC = newStyle.line.color || (isCartesian ? Color.contrast(gd._fullLayout.plot_bgcolor) : '#7f7f7f' // non-cartesian subplot\n  );\n\n  outlines.enter().append('path').attr('class', 'select-outline select-outline-' + plotinfo.id).style({\n    opacity: isDrawMode ? newStyle.opacity / 2 : 1,\n    'stroke-dasharray': dashStyle(newStyle.line.dash, newStyle.line.width),\n    'stroke-width': newStyle.line.width + 'px',\n    'shape-rendering': 'crispEdges'\n  }).call(Color.stroke, strokeC).call(Color.fill, fillC).attr('fill-rule', 'evenodd').classed('cursor-move', isDrawMode ? true : false).attr('transform', transform).attr('d', path0 + 'Z');\n  var corners = zoomLayer.append('path').attr('class', 'zoombox-corners').style({\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': 1\n  }).attr('transform', transform).attr('d', 'M0,0Z');\n  var throttleID = fullLayout._uid + constants.SELECTID;\n  var selection = [];\n\n  // find the traces to search for selection points\n  var searchTraces = determineSearchTraces(gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot);\n  if (immediateSelect && !evt.shiftKey) {\n    dragOptions._clearSubplotSelections = function () {\n      if (!isCartesian) return;\n      var xRef = xAxis._id;\n      var yRef = yAxis._id;\n      deselectSubplot(gd, xRef, yRef, searchTraces);\n      var selections = (gd.layout || {}).selections || [];\n      var list = [];\n      var selectionErased = false;\n      for (var q = 0; q < selections.length; q++) {\n        var s = fullLayout.selections[q];\n        if (s.xref !== xRef || s.yref !== yRef) {\n          list.push(selections[q]);\n        } else {\n          selectionErased = true;\n        }\n      }\n      if (selectionErased) {\n        gd._fullLayout._noEmitSelectedAtStart = true;\n        Registry.call('_guiRelayout', gd, {\n          selections: list\n        });\n      }\n    };\n  }\n  var fillRangeItems = getFillRangeItems(dragOptions);\n  dragOptions.moveFn = function (dx0, dy0) {\n    if (dragOptions._clearSubplotSelections) {\n      dragOptions._clearSubplotSelections();\n      dragOptions._clearSubplotSelections = undefined;\n    }\n    x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));\n    y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));\n    var dx = Math.abs(x1 - x0);\n    var dy = Math.abs(y1 - y0);\n    if (isRectMode) {\n      var direction;\n      var start, end;\n      if (isSelectMode) {\n        var q = fullLayout.selectdirection;\n        if (q === 'any') {\n          if (dy < Math.min(dx * 0.6, MINSELECT)) {\n            direction = 'h';\n          } else if (dx < Math.min(dy * 0.6, MINSELECT)) {\n            direction = 'v';\n          } else {\n            direction = 'd';\n          }\n        } else {\n          direction = q;\n        }\n        switch (direction) {\n          case 'h':\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n          case 'v':\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n        }\n      }\n      if (isDrawMode) {\n        switch (fullLayout.newshape.drawdirection) {\n          case 'vertical':\n            direction = 'h';\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n          case 'horizontal':\n            direction = 'v';\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n          case 'ortho':\n            if (dx < dy) {\n              direction = 'h';\n              start = y0;\n              end = y1;\n            } else {\n              direction = 'v';\n              start = x0;\n              end = x1;\n            }\n            break;\n          default:\n            // i.e. case of 'diagonal'\n            direction = 'd';\n        }\n      }\n      if (direction === 'h') {\n        // horizontal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x1, start], [x1, end]) :\n        // using x1 instead of x0 allows adjusting the line while drawing\n        [[x0, start], [x0, end], [x1, end], [x1, start]]; // make a vertical box\n\n        currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);\n        currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(start, end);\n        currentPolygon.ymax = Math.max(start, end);\n        // extras to guide users in keeping a straight selection\n        corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) + 'h-4v' + 2 * MINSELECT + 'h4Z' + 'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) + 'h4v' + 2 * MINSELECT + 'h-4Z');\n      } else if (direction === 'v') {\n        // vertical motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [start, y1], [end, y1]) :\n        // using y1 instead of y0 allows adjusting the line while drawing\n        [[start, y0], [start, y1], [end, y1], [end, y0]]; // make a horizontal box\n\n        currentPolygon.xmin = Math.min(start, end);\n        currentPolygon.xmax = Math.max(start, end);\n        currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);\n        currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);\n        corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin + 'v-4h' + 2 * MINSELECT + 'v4Z' + 'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) + 'v4h' + 2 * MINSELECT + 'v-4Z');\n      } else if (direction === 'd') {\n        // diagonal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x0, y0], [x1, y1]) : [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n        currentPolygon.xmin = Math.min(x0, x1);\n        currentPolygon.xmax = Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(y0, y1);\n        currentPolygon.ymax = Math.max(y0, y1);\n        corners.attr('d', 'M0,0Z');\n      }\n    } else if (isFreeMode) {\n      filterPoly.addPt([x1, y1]);\n      currentPolygon = filterPoly.filtered;\n    }\n\n    // create outline & tester\n    if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {\n      mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n      currentPolygon.subtract = subtract;\n      selectionTesters = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));\n    } else {\n      mergedPolygons = [currentPolygon];\n      selectionTesters = polygonTester(currentPolygon);\n    }\n\n    // display polygons on the screen\n    displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);\n    if (isSelectMode) {\n      var _res = reselect(gd, false);\n      var extraPoints = _res.eventData ? _res.eventData.points.slice() : [];\n      _res = reselect(gd, false, selectionTesters, searchTraces, dragOptions);\n      selectionTesters = _res.selectionTesters;\n      eventData = _res.eventData;\n      var poly;\n      if (filterPoly) {\n        poly = filterPoly.filtered;\n      } else {\n        poly = castMultiPolygon(mergedPolygons);\n      }\n      throttle.throttle(throttleID, constants.SELECTDELAY, function () {\n        selection = _doSelect(selectionTesters, searchTraces);\n        var newPoints = selection.slice();\n        for (var w = 0; w < extraPoints.length; w++) {\n          var p = extraPoints[w];\n          var found = false;\n          for (var u = 0; u < newPoints.length; u++) {\n            if (newPoints[u].curveNumber === p.curveNumber && newPoints[u].pointNumber === p.pointNumber) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) newPoints.push(p);\n        }\n        if (newPoints.length) {\n          if (!eventData) eventData = {};\n          eventData.points = newPoints;\n        }\n        fillRangeItems(eventData, poly);\n        emitSelecting(gd, eventData);\n      });\n    }\n  };\n  dragOptions.clickFn = function (numClicks, evt) {\n    corners.remove();\n    if (gd._fullLayout._activeShapeIndex >= 0) {\n      gd._fullLayout._deactivateShape(gd);\n      return;\n    }\n    if (isDrawMode) return;\n    var clickmode = fullLayout.clickmode;\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n      if (numClicks === 2) {\n        // clear selection on doubleclick\n        outlines.remove();\n        for (i = 0; i < searchTraces.length; i++) {\n          searchInfo = searchTraces[i];\n          searchInfo._module.selectPoints(searchInfo, false);\n        }\n        updateSelectedState(gd, searchTraces);\n        clearSelectionsCache(dragOptions);\n        emitDeselect(gd);\n        if (searchTraces.length) {\n          var clickedXaxis = searchTraces[0].xaxis;\n          var clickedYaxis = searchTraces[0].yaxis;\n          if (clickedXaxis && clickedYaxis) {\n            // drop selections in the clicked subplot\n            var subSelections = [];\n            var allSelections = gd._fullLayout.selections;\n            for (var k = 0; k < allSelections.length; k++) {\n              var s = allSelections[k];\n              if (!s) continue; // also drop null selections if any\n\n              if (s.xref !== clickedXaxis._id || s.yref !== clickedYaxis._id) {\n                subSelections.push(s);\n              }\n            }\n            if (subSelections.length < allSelections.length) {\n              gd._fullLayout._noEmitSelectedAtStart = true;\n              Registry.call('_guiRelayout', gd, {\n                selections: subSelections\n              });\n            }\n          }\n        }\n      } else {\n        if (clickmode.indexOf('select') > -1) {\n          selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot, dragOptions, outlines);\n        }\n        if (clickmode === 'event') {\n          // TODO: remove in v3 - this was probably never intended to work as it does,\n          // but in case anyone depends on it we don't want to break it now.\n          // Note that click-to-select introduced pre v3 also emitts proper\n          // event data when clickmode is having 'select' in its flag list.\n          emitSelected(gd, undefined);\n        }\n      }\n      Fx.click(gd, evt);\n    }).catch(Lib.error);\n  };\n  dragOptions.doneFn = function () {\n    corners.remove();\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n      if (!immediateSelect && currentPolygon && dragOptions.selectionDefs) {\n        // save last polygons\n        currentPolygon.subtract = subtract;\n        dragOptions.selectionDefs.push(currentPolygon);\n\n        // we have to keep reference to arrays container\n        dragOptions.mergedPolygons.length = 0;\n        [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n      }\n      if (immediateSelect || isDrawMode) {\n        clearSelectionsCache(dragOptions, immediateSelect);\n      }\n      if (dragOptions.doneFnCompleted) {\n        dragOptions.doneFnCompleted(selection);\n      }\n      if (isSelectMode) {\n        emitSelected(gd, eventData);\n      }\n    }).catch(Lib.error);\n  };\n}\nfunction selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {\n  var hoverData = gd._hoverdata;\n  var fullLayout = gd._fullLayout;\n  var clickmode = fullLayout.clickmode;\n  var sendEvents = clickmode.indexOf('event') > -1;\n  var selection = [];\n  var searchTraces, searchInfo, currentSelectionDef, selectionTesters, traceSelection;\n  var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;\n  if (isHoverDataSet(hoverData)) {\n    coerceSelectionsCache(evt, gd, dragOptions);\n    searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);\n    var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);\n    var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0;\n\n    // Note: potentially costly operation isPointOrBinSelected is\n    // called as late as possible through the use of an assignment\n    // in an if condition.\n    if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {\n      if (polygonOutlines) polygonOutlines.remove();\n      for (i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        searchInfo._module.selectPoints(searchInfo, false);\n      }\n      updateSelectedState(gd, searchTraces);\n      clearSelectionsCache(dragOptions);\n      if (sendEvents) {\n        emitDeselect(gd);\n      }\n    } else {\n      subtract = evt.shiftKey && (pointOrBinSelected !== undefined ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));\n      currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);\n      var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);\n      selectionTesters = multiTester(allSelectionDefs, selectionTesters);\n      for (i = 0; i < searchTraces.length; i++) {\n        traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTesters);\n        thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);\n        if (selection.length) {\n          for (var j = 0; j < thisTracesSelection.length; j++) {\n            selection.push(thisTracesSelection[j]);\n          }\n        } else selection = thisTracesSelection;\n      }\n      eventData = {\n        points: selection\n      };\n      updateSelectedState(gd, searchTraces, eventData);\n      if (currentSelectionDef && dragOptions) {\n        dragOptions.selectionDefs.push(currentSelectionDef);\n      }\n      if (polygonOutlines) {\n        var polygons = dragOptions.mergedPolygons;\n        var isOpenMode = openMode(dragOptions.dragmode);\n\n        // display polygons on the screen\n        displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);\n      }\n      if (sendEvents) {\n        emitSelected(gd, eventData);\n      }\n    }\n  }\n}\n\n/**\n * Constructs a new point selection definition object.\n */\nfunction newPointSelectionDef(pointNumber, searchInfo, subtract) {\n  return {\n    pointNumber: pointNumber,\n    searchInfo: searchInfo,\n    subtract: !!subtract\n  };\n}\nfunction isPointSelectionDef(o) {\n  return 'pointNumber' in o && 'searchInfo' in o;\n}\n\n/*\n * Constructs a new point number tester.\n */\nfunction newPointNumTester(pointSelectionDef) {\n  return {\n    xmin: 0,\n    xmax: 0,\n    ymin: 0,\n    ymax: 0,\n    pts: [],\n    contains: function (pt, omitFirstEdge, pointNumber, searchInfo) {\n      var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;\n      var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;\n      return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;\n    },\n    isRect: false,\n    degenerate: false,\n    subtract: !!pointSelectionDef.subtract\n  };\n}\n\n/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */\nfunction multiTester(list) {\n  if (!list.length) return;\n  var testers = [];\n  var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];\n  var xmax = xmin;\n  var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];\n  var ymax = ymin;\n  for (var i = 0; i < list.length; i++) {\n    if (isPointSelectionDef(list[i])) {\n      testers.push(newPointNumTester(list[i]));\n    } else {\n      var tester = polygonTester(list[i]);\n      tester.subtract = !!list[i].subtract;\n      testers.push(tester);\n      xmin = Math.min(xmin, tester.xmin);\n      xmax = Math.max(xmax, tester.xmax);\n      ymin = Math.min(ymin, tester.ymin);\n      ymax = Math.max(ymax, tester.ymax);\n    }\n  }\n\n  /**\n   * Tests if the given point is within this tester.\n   *\n   * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n   * @param {*} arg - An optional parameter to pass down to wrapped testers.\n   * @param {number} pointNumber - The point number of the point within the underlying data array.\n   * @param {number} searchInfo - An object identifying the trace the point is contained in.\n   *\n   * @return {boolean} true if point is considered to be selected, false otherwise.\n   */\n  function contains(pt, arg, pointNumber, searchInfo) {\n    var contained = false;\n    for (var i = 0; i < testers.length; i++) {\n      if (testers[i].contains(pt, arg, pointNumber, searchInfo)) {\n        // if contained by subtract tester - exclude the point\n        contained = !testers[i].subtract;\n      }\n    }\n    return contained;\n  }\n  return {\n    xmin: xmin,\n    xmax: xmax,\n    ymin: ymin,\n    ymax: ymax,\n    pts: [],\n    contains: contains,\n    isRect: false,\n    degenerate: false\n  };\n}\nfunction coerceSelectionsCache(evt, gd, dragOptions) {\n  var fullLayout = gd._fullLayout;\n  var plotinfo = dragOptions.plotinfo;\n  var dragmode = dragOptions.dragmode;\n  var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;\n  var hasModifierKey = (evt.shiftKey || evt.altKey) && !(drawMode(dragmode) && openMode(dragmode));\n  if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {\n    // take over selection definitions from prev mode, if any\n    dragOptions.selectionDefs = plotinfo.selection.selectionDefs;\n    dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n  } else if (!hasModifierKey || !plotinfo.selection) {\n    clearSelectionsCache(dragOptions);\n  }\n\n  // clear selection outline when selecting a different subplot\n  if (!selectingOnSameSubplot) {\n    clearOutline(gd);\n    fullLayout._lastSelectedSubplot = plotinfo.id;\n  }\n}\nfunction hasActiveShape(gd) {\n  return gd._fullLayout._activeShapeIndex >= 0;\n}\nfunction hasActiveSelection(gd) {\n  return gd._fullLayout._activeSelectionIndex >= 0;\n}\nfunction clearSelectionsCache(dragOptions, immediateSelect) {\n  var dragmode = dragOptions.dragmode;\n  var plotinfo = dragOptions.plotinfo;\n  var gd = dragOptions.gd;\n  if (hasActiveShape(gd)) {\n    gd._fullLayout._deactivateShape(gd);\n  }\n  if (hasActiveSelection(gd)) {\n    gd._fullLayout._deactivateSelection(gd);\n  }\n  var fullLayout = gd._fullLayout;\n  var zoomLayer = fullLayout._zoomlayer;\n  var isDrawMode = drawMode(dragmode);\n  var isSelectMode = selectMode(dragmode);\n  if (isDrawMode || isSelectMode) {\n    var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n    if (outlines && gd._fullLayout._outlining) {\n      // add shape\n      var shapes;\n      if (isDrawMode) {\n        shapes = newShapes(outlines, dragOptions);\n      }\n      if (shapes) {\n        Registry.call('_guiRelayout', gd, {\n          shapes: shapes\n        });\n      }\n\n      // add selection\n      var selections;\n      if (isSelectMode && !hasSubplot(dragOptions) // only allow cartesian - no mapbox for now\n      ) {\n        selections = newSelections(outlines, dragOptions);\n      }\n      if (selections) {\n        gd._fullLayout._noEmitSelectedAtStart = true;\n        Registry.call('_guiRelayout', gd, {\n          selections: selections\n        }).then(function () {\n          if (immediateSelect) {\n            activateLastSelection(gd);\n          }\n        });\n      }\n      gd._fullLayout._outlining = false;\n    }\n  }\n  plotinfo.selection = {};\n  plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];\n  plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n}\nfunction getAxId(ax) {\n  return ax._id;\n}\nfunction determineSearchTraces(gd, xAxes, yAxes, subplot) {\n  if (!gd.calcdata) return [];\n  var searchTraces = [];\n  var xAxisIds = xAxes.map(getAxId);\n  var yAxisIds = yAxes.map(getAxId);\n  var cd, trace, i;\n  for (i = 0; i < gd.calcdata.length; i++) {\n    cd = gd.calcdata[i];\n    trace = cd[0].trace;\n    if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n    if (hasSubplot({\n      subplot: subplot\n    }) && (trace.subplot === subplot || trace.geo === subplot)) {\n      searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));\n    } else if (trace.type === 'splom') {\n      // FIXME: make sure we don't have more than single axis for splom\n      if (trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {\n        var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n        info.scene = gd._fullLayout._splomScenes[trace.uid];\n        searchTraces.push(info);\n      }\n    } else if (trace.type === 'sankey') {\n      var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n      searchTraces.push(sankeyInfo);\n    } else {\n      if (xAxisIds.indexOf(trace.xaxis) === -1) continue;\n      if (yAxisIds.indexOf(trace.yaxis) === -1) continue;\n      searchTraces.push(createSearchInfo(trace._module, cd, getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));\n    }\n  }\n  return searchTraces;\n}\nfunction createSearchInfo(module, calcData, xaxis, yaxis) {\n  return {\n    _module: module,\n    cd: calcData,\n    xaxis: xaxis,\n    yaxis: yaxis\n  };\n}\nfunction isHoverDataSet(hoverData) {\n  return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;\n}\nfunction extractClickedPtInfo(hoverData, searchTraces) {\n  var hoverDatum = hoverData[0];\n  var pointNumber = -1;\n  var pointNumbers = [];\n  var searchInfo, i;\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    if (hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {\n      // Special case for box (and violin)\n      if (hoverDatum.hoverOnBox === true) {\n        break;\n      }\n\n      // Hint: in some traces like histogram, one graphical element\n      // doesn't correspond to one particular data point, but to\n      // bins of data points. Thus, hoverDatum can have a binNumber\n      // property instead of pointNumber.\n      if (hoverDatum.pointNumber !== undefined) {\n        pointNumber = hoverDatum.pointNumber;\n      } else if (hoverDatum.binNumber !== undefined) {\n        pointNumber = hoverDatum.binNumber;\n        pointNumbers = hoverDatum.pointNumbers;\n      }\n      break;\n    }\n  }\n  return {\n    pointNumber: pointNumber,\n    pointNumbers: pointNumbers,\n    searchInfo: searchInfo\n  };\n}\nfunction isPointOrBinSelected(clickedPtInfo) {\n  var trace = clickedPtInfo.searchInfo.cd[0].trace;\n  var ptNum = clickedPtInfo.pointNumber;\n  var ptNums = clickedPtInfo.pointNumbers;\n  var ptNumsSet = ptNums.length > 0;\n\n  // When pointsNumbers is set (e.g. histogram's binning),\n  // it is assumed that when the first point of\n  // a bin is selected, all others are as well\n  var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum;\n\n  // TODO potential performance improvement\n  // Primarily we need this function to determine if a click adds\n  // or subtracts from a selection.\n  // In cases `trace.selectedpoints` is a huge array, indexOf\n  // might be slow. One remedy would be to introduce a hash somewhere.\n  return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;\n}\nfunction isOnlyThisBinSelected(searchTraces, clickedPtInfo) {\n  var tracesWithSelectedPts = [];\n  var searchInfo, trace, isSameTrace, i;\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {\n      tracesWithSelectedPts.push(searchInfo);\n    }\n  }\n  if (tracesWithSelectedPts.length === 1) {\n    isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;\n    if (isSameTrace) {\n      trace = clickedPtInfo.searchInfo.cd[0].trace;\n      if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {\n        for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {\n          if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isOnlyOnePointSelected(searchTraces) {\n  var len = 0;\n  var searchInfo, trace, i;\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    trace = searchInfo.cd[0].trace;\n    if (trace.selectedpoints) {\n      if (trace.selectedpoints.length > 1) return false;\n      len += trace.selectedpoints.length;\n      if (len > 1) return false;\n    }\n  }\n  return len === 1;\n}\nfunction updateSelectedState(gd, searchTraces, eventData) {\n  var i;\n\n  // before anything else, update preGUI if necessary\n  for (i = 0; i < searchTraces.length; i++) {\n    var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;\n    var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};\n    if (tracePreGUI.selectedpoints === undefined) {\n      tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;\n    }\n  }\n  var trace;\n  if (eventData) {\n    var pts = eventData.points || [];\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      trace._input.selectedpoints = trace._fullInput.selectedpoints = [];\n      if (trace._fullInput !== trace) trace.selectedpoints = [];\n    }\n    for (var k = 0; k < pts.length; k++) {\n      var pt = pts[k];\n      var data = pt.data;\n      var fullData = pt.fullData;\n      var pointIndex = pt.pointIndex;\n      var pointIndices = pt.pointIndices;\n      if (pointIndices) {\n        [].push.apply(data.selectedpoints, pointIndices);\n        if (trace._fullInput !== trace) {\n          [].push.apply(fullData.selectedpoints, pointIndices);\n        }\n      } else {\n        data.selectedpoints.push(pointIndex);\n        if (trace._fullInput !== trace) {\n          fullData.selectedpoints.push(pointIndex);\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      delete trace.selectedpoints;\n      delete trace._input.selectedpoints;\n      if (trace._fullInput !== trace) {\n        delete trace._fullInput.selectedpoints;\n      }\n    }\n  }\n  updateReglSelectedState(gd, searchTraces);\n}\nfunction updateReglSelectedState(gd, searchTraces) {\n  var hasRegl = false;\n  for (var i = 0; i < searchTraces.length; i++) {\n    var searchInfo = searchTraces[i];\n    var cd = searchInfo.cd;\n    if (Registry.traceIs(cd[0].trace, 'regl')) {\n      hasRegl = true;\n    }\n    var _module = searchInfo._module;\n    var fn = _module.styleOnSelect || _module.style;\n    if (fn) {\n      fn(gd, cd, cd[0].node3);\n      if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);\n    }\n  }\n  if (hasRegl) {\n    clearGlCanvases(gd);\n    redrawReglTraces(gd);\n  }\n}\nfunction mergePolygons(list, poly, subtract) {\n  var fn = subtract ? polybool.difference : polybool.union;\n  var res = fn({\n    regions: list\n  }, {\n    regions: [poly]\n  });\n  var allPolygons = res.regions.reverse();\n  for (var i = 0; i < allPolygons.length; i++) {\n    var polygon = allPolygons[i];\n    polygon.subtract = getSubtract(polygon, allPolygons.slice(0, i));\n  }\n  return allPolygons;\n}\nfunction fillSelectionItem(selection, searchInfo) {\n  if (Array.isArray(selection)) {\n    var cd = searchInfo.cd;\n    var trace = searchInfo.cd[0].trace;\n    for (var i = 0; i < selection.length; i++) {\n      selection[i] = makeEventData(selection[i], trace, cd);\n    }\n  }\n  return selection;\n}\nfunction convertPoly(polygonsIn, isOpenMode) {\n  // add M and L command to draft positions\n  var polygonsOut = [];\n  for (var i = 0; i < polygonsIn.length; i++) {\n    polygonsOut[i] = [];\n    for (var j = 0; j < polygonsIn[i].length; j++) {\n      polygonsOut[i][j] = [];\n      polygonsOut[i][j][0] = j ? 'L' : 'M';\n      for (var k = 0; k < polygonsIn[i][j].length; k++) {\n        polygonsOut[i][j].push(polygonsIn[i][j][k]);\n      }\n    }\n    if (!isOpenMode) {\n      polygonsOut[i].push(['Z', polygonsOut[i][0][1],\n      // initial x\n      polygonsOut[i][0][2] // initial y\n      ]);\n    }\n  }\n\n  return polygonsOut;\n}\nfunction _doSelect(selectionTesters, searchTraces) {\n  var allSelections = [];\n  var thisSelection;\n  var traceSelections = [];\n  var traceSelection;\n  for (var i = 0; i < searchTraces.length; i++) {\n    var searchInfo = searchTraces[i];\n    traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTesters);\n    traceSelections.push(traceSelection);\n    thisSelection = fillSelectionItem(traceSelection, searchInfo);\n    allSelections = allSelections.concat(thisSelection);\n  }\n  return allSelections;\n}\nfunction reselect(gd, mayEmitSelected, selectionTesters, searchTraces, dragOptions) {\n  var hadSearchTraces = !!searchTraces;\n  var plotinfo, xRef, yRef;\n  if (dragOptions) {\n    plotinfo = dragOptions.plotinfo;\n    xRef = dragOptions.xaxes[0]._id;\n    yRef = dragOptions.yaxes[0]._id;\n  }\n  var allSelections = [];\n  var allSearchTraces = [];\n\n  // select layout.selection polygons\n  var layoutPolygons = getLayoutPolygons(gd);\n\n  // add draft outline polygons to layoutPolygons\n  var fullLayout = gd._fullLayout;\n  if (plotinfo) {\n    var zoomLayer = fullLayout._zoomlayer;\n    var mode = fullLayout.dragmode;\n    var isDrawMode = drawMode(mode);\n    var isSelectMode = selectMode(mode);\n    if (isDrawMode || isSelectMode) {\n      var xaxis = getFromId(gd, xRef, 'x');\n      var yaxis = getFromId(gd, yRef, 'y');\n      if (xaxis && yaxis) {\n        var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n        if (outlines && gd._fullLayout._outlining) {\n          if (outlines.length) {\n            var e = outlines[0][0]; // pick first\n            var d = e.getAttribute('d');\n            var outlinePolys = readPaths(d, gd, plotinfo);\n            var draftPolygons = [];\n            for (var u = 0; u < outlinePolys.length; u++) {\n              var p = outlinePolys[u];\n              var polygon = [];\n              for (var t = 0; t < p.length; t++) {\n                polygon.push([convert(xaxis, p[t][1]), convert(yaxis, p[t][2])]);\n              }\n              polygon.xref = xRef;\n              polygon.yref = yRef;\n              polygon.subtract = getSubtract(polygon, draftPolygons);\n              draftPolygons.push(polygon);\n            }\n            layoutPolygons = layoutPolygons.concat(draftPolygons);\n          }\n        }\n      }\n    }\n  }\n  var subplots = xRef && yRef ? [xRef + yRef] : fullLayout._subplots.cartesian;\n  epmtySplomSelectionBatch(gd);\n  var seenSplom = {};\n  for (var i = 0; i < subplots.length; i++) {\n    var subplot = subplots[i];\n    var yAt = subplot.indexOf('y');\n    var _xRef = subplot.slice(0, yAt);\n    var _yRef = subplot.slice(yAt);\n    var _selectionTesters = xRef && yRef ? selectionTesters : undefined;\n    _selectionTesters = addTester(layoutPolygons, _xRef, _yRef, _selectionTesters);\n    if (_selectionTesters) {\n      var _searchTraces = searchTraces;\n      if (!hadSearchTraces) {\n        var _xA = getFromId(gd, _xRef, 'x');\n        var _yA = getFromId(gd, _yRef, 'y');\n        _searchTraces = determineSearchTraces(gd, [_xA], [_yA], subplot);\n        for (var w = 0; w < _searchTraces.length; w++) {\n          var s = _searchTraces[w];\n          var cd0 = s.cd[0];\n          var trace = cd0.trace;\n          if (s._module.name === 'scattergl' && !cd0.t.xpx) {\n            var x = trace.x;\n            var y = trace.y;\n            var len = trace._length;\n            // generate stash for scattergl\n            cd0.t.xpx = [];\n            cd0.t.ypx = [];\n            for (var j = 0; j < len; j++) {\n              cd0.t.xpx[j] = _xA.c2p(x[j]);\n              cd0.t.ypx[j] = _yA.c2p(y[j]);\n            }\n          }\n          if (s._module.name === 'splom') {\n            if (!seenSplom[trace.uid]) {\n              seenSplom[trace.uid] = true;\n            }\n          }\n        }\n      }\n      var selection = _doSelect(_selectionTesters, _searchTraces);\n      allSelections = allSelections.concat(selection);\n      allSearchTraces = allSearchTraces.concat(_searchTraces);\n    }\n  }\n  var eventData = {\n    points: allSelections\n  };\n  updateSelectedState(gd, allSearchTraces, eventData);\n  var clickmode = fullLayout.clickmode;\n  var sendEvents = clickmode.indexOf('event') > -1 && mayEmitSelected;\n  if (!plotinfo &&\n  // get called from plot_api & plots\n  mayEmitSelected) {\n    var activePolygons = getLayoutPolygons(gd, true);\n    if (activePolygons.length) {\n      var xref = activePolygons[0].xref;\n      var yref = activePolygons[0].yref;\n      if (xref && yref) {\n        var poly = castMultiPolygon(activePolygons);\n        var fillRangeItems = makeFillRangeItems([getFromId(gd, xref, 'x'), getFromId(gd, yref, 'y')]);\n        fillRangeItems(eventData, poly);\n      }\n    }\n    if (gd._fullLayout._noEmitSelectedAtStart) {\n      gd._fullLayout._noEmitSelectedAtStart = false;\n    } else {\n      if (sendEvents) emitSelected(gd, eventData);\n    }\n    fullLayout._reselect = false;\n  }\n  if (!plotinfo &&\n  // get called from plot_api & plots\n  fullLayout._deselect) {\n    var deselect = fullLayout._deselect;\n    xRef = deselect.xref;\n    yRef = deselect.yref;\n    if (!subplotSelected(xRef, yRef, allSearchTraces)) {\n      deselectSubplot(gd, xRef, yRef, searchTraces);\n    }\n    if (sendEvents) {\n      if (eventData.points.length) {\n        emitSelected(gd, eventData);\n      } else {\n        emitDeselect(gd);\n      }\n    }\n    fullLayout._deselect = false;\n  }\n  return {\n    eventData: eventData,\n    selectionTesters: selectionTesters\n  };\n}\nfunction epmtySplomSelectionBatch(gd) {\n  var cd = gd.calcdata;\n  if (!cd) return;\n  for (var i = 0; i < cd.length; i++) {\n    var cd0 = cd[i][0];\n    var trace = cd0.trace;\n    var splomScenes = gd._fullLayout._splomScenes;\n    if (splomScenes) {\n      var scene = splomScenes[trace.uid];\n      if (scene) {\n        scene.selectBatch = [];\n      }\n    }\n  }\n}\nfunction subplotSelected(xRef, yRef, searchTraces) {\n  for (var i = 0; i < searchTraces.length; i++) {\n    var s = searchTraces[i];\n    if (s.xaxis && s.xaxis._id === xRef && s.yaxis && s.yaxis._id === yRef) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction deselectSubplot(gd, xRef, yRef, searchTraces) {\n  searchTraces = determineSearchTraces(gd, [getFromId(gd, xRef, 'x')], [getFromId(gd, yRef, 'y')], xRef + yRef);\n  for (var k = 0; k < searchTraces.length; k++) {\n    var searchInfo = searchTraces[k];\n    searchInfo._module.selectPoints(searchInfo, false);\n  }\n  updateSelectedState(gd, searchTraces);\n}\nfunction addTester(layoutPolygons, xRef, yRef, selectionTesters) {\n  var mergedPolygons;\n  for (var i = 0; i < layoutPolygons.length; i++) {\n    var currentPolygon = layoutPolygons[i];\n    if (xRef !== currentPolygon.xref || yRef !== currentPolygon.yref) continue;\n    if (mergedPolygons) {\n      var subtract = !!currentPolygon.subtract;\n      mergedPolygons = mergePolygons(mergedPolygons, currentPolygon, subtract);\n      selectionTesters = multiTester(mergedPolygons);\n    } else {\n      mergedPolygons = [currentPolygon];\n      selectionTesters = polygonTester(currentPolygon);\n    }\n  }\n  return selectionTesters;\n}\nfunction getLayoutPolygons(gd, onlyActiveOnes) {\n  var allPolygons = [];\n  var fullLayout = gd._fullLayout;\n  var allSelections = fullLayout.selections;\n  var len = allSelections.length;\n  for (var i = 0; i < len; i++) {\n    if (onlyActiveOnes && i !== fullLayout._activeSelectionIndex) continue;\n    var selection = allSelections[i];\n    if (!selection) continue;\n    var xref = selection.xref;\n    var yref = selection.yref;\n    var xaxis = getFromId(gd, xref, 'x');\n    var yaxis = getFromId(gd, yref, 'y');\n    var xmin, xmax, ymin, ymax;\n    var polygon;\n    if (selection.type === 'rect') {\n      polygon = [];\n      var x0 = convert(xaxis, selection.x0);\n      var x1 = convert(xaxis, selection.x1);\n      var y0 = convert(yaxis, selection.y0);\n      var y1 = convert(yaxis, selection.y1);\n      polygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n      xmin = Math.min(x0, x1);\n      xmax = Math.max(x0, x1);\n      ymin = Math.min(y0, y1);\n      ymax = Math.max(y0, y1);\n      polygon.xmin = xmin;\n      polygon.xmax = xmax;\n      polygon.ymin = ymin;\n      polygon.ymax = ymax;\n      polygon.xref = xref;\n      polygon.yref = yref;\n      polygon.subtract = false;\n      polygon.isRect = true;\n      allPolygons.push(polygon);\n    } else if (selection.type === 'path') {\n      var segments = selection.path.split('Z');\n      var multiPolygons = [];\n      for (var j = 0; j < segments.length; j++) {\n        var path = segments[j];\n        if (!path) continue;\n        path += 'Z';\n        var allX = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsX, 'raw');\n        var allY = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsY, 'raw');\n        xmin = Infinity;\n        xmax = -Infinity;\n        ymin = Infinity;\n        ymax = -Infinity;\n        polygon = [];\n        for (var k = 0; k < allX.length; k++) {\n          var x = convert(xaxis, allX[k]);\n          var y = convert(yaxis, allY[k]);\n          polygon.push([x, y]);\n          xmin = Math.min(x, xmin);\n          xmax = Math.max(x, xmax);\n          ymin = Math.min(y, ymin);\n          ymax = Math.max(y, ymax);\n        }\n        polygon.xmin = xmin;\n        polygon.xmax = xmax;\n        polygon.ymin = ymin;\n        polygon.ymax = ymax;\n        polygon.xref = xref;\n        polygon.yref = yref;\n        polygon.subtract = getSubtract(polygon, multiPolygons);\n        multiPolygons.push(polygon);\n        allPolygons.push(polygon);\n      }\n    }\n  }\n  return allPolygons;\n}\nfunction getSubtract(polygon, previousPolygons) {\n  var subtract = false;\n  for (var i = 0; i < previousPolygons.length; i++) {\n    var previousPolygon = previousPolygons[i];\n\n    // find out if a point of polygon is inside previous polygons\n    for (var k = 0; k < polygon.length; k++) {\n      if (pointInPolygon(polygon[k], previousPolygon)) {\n        subtract = !subtract;\n        break;\n      }\n    }\n  }\n  return subtract;\n}\nfunction convert(ax, d) {\n  if (ax.type === 'date') d = d.replace('_', ' ');\n  return ax.type === 'log' ? ax.c2p(d) : ax.r2p(d, null, ax.calendar);\n}\nfunction castMultiPolygon(allPolygons) {\n  var len = allPolygons.length;\n\n  // descibe multi polygons in one polygon\n  var p = [];\n  for (var i = 0; i < len; i++) {\n    var polygon = allPolygons[i];\n    p = p.concat(polygon);\n\n    // add starting vertex to close\n    // which indicates next polygon\n    p = p.concat([polygon[0]]);\n  }\n  return computeRectAndRanges(p);\n}\nfunction computeRectAndRanges(poly) {\n  poly.isRect = poly.length === 5 && poly[0][0] === poly[4][0] && poly[0][1] === poly[4][1] && poly[0][0] === poly[1][0] && poly[2][0] === poly[3][0] && poly[0][1] === poly[3][1] && poly[1][1] === poly[2][1] || poly[0][1] === poly[1][1] && poly[2][1] === poly[3][1] && poly[0][0] === poly[3][0] && poly[1][0] === poly[2][0];\n  if (poly.isRect) {\n    poly.xmin = Math.min(poly[0][0], poly[2][0]);\n    poly.xmax = Math.max(poly[0][0], poly[2][0]);\n    poly.ymin = Math.min(poly[0][1], poly[2][1]);\n    poly.ymax = Math.max(poly[0][1], poly[2][1]);\n  }\n  return poly;\n}\nfunction makeFillRangeItems(allAxes) {\n  return function (eventData, poly) {\n    var range;\n    var lassoPoints;\n    for (var i = 0; i < allAxes.length; i++) {\n      var ax = allAxes[i];\n      var id = ax._id;\n      var axLetter = id.charAt(0);\n      if (poly.isRect) {\n        if (!range) range = {};\n        var min = poly[axLetter + 'min'];\n        var max = poly[axLetter + 'max'];\n        if (min !== undefined && max !== undefined) {\n          range[id] = [p2r(ax, min), p2r(ax, max)].sort(ascending);\n        }\n      } else {\n        if (!lassoPoints) lassoPoints = {};\n        lassoPoints[id] = poly.map(axValue(ax));\n      }\n    }\n    if (range) {\n      eventData.range = range;\n    }\n    if (lassoPoints) {\n      eventData.lassoPoints = lassoPoints;\n    }\n  };\n}\nfunction getFillRangeItems(dragOptions) {\n  var plotinfo = dragOptions.plotinfo;\n  return plotinfo.fillRangeItems ||\n  // allow subplots (i.e. geo, mapbox, sankey) to override fillRangeItems routine\n  makeFillRangeItems(dragOptions.xaxes.concat(dragOptions.yaxes));\n}\nfunction emitSelecting(gd, eventData) {\n  gd.emit('plotly_selecting', eventData);\n}\nfunction emitSelected(gd, eventData) {\n  if (eventData) {\n    eventData.selections = (gd.layout || {}).selections || [];\n  }\n  gd.emit('plotly_selected', eventData);\n}\nfunction emitDeselect(gd) {\n  gd.emit('plotly_deselect', null);\n}\nmodule.exports = {\n  reselect: reselect,\n  prepSelect: prepSelect,\n  clearOutline: clearOutline,\n  clearSelectionsCache: clearSelectionsCache,\n  selectOnClick: selectOnClick\n};","map":{"version":3,"names":["polybool","require","pointInPolygon","Registry","dashStyle","Color","Fx","makeEventData","dragHelpers","freeMode","rectMode","drawMode","openMode","selectMode","shapeHelpers","shapeConstants","displayOutlines","clearOutline","newShapeHelpers","handleEllipse","readPaths","newShapes","newSelections","activateLastSelection","Lib","ascending","sorterAsc","libPolygon","throttle","getFromId","clearGlCanvases","redrawReglTraces","constants","MINSELECT","filteredPolygon","filter","polygonTester","tester","helpers","p2r","axValue","getTransform","hasSubplot","dragOptions","subplot","undefined","prepSelect","evt","startX","startY","mode","isCartesian","isFreeMode","isRectMode","isOpenMode","isDrawMode","isSelectMode","isLine","isEllipse","isLineOrEllipse","gd","fullLayout","_fullLayout","immediateSelect","newselection","zoomLayer","_zoomlayer","dragBBox","element","getBoundingClientRect","plotinfo","transform","x0","left","y0","top","_calcInverseTransform","transformedCoords","apply3DTransform","_invTransform","scaleX","_invScaleX","scaleY","_invScaleY","x1","y1","path0","xAxis","xaxes","yAxis","yaxes","pw","_length","ph","subtract","altKey","filterPoly","selectionTesters","mergedPolygons","currentPolygon","i","searchInfo","eventData","coerceSelectionsCache","BENDPX","outlines","selectAll","id","data","newStyle","newshape","fillC","fillcolor","strokeC","line","color","contrast","plot_bgcolor","enter","append","attr","style","opacity","dash","width","call","stroke","fill","classed","corners","background","defaultLine","throttleID","_uid","SELECTID","selection","searchTraces","determineSearchTraces","shiftKey","_clearSubplotSelections","xRef","_id","yRef","deselectSubplot","selections","layout","list","selectionErased","q","length","s","xref","yref","push","_noEmitSelectedAtStart","fillRangeItems","getFillRangeItems","moveFn","dx0","dy0","Math","max","min","dx","abs","dy","direction","start","end","selectdirection","drawdirection","xmin","xmax","ymin","ymax","addPt","filtered","selectionDefs","mergePolygons","multiTester","concat","convertPoly","_res","reselect","extraPoints","points","slice","poly","castMultiPolygon","SELECTDELAY","_doSelect","newPoints","w","p","found","u","curveNumber","pointNumber","emitSelecting","clickFn","numClicks","remove","_activeShapeIndex","_deactivateShape","clickmode","done","then","clear","_module","selectPoints","updateSelectedState","clearSelectionsCache","emitDeselect","clickedXaxis","xaxis","clickedYaxis","yaxis","subSelections","allSelections","k","indexOf","selectOnClick","emitSelected","click","catch","error","doneFn","apply","doneFnCompleted","xAxes","yAxes","polygonOutlines","hoverData","_hoverdata","sendEvents","currentSelectionDef","traceSelection","thisTracesSelection","pointOrBinSelected","isHoverDataSet","clickedPtInfo","extractClickedPtInfo","isBinnedTrace","pointNumbers","isOnlyThisBinSelected","isOnlyOnePointSelected","isPointOrBinSelected","newPointSelectionDef","allSelectionDefs","fillSelectionItem","j","polygons","dragmode","isPointSelectionDef","o","newPointNumTester","pointSelectionDef","pts","contains","pt","omitFirstEdge","idxWantedTrace","cd","trace","_expandedIndex","idxActualTrace","isRect","degenerate","testers","arg","contained","selectingOnSameSubplot","_lastSelectedSubplot","hasModifierKey","hasActiveShape","hasActiveSelection","_activeSelectionIndex","_deactivateSelection","_outlining","shapes","getAxId","ax","calcdata","xAxisIds","map","yAxisIds","visible","geo","createSearchInfo","type","_xaxes","_yaxes","info","scene","_splomScenes","uid","sankeyInfo","module","calcData","Array","isArray","hoverOnBox","hoverDatum","fullData","binNumber","ptNum","ptNums","ptNumsSet","ptNumToTest","selectedpoints","tracesWithSelectedPts","isSameTrace","len","fullInputTrace","_fullInput","tracePreGUI","_tracePreGUI","_input","pointIndex","pointIndices","updateReglSelectedState","hasRegl","traceIs","fn","styleOnSelect","node3","nodeRangePlot3","difference","union","res","regions","allPolygons","reverse","polygon","getSubtract","polygonsIn","polygonsOut","thisSelection","traceSelections","mayEmitSelected","hadSearchTraces","allSearchTraces","layoutPolygons","getLayoutPolygons","e","d","getAttribute","outlinePolys","draftPolygons","t","convert","subplots","_subplots","cartesian","epmtySplomSelectionBatch","seenSplom","yAt","_xRef","_yRef","_selectionTesters","addTester","_searchTraces","_xA","_yA","cd0","name","xpx","x","y","ypx","c2p","activePolygons","makeFillRangeItems","_reselect","_deselect","deselect","subplotSelected","splomScenes","selectBatch","onlyActiveOnes","segments","path","split","multiPolygons","allX","extractPathCoords","paramIsX","allY","paramIsY","Infinity","previousPolygons","previousPolygon","replace","r2p","calendar","computeRectAndRanges","allAxes","range","lassoPoints","axLetter","charAt","sort","emit","exports"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/components/selections/select.js"],"sourcesContent":["'use strict';\n\nvar polybool = require('polybooljs');\nvar pointInPolygon = require('point-in-polygon/nested'); // could we use contains lib/polygon instead?\n\nvar Registry = require('../../registry');\nvar dashStyle = require('../drawing').dashStyle;\nvar Color = require('../color');\nvar Fx = require('../fx');\nvar makeEventData = require('../fx/helpers').makeEventData;\nvar dragHelpers = require('../dragelement/helpers');\nvar freeMode = dragHelpers.freeMode;\nvar rectMode = dragHelpers.rectMode;\nvar drawMode = dragHelpers.drawMode;\nvar openMode = dragHelpers.openMode;\nvar selectMode = dragHelpers.selectMode;\n\nvar shapeHelpers = require('../shapes/helpers');\nvar shapeConstants = require('../shapes/constants');\n\nvar displayOutlines = require('../shapes/display_outlines');\nvar clearOutline = require('../shapes/handle_outline').clearOutline;\n\nvar newShapeHelpers = require('../shapes/draw_newshape/helpers');\nvar handleEllipse = newShapeHelpers.handleEllipse;\nvar readPaths = newShapeHelpers.readPaths;\n\nvar newShapes = require('../shapes/draw_newshape/newshapes');\n\nvar newSelections = require('./draw_newselection/newselections');\nvar activateLastSelection = require('./draw').activateLastSelection;\n\nvar Lib = require('../../lib');\nvar ascending = Lib.sorterAsc;\nvar libPolygon = require('../../lib/polygon');\nvar throttle = require('../../lib/throttle');\nvar getFromId = require('../../plots/cartesian/axis_ids').getFromId;\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar constants = require('./constants');\nvar MINSELECT = constants.MINSELECT;\n\nvar filteredPolygon = libPolygon.filter;\nvar polygonTester = libPolygon.tester;\n\nvar helpers = require('./helpers');\nvar p2r = helpers.p2r;\nvar axValue = helpers.axValue;\nvar getTransform = helpers.getTransform;\n\nfunction hasSubplot(dragOptions) {\n    // N.B. subplot may be falsy e.g zero sankey index!\n    return dragOptions.subplot !== undefined;\n}\n\nfunction prepSelect(evt, startX, startY, dragOptions, mode) {\n    var isCartesian = !hasSubplot(dragOptions);\n\n    var isFreeMode = freeMode(mode);\n    var isRectMode = rectMode(mode);\n    var isOpenMode = openMode(mode);\n    var isDrawMode = drawMode(mode);\n    var isSelectMode = selectMode(mode);\n\n    var isLine = mode === 'drawline';\n    var isEllipse = mode === 'drawcircle';\n    var isLineOrEllipse = isLine || isEllipse; // cases with two start & end positions\n\n    var gd = dragOptions.gd;\n    var fullLayout = gd._fullLayout;\n    var immediateSelect = isSelectMode && fullLayout.newselection.mode === 'immediate' &&\n        isCartesian; // N.B. only cartesian subplots have persistent selection\n\n    var zoomLayer = fullLayout._zoomlayer;\n    var dragBBox = dragOptions.element.getBoundingClientRect();\n    var plotinfo = dragOptions.plotinfo;\n    var transform = getTransform(plotinfo);\n    var x0 = startX - dragBBox.left;\n    var y0 = startY - dragBBox.top;\n\n    fullLayout._calcInverseTransform(gd);\n    var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1];\n    var scaleX = fullLayout._invScaleX;\n    var scaleY = fullLayout._invScaleY;\n\n    var x1 = x0;\n    var y1 = y0;\n    var path0 = 'M' + x0 + ',' + y0;\n    var xAxis = dragOptions.xaxes[0];\n    var yAxis = dragOptions.yaxes[0];\n    var pw = xAxis._length;\n    var ph = yAxis._length;\n\n    var subtract = evt.altKey &&\n        !(drawMode(mode) && isOpenMode);\n\n    var filterPoly, selectionTesters, mergedPolygons, currentPolygon;\n    var i, searchInfo, eventData;\n\n    coerceSelectionsCache(evt, gd, dragOptions);\n\n    if(isFreeMode) {\n        filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n    }\n\n    var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data([1]);\n    var newStyle = isDrawMode ?\n        fullLayout.newshape :\n        fullLayout.newselection;\n\n    var fillC = (isDrawMode && !isOpenMode) ? newStyle.fillcolor : 'rgba(0,0,0,0)';\n\n    var strokeC = newStyle.line.color || (\n        isCartesian ?\n            Color.contrast(gd._fullLayout.plot_bgcolor) :\n            '#7f7f7f' // non-cartesian subplot\n    );\n\n    outlines.enter()\n        .append('path')\n        .attr('class', 'select-outline select-outline-' + plotinfo.id)\n        .style({\n            opacity: isDrawMode ? newStyle.opacity / 2 : 1,\n            'stroke-dasharray': dashStyle(newStyle.line.dash, newStyle.line.width),\n            'stroke-width': newStyle.line.width + 'px',\n            'shape-rendering': 'crispEdges'\n        })\n        .call(Color.stroke, strokeC)\n        .call(Color.fill, fillC)\n        .attr('fill-rule', 'evenodd')\n        .classed('cursor-move', isDrawMode ? true : false)\n        .attr('transform', transform)\n        .attr('d', path0 + 'Z');\n\n    var corners = zoomLayer.append('path')\n        .attr('class', 'zoombox-corners')\n        .style({\n            fill: Color.background,\n            stroke: Color.defaultLine,\n            'stroke-width': 1\n        })\n        .attr('transform', transform)\n        .attr('d', 'M0,0Z');\n\n\n    var throttleID = fullLayout._uid + constants.SELECTID;\n    var selection = [];\n\n    // find the traces to search for selection points\n    var searchTraces = determineSearchTraces(gd, dragOptions.xaxes,\n      dragOptions.yaxes, dragOptions.subplot);\n\n    if(immediateSelect && !evt.shiftKey) {\n        dragOptions._clearSubplotSelections = function() {\n            if(!isCartesian) return;\n\n            var xRef = xAxis._id;\n            var yRef = yAxis._id;\n            deselectSubplot(gd, xRef, yRef, searchTraces);\n\n            var selections = (gd.layout || {}).selections || [];\n            var list = [];\n            var selectionErased = false;\n            for(var q = 0; q < selections.length; q++) {\n                var s = fullLayout.selections[q];\n                if(\n                    s.xref !== xRef ||\n                    s.yref !== yRef\n                ) {\n                    list.push(selections[q]);\n                } else {\n                    selectionErased = true;\n                }\n            }\n\n            if(selectionErased) {\n                gd._fullLayout._noEmitSelectedAtStart = true;\n\n                Registry.call('_guiRelayout', gd, {\n                    selections: list\n                });\n            }\n        };\n    }\n\n    var fillRangeItems = getFillRangeItems(dragOptions);\n\n    dragOptions.moveFn = function(dx0, dy0) {\n        if(dragOptions._clearSubplotSelections) {\n            dragOptions._clearSubplotSelections();\n            dragOptions._clearSubplotSelections = undefined;\n        }\n\n        x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));\n        y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));\n\n        var dx = Math.abs(x1 - x0);\n        var dy = Math.abs(y1 - y0);\n\n        if(isRectMode) {\n            var direction;\n            var start, end;\n\n            if(isSelectMode) {\n                var q = fullLayout.selectdirection;\n\n                if(q === 'any') {\n                    if(dy < Math.min(dx * 0.6, MINSELECT)) {\n                        direction = 'h';\n                    } else if(dx < Math.min(dy * 0.6, MINSELECT)) {\n                        direction = 'v';\n                    } else {\n                        direction = 'd';\n                    }\n                } else {\n                    direction = q;\n                }\n\n                switch(direction) {\n                    case 'h':\n                        start = isEllipse ? ph / 2 : 0;\n                        end = ph;\n                        break;\n                    case 'v':\n                        start = isEllipse ? pw / 2 : 0;\n                        end = pw;\n                        break;\n                }\n            }\n\n            if(isDrawMode) {\n                switch(fullLayout.newshape.drawdirection) {\n                    case 'vertical':\n                        direction = 'h';\n                        start = isEllipse ? ph / 2 : 0;\n                        end = ph;\n                        break;\n                    case 'horizontal':\n                        direction = 'v';\n                        start = isEllipse ? pw / 2 : 0;\n                        end = pw;\n                        break;\n                    case 'ortho':\n                        if(dx < dy) {\n                            direction = 'h';\n                            start = y0;\n                            end = y1;\n                        } else {\n                            direction = 'v';\n                            start = x0;\n                            end = x1;\n                        }\n                        break;\n                    default: // i.e. case of 'diagonal'\n                        direction = 'd';\n                }\n            }\n\n            if(direction === 'h') {\n                // horizontal motion\n                currentPolygon = isLineOrEllipse ?\n                    handleEllipse(isEllipse, [x1, start], [x1, end]) : // using x1 instead of x0 allows adjusting the line while drawing\n                    [[x0, start], [x0, end], [x1, end], [x1, start]]; // make a vertical box\n\n                currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);\n                currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);\n                currentPolygon.ymin = Math.min(start, end);\n                currentPolygon.ymax = Math.max(start, end);\n                // extras to guide users in keeping a straight selection\n                corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) +\n                    'h-4v' + (2 * MINSELECT) + 'h4Z' +\n                    'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) +\n                    'h4v' + (2 * MINSELECT) + 'h-4Z');\n            } else if(direction === 'v') {\n                // vertical motion\n                currentPolygon = isLineOrEllipse ?\n                    handleEllipse(isEllipse, [start, y1], [end, y1]) : // using y1 instead of y0 allows adjusting the line while drawing\n                    [[start, y0], [start, y1], [end, y1], [end, y0]]; // make a horizontal box\n\n                currentPolygon.xmin = Math.min(start, end);\n                currentPolygon.xmax = Math.max(start, end);\n                currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);\n                currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);\n                corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin +\n                    'v-4h' + (2 * MINSELECT) + 'v4Z' +\n                    'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) +\n                    'v4h' + (2 * MINSELECT) + 'v-4Z');\n            } else if(direction === 'd') {\n                // diagonal motion\n                currentPolygon = isLineOrEllipse ?\n                    handleEllipse(isEllipse, [x0, y0], [x1, y1]) :\n                    [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n\n                currentPolygon.xmin = Math.min(x0, x1);\n                currentPolygon.xmax = Math.max(x0, x1);\n                currentPolygon.ymin = Math.min(y0, y1);\n                currentPolygon.ymax = Math.max(y0, y1);\n                corners.attr('d', 'M0,0Z');\n            }\n        } else if(isFreeMode) {\n            filterPoly.addPt([x1, y1]);\n            currentPolygon = filterPoly.filtered;\n        }\n\n        // create outline & tester\n        if(dragOptions.selectionDefs && dragOptions.selectionDefs.length) {\n            mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n\n            currentPolygon.subtract = subtract;\n            selectionTesters = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));\n        } else {\n            mergedPolygons = [currentPolygon];\n            selectionTesters = polygonTester(currentPolygon);\n        }\n\n        // display polygons on the screen\n        displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);\n\n        if(isSelectMode) {\n            var _res = reselect(gd, false);\n            var extraPoints = _res.eventData ? _res.eventData.points.slice() : [];\n\n            _res = reselect(gd, false, selectionTesters, searchTraces, dragOptions);\n            selectionTesters = _res.selectionTesters;\n            eventData = _res.eventData;\n\n            var poly;\n            if(filterPoly) {\n                poly = filterPoly.filtered;\n            } else {\n                poly = castMultiPolygon(mergedPolygons);\n            }\n\n            throttle.throttle(\n                throttleID,\n                constants.SELECTDELAY,\n                function() {\n                    selection = _doSelect(selectionTesters, searchTraces);\n\n                    var newPoints = selection.slice();\n\n                    for(var w = 0; w < extraPoints.length; w++) {\n                        var p = extraPoints[w];\n                        var found = false;\n                        for(var u = 0; u < newPoints.length; u++) {\n                            if(\n                                newPoints[u].curveNumber === p.curveNumber &&\n                                newPoints[u].pointNumber === p.pointNumber\n                            ) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if(!found) newPoints.push(p);\n                    }\n\n                    if(newPoints.length) {\n                        if(!eventData) eventData = {};\n                        eventData.points = newPoints;\n                    }\n\n                    fillRangeItems(eventData, poly);\n\n                    emitSelecting(gd, eventData);\n                }\n            );\n        }\n    };\n\n    dragOptions.clickFn = function(numClicks, evt) {\n        corners.remove();\n\n        if(gd._fullLayout._activeShapeIndex >= 0) {\n            gd._fullLayout._deactivateShape(gd);\n            return;\n        }\n        if(isDrawMode) return;\n\n        var clickmode = fullLayout.clickmode;\n\n        throttle.done(throttleID).then(function() {\n            throttle.clear(throttleID);\n            if(numClicks === 2) {\n                // clear selection on doubleclick\n                outlines.remove();\n                for(i = 0; i < searchTraces.length; i++) {\n                    searchInfo = searchTraces[i];\n                    searchInfo._module.selectPoints(searchInfo, false);\n                }\n\n                updateSelectedState(gd, searchTraces);\n\n                clearSelectionsCache(dragOptions);\n\n                emitDeselect(gd);\n\n                if(searchTraces.length) {\n                    var clickedXaxis = searchTraces[0].xaxis;\n                    var clickedYaxis = searchTraces[0].yaxis;\n\n                    if(clickedXaxis && clickedYaxis) {\n                        // drop selections in the clicked subplot\n                        var subSelections = [];\n                        var allSelections = gd._fullLayout.selections;\n                        for(var k = 0; k < allSelections.length; k++) {\n                            var s = allSelections[k];\n                            if(!s) continue; // also drop null selections if any\n\n                            if(\n                                s.xref !== clickedXaxis._id ||\n                                s.yref !== clickedYaxis._id\n                            ) {\n                                subSelections.push(s);\n                            }\n                        }\n\n                        if(subSelections.length < allSelections.length) {\n                            gd._fullLayout._noEmitSelectedAtStart = true;\n\n                            Registry.call('_guiRelayout', gd, {\n                                selections: subSelections\n                            });\n                        }\n                    }\n                }\n            } else {\n                if(clickmode.indexOf('select') > -1) {\n                    selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes,\n                      dragOptions.subplot, dragOptions, outlines);\n                }\n\n                if(clickmode === 'event') {\n                    // TODO: remove in v3 - this was probably never intended to work as it does,\n                    // but in case anyone depends on it we don't want to break it now.\n                    // Note that click-to-select introduced pre v3 also emitts proper\n                    // event data when clickmode is having 'select' in its flag list.\n                    emitSelected(gd, undefined);\n                }\n            }\n\n            Fx.click(gd, evt);\n        }).catch(Lib.error);\n    };\n\n    dragOptions.doneFn = function() {\n        corners.remove();\n\n        throttle.done(throttleID).then(function() {\n            throttle.clear(throttleID);\n\n            if(!immediateSelect && currentPolygon && dragOptions.selectionDefs) {\n                // save last polygons\n                currentPolygon.subtract = subtract;\n                dragOptions.selectionDefs.push(currentPolygon);\n\n                // we have to keep reference to arrays container\n                dragOptions.mergedPolygons.length = 0;\n                [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n            }\n\n            if(immediateSelect || isDrawMode) {\n                clearSelectionsCache(dragOptions, immediateSelect);\n            }\n\n            if(dragOptions.doneFnCompleted) {\n                dragOptions.doneFnCompleted(selection);\n            }\n\n            if(isSelectMode) {\n                emitSelected(gd, eventData);\n            }\n        }).catch(Lib.error);\n    };\n}\n\nfunction selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {\n    var hoverData = gd._hoverdata;\n    var fullLayout = gd._fullLayout;\n    var clickmode = fullLayout.clickmode;\n    var sendEvents = clickmode.indexOf('event') > -1;\n    var selection = [];\n    var searchTraces, searchInfo, currentSelectionDef, selectionTesters, traceSelection;\n    var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;\n\n    if(isHoverDataSet(hoverData)) {\n        coerceSelectionsCache(evt, gd, dragOptions);\n        searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);\n        var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);\n        var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0;\n\n\n        // Note: potentially costly operation isPointOrBinSelected is\n        // called as late as possible through the use of an assignment\n        // in an if condition.\n        if(isBinnedTrace ?\n            isOnlyThisBinSelected(searchTraces, clickedPtInfo) :\n            isOnlyOnePointSelected(searchTraces) &&\n                (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {\n            if(polygonOutlines) polygonOutlines.remove();\n            for(i = 0; i < searchTraces.length; i++) {\n                searchInfo = searchTraces[i];\n                searchInfo._module.selectPoints(searchInfo, false);\n            }\n\n            updateSelectedState(gd, searchTraces);\n\n            clearSelectionsCache(dragOptions);\n\n            if(sendEvents) {\n                emitDeselect(gd);\n            }\n        } else {\n            subtract = evt.shiftKey &&\n              (pointOrBinSelected !== undefined ?\n                pointOrBinSelected :\n                isPointOrBinSelected(clickedPtInfo));\n            currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);\n\n            var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);\n            selectionTesters = multiTester(allSelectionDefs, selectionTesters);\n\n            for(i = 0; i < searchTraces.length; i++) {\n                traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTesters);\n                thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);\n\n                if(selection.length) {\n                    for(var j = 0; j < thisTracesSelection.length; j++) {\n                        selection.push(thisTracesSelection[j]);\n                    }\n                } else selection = thisTracesSelection;\n            }\n\n            eventData = {points: selection};\n            updateSelectedState(gd, searchTraces, eventData);\n\n            if(currentSelectionDef && dragOptions) {\n                dragOptions.selectionDefs.push(currentSelectionDef);\n            }\n\n            if(polygonOutlines) {\n                var polygons = dragOptions.mergedPolygons;\n                var isOpenMode = openMode(dragOptions.dragmode);\n\n                // display polygons on the screen\n                displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);\n            }\n\n            if(sendEvents) {\n                emitSelected(gd, eventData);\n            }\n        }\n    }\n}\n\n/**\n * Constructs a new point selection definition object.\n */\nfunction newPointSelectionDef(pointNumber, searchInfo, subtract) {\n    return {\n        pointNumber: pointNumber,\n        searchInfo: searchInfo,\n        subtract: !!subtract\n    };\n}\n\nfunction isPointSelectionDef(o) {\n    return 'pointNumber' in o && 'searchInfo' in o;\n}\n\n/*\n * Constructs a new point number tester.\n */\nfunction newPointNumTester(pointSelectionDef) {\n    return {\n        xmin: 0,\n        xmax: 0,\n        ymin: 0,\n        ymax: 0,\n        pts: [],\n        contains: function(pt, omitFirstEdge, pointNumber, searchInfo) {\n            var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;\n            var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;\n            return idxActualTrace === idxWantedTrace &&\n              pointNumber === pointSelectionDef.pointNumber;\n        },\n        isRect: false,\n        degenerate: false,\n        subtract: !!pointSelectionDef.subtract\n    };\n}\n\n/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */\nfunction multiTester(list) {\n    if(!list.length) return;\n\n    var testers = [];\n    var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];\n    var xmax = xmin;\n    var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];\n    var ymax = ymin;\n\n    for(var i = 0; i < list.length; i++) {\n        if(isPointSelectionDef(list[i])) {\n            testers.push(newPointNumTester(list[i]));\n        } else {\n            var tester = polygonTester(list[i]);\n            tester.subtract = !!list[i].subtract;\n            testers.push(tester);\n\n            xmin = Math.min(xmin, tester.xmin);\n            xmax = Math.max(xmax, tester.xmax);\n            ymin = Math.min(ymin, tester.ymin);\n            ymax = Math.max(ymax, tester.ymax);\n        }\n    }\n\n    /**\n     * Tests if the given point is within this tester.\n     *\n     * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n     * @param {*} arg - An optional parameter to pass down to wrapped testers.\n     * @param {number} pointNumber - The point number of the point within the underlying data array.\n     * @param {number} searchInfo - An object identifying the trace the point is contained in.\n     *\n     * @return {boolean} true if point is considered to be selected, false otherwise.\n     */\n    function contains(pt, arg, pointNumber, searchInfo) {\n        var contained = false;\n        for(var i = 0; i < testers.length; i++) {\n            if(testers[i].contains(pt, arg, pointNumber, searchInfo)) {\n                // if contained by subtract tester - exclude the point\n                contained = !testers[i].subtract;\n            }\n        }\n\n        return contained;\n    }\n\n    return {\n        xmin: xmin,\n        xmax: xmax,\n        ymin: ymin,\n        ymax: ymax,\n        pts: [],\n        contains: contains,\n        isRect: false,\n        degenerate: false\n    };\n}\n\nfunction coerceSelectionsCache(evt, gd, dragOptions) {\n    var fullLayout = gd._fullLayout;\n    var plotinfo = dragOptions.plotinfo;\n    var dragmode = dragOptions.dragmode;\n\n    var selectingOnSameSubplot = (\n        fullLayout._lastSelectedSubplot &&\n        fullLayout._lastSelectedSubplot === plotinfo.id\n    );\n\n    var hasModifierKey = (evt.shiftKey || evt.altKey) &&\n        !(drawMode(dragmode) && openMode(dragmode));\n\n    if(\n        selectingOnSameSubplot &&\n        hasModifierKey &&\n        plotinfo.selection &&\n        plotinfo.selection.selectionDefs &&\n        !dragOptions.selectionDefs\n    ) {\n        // take over selection definitions from prev mode, if any\n        dragOptions.selectionDefs = plotinfo.selection.selectionDefs;\n        dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n    } else if(!hasModifierKey || !plotinfo.selection) {\n        clearSelectionsCache(dragOptions);\n    }\n\n    // clear selection outline when selecting a different subplot\n    if(!selectingOnSameSubplot) {\n        clearOutline(gd);\n        fullLayout._lastSelectedSubplot = plotinfo.id;\n    }\n}\n\nfunction hasActiveShape(gd) {\n    return gd._fullLayout._activeShapeIndex >= 0;\n}\n\nfunction hasActiveSelection(gd) {\n    return gd._fullLayout._activeSelectionIndex >= 0;\n}\n\nfunction clearSelectionsCache(dragOptions, immediateSelect) {\n    var dragmode = dragOptions.dragmode;\n    var plotinfo = dragOptions.plotinfo;\n\n    var gd = dragOptions.gd;\n    if(hasActiveShape(gd)) {\n        gd._fullLayout._deactivateShape(gd);\n    }\n    if(hasActiveSelection(gd)) {\n        gd._fullLayout._deactivateSelection(gd);\n    }\n\n    var fullLayout = gd._fullLayout;\n    var zoomLayer = fullLayout._zoomlayer;\n\n    var isDrawMode = drawMode(dragmode);\n    var isSelectMode = selectMode(dragmode);\n\n    if(isDrawMode || isSelectMode) {\n        var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n        if(outlines && gd._fullLayout._outlining) {\n            // add shape\n            var shapes;\n            if(isDrawMode) {\n                shapes = newShapes(outlines, dragOptions);\n            }\n            if(shapes) {\n                Registry.call('_guiRelayout', gd, {\n                    shapes: shapes\n                });\n            }\n\n            // add selection\n            var selections;\n            if(\n                isSelectMode &&\n                !hasSubplot(dragOptions) // only allow cartesian - no mapbox for now\n            ) {\n                selections = newSelections(outlines, dragOptions);\n            }\n            if(selections) {\n                gd._fullLayout._noEmitSelectedAtStart = true;\n\n                Registry.call('_guiRelayout', gd, {\n                    selections: selections\n                }).then(function() {\n                    if(immediateSelect) { activateLastSelection(gd); }\n                });\n            }\n\n            gd._fullLayout._outlining = false;\n        }\n    }\n\n    plotinfo.selection = {};\n    plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];\n    plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n}\n\nfunction getAxId(ax) {\n    return ax._id;\n}\n\nfunction determineSearchTraces(gd, xAxes, yAxes, subplot) {\n    if(!gd.calcdata) return [];\n\n    var searchTraces = [];\n    var xAxisIds = xAxes.map(getAxId);\n    var yAxisIds = yAxes.map(getAxId);\n    var cd, trace, i;\n\n    for(i = 0; i < gd.calcdata.length; i++) {\n        cd = gd.calcdata[i];\n        trace = cd[0].trace;\n\n        if(trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n\n        if(\n            hasSubplot({subplot: subplot}) &&\n            (trace.subplot === subplot || trace.geo === subplot)\n        ) {\n            searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));\n        } else if(trace.type === 'splom') {\n            // FIXME: make sure we don't have more than single axis for splom\n            if(trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {\n                var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n                info.scene = gd._fullLayout._splomScenes[trace.uid];\n                searchTraces.push(info);\n            }\n        } else if(trace.type === 'sankey') {\n            var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n            searchTraces.push(sankeyInfo);\n        } else {\n            if(xAxisIds.indexOf(trace.xaxis) === -1) continue;\n            if(yAxisIds.indexOf(trace.yaxis) === -1) continue;\n\n            searchTraces.push(createSearchInfo(trace._module, cd,\n              getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));\n        }\n    }\n\n    return searchTraces;\n}\n\nfunction createSearchInfo(module, calcData, xaxis, yaxis) {\n    return {\n        _module: module,\n        cd: calcData,\n        xaxis: xaxis,\n        yaxis: yaxis\n    };\n}\n\nfunction isHoverDataSet(hoverData) {\n    return hoverData &&\n      Array.isArray(hoverData) &&\n      hoverData[0].hoverOnBox !== true;\n}\n\nfunction extractClickedPtInfo(hoverData, searchTraces) {\n    var hoverDatum = hoverData[0];\n    var pointNumber = -1;\n    var pointNumbers = [];\n    var searchInfo, i;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        if(hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {\n            // Special case for box (and violin)\n            if(hoverDatum.hoverOnBox === true) {\n                break;\n            }\n\n            // Hint: in some traces like histogram, one graphical element\n            // doesn't correspond to one particular data point, but to\n            // bins of data points. Thus, hoverDatum can have a binNumber\n            // property instead of pointNumber.\n            if(hoverDatum.pointNumber !== undefined) {\n                pointNumber = hoverDatum.pointNumber;\n            } else if(hoverDatum.binNumber !== undefined) {\n                pointNumber = hoverDatum.binNumber;\n                pointNumbers = hoverDatum.pointNumbers;\n            }\n\n            break;\n        }\n    }\n\n    return {\n        pointNumber: pointNumber,\n        pointNumbers: pointNumbers,\n        searchInfo: searchInfo\n    };\n}\n\nfunction isPointOrBinSelected(clickedPtInfo) {\n    var trace = clickedPtInfo.searchInfo.cd[0].trace;\n    var ptNum = clickedPtInfo.pointNumber;\n    var ptNums = clickedPtInfo.pointNumbers;\n    var ptNumsSet = ptNums.length > 0;\n\n    // When pointsNumbers is set (e.g. histogram's binning),\n    // it is assumed that when the first point of\n    // a bin is selected, all others are as well\n    var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum;\n\n    // TODO potential performance improvement\n    // Primarily we need this function to determine if a click adds\n    // or subtracts from a selection.\n    // In cases `trace.selectedpoints` is a huge array, indexOf\n    // might be slow. One remedy would be to introduce a hash somewhere.\n    return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;\n}\n\nfunction isOnlyThisBinSelected(searchTraces, clickedPtInfo) {\n    var tracesWithSelectedPts = [];\n    var searchInfo, trace, isSameTrace, i;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        if(searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {\n            tracesWithSelectedPts.push(searchInfo);\n        }\n    }\n\n    if(tracesWithSelectedPts.length === 1) {\n        isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;\n        if(isSameTrace) {\n            trace = clickedPtInfo.searchInfo.cd[0].trace;\n            if(trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {\n                for(i = 0; i < clickedPtInfo.pointNumbers.length; i++) {\n                    if(trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction isOnlyOnePointSelected(searchTraces) {\n    var len = 0;\n    var searchInfo, trace, i;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        trace = searchInfo.cd[0].trace;\n        if(trace.selectedpoints) {\n            if(trace.selectedpoints.length > 1) return false;\n\n            len += trace.selectedpoints.length;\n            if(len > 1) return false;\n        }\n    }\n\n    return len === 1;\n}\n\nfunction updateSelectedState(gd, searchTraces, eventData) {\n    var i;\n\n    // before anything else, update preGUI if necessary\n    for(i = 0; i < searchTraces.length; i++) {\n        var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;\n        var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};\n        if(tracePreGUI.selectedpoints === undefined) {\n            tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;\n        }\n    }\n\n    var trace;\n    if(eventData) {\n        var pts = eventData.points || [];\n        for(i = 0; i < searchTraces.length; i++) {\n            trace = searchTraces[i].cd[0].trace;\n            trace._input.selectedpoints = trace._fullInput.selectedpoints = [];\n            if(trace._fullInput !== trace) trace.selectedpoints = [];\n        }\n\n        for(var k = 0; k < pts.length; k++) {\n            var pt = pts[k];\n            var data = pt.data;\n            var fullData = pt.fullData;\n            var pointIndex = pt.pointIndex;\n            var pointIndices = pt.pointIndices;\n            if(pointIndices) {\n                [].push.apply(data.selectedpoints, pointIndices);\n                if(trace._fullInput !== trace) {\n                    [].push.apply(fullData.selectedpoints, pointIndices);\n                }\n            } else {\n                data.selectedpoints.push(pointIndex);\n                if(trace._fullInput !== trace) {\n                    fullData.selectedpoints.push(pointIndex);\n                }\n            }\n        }\n    } else {\n        for(i = 0; i < searchTraces.length; i++) {\n            trace = searchTraces[i].cd[0].trace;\n            delete trace.selectedpoints;\n            delete trace._input.selectedpoints;\n            if(trace._fullInput !== trace) {\n                delete trace._fullInput.selectedpoints;\n            }\n        }\n    }\n\n    updateReglSelectedState(gd, searchTraces);\n}\n\nfunction updateReglSelectedState(gd, searchTraces) {\n    var hasRegl = false;\n\n    for(var i = 0; i < searchTraces.length; i++) {\n        var searchInfo = searchTraces[i];\n        var cd = searchInfo.cd;\n\n        if(Registry.traceIs(cd[0].trace, 'regl')) {\n            hasRegl = true;\n        }\n\n        var _module = searchInfo._module;\n        var fn = _module.styleOnSelect || _module.style;\n        if(fn) {\n            fn(gd, cd, cd[0].node3);\n            if(cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);\n        }\n    }\n\n    if(hasRegl) {\n        clearGlCanvases(gd);\n        redrawReglTraces(gd);\n    }\n}\n\nfunction mergePolygons(list, poly, subtract) {\n    var fn = subtract ?\n        polybool.difference :\n        polybool.union;\n\n    var res = fn({\n        regions: list\n    }, {\n        regions: [poly]\n    });\n\n    var allPolygons = res.regions.reverse();\n\n    for(var i = 0; i < allPolygons.length; i++) {\n        var polygon = allPolygons[i];\n\n        polygon.subtract = getSubtract(polygon, allPolygons.slice(0, i));\n    }\n\n    return allPolygons;\n}\n\nfunction fillSelectionItem(selection, searchInfo) {\n    if(Array.isArray(selection)) {\n        var cd = searchInfo.cd;\n        var trace = searchInfo.cd[0].trace;\n\n        for(var i = 0; i < selection.length; i++) {\n            selection[i] = makeEventData(selection[i], trace, cd);\n        }\n    }\n\n    return selection;\n}\n\nfunction convertPoly(polygonsIn, isOpenMode) { // add M and L command to draft positions\n    var polygonsOut = [];\n    for(var i = 0; i < polygonsIn.length; i++) {\n        polygonsOut[i] = [];\n        for(var j = 0; j < polygonsIn[i].length; j++) {\n            polygonsOut[i][j] = [];\n            polygonsOut[i][j][0] = j ? 'L' : 'M';\n            for(var k = 0; k < polygonsIn[i][j].length; k++) {\n                polygonsOut[i][j].push(\n                    polygonsIn[i][j][k]\n                );\n            }\n        }\n\n        if(!isOpenMode) {\n            polygonsOut[i].push([\n                'Z',\n                polygonsOut[i][0][1], // initial x\n                polygonsOut[i][0][2]  // initial y\n            ]);\n        }\n    }\n\n    return polygonsOut;\n}\n\nfunction _doSelect(selectionTesters, searchTraces) {\n    var allSelections = [];\n\n    var thisSelection;\n    var traceSelections = [];\n    var traceSelection;\n    for(var i = 0; i < searchTraces.length; i++) {\n        var searchInfo = searchTraces[i];\n\n        traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTesters);\n        traceSelections.push(traceSelection);\n\n        thisSelection = fillSelectionItem(traceSelection, searchInfo);\n\n        allSelections = allSelections.concat(thisSelection);\n    }\n\n    return allSelections;\n}\n\nfunction reselect(gd, mayEmitSelected, selectionTesters, searchTraces, dragOptions) {\n    var hadSearchTraces = !!searchTraces;\n    var plotinfo, xRef, yRef;\n    if(dragOptions) {\n        plotinfo = dragOptions.plotinfo;\n        xRef = dragOptions.xaxes[0]._id;\n        yRef = dragOptions.yaxes[0]._id;\n    }\n\n    var allSelections = [];\n    var allSearchTraces = [];\n\n    // select layout.selection polygons\n    var layoutPolygons = getLayoutPolygons(gd);\n\n    // add draft outline polygons to layoutPolygons\n    var fullLayout = gd._fullLayout;\n    if(plotinfo) {\n        var zoomLayer = fullLayout._zoomlayer;\n        var mode = fullLayout.dragmode;\n        var isDrawMode = drawMode(mode);\n        var isSelectMode = selectMode(mode);\n        if(isDrawMode || isSelectMode) {\n            var xaxis = getFromId(gd, xRef, 'x');\n            var yaxis = getFromId(gd, yRef, 'y');\n            if(xaxis && yaxis) {\n                var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n                if(outlines && gd._fullLayout._outlining) {\n                    if(outlines.length) {\n                        var e = outlines[0][0]; // pick first\n                        var d = e.getAttribute('d');\n                        var outlinePolys = readPaths(d, gd, plotinfo);\n\n                        var draftPolygons = [];\n                        for(var u = 0; u < outlinePolys.length; u++) {\n                            var p = outlinePolys[u];\n                            var polygon = [];\n                            for(var t = 0; t < p.length; t++) {\n                                polygon.push([\n                                    convert(xaxis, p[t][1]),\n                                    convert(yaxis, p[t][2])\n                                ]);\n                            }\n\n                            polygon.xref = xRef;\n                            polygon.yref = yRef;\n                            polygon.subtract = getSubtract(polygon, draftPolygons);\n\n                            draftPolygons.push(polygon);\n                        }\n\n                        layoutPolygons = layoutPolygons.concat(draftPolygons);\n                    }\n                }\n            }\n        }\n    }\n\n    var subplots = (xRef && yRef) ? [xRef + yRef] :\n        fullLayout._subplots.cartesian;\n\n    epmtySplomSelectionBatch(gd);\n\n    var seenSplom = {};\n\n    for(var i = 0; i < subplots.length; i++) {\n        var subplot = subplots[i];\n        var yAt = subplot.indexOf('y');\n        var _xRef = subplot.slice(0, yAt);\n        var _yRef = subplot.slice(yAt);\n\n        var _selectionTesters = (xRef && yRef) ? selectionTesters : undefined;\n        _selectionTesters = addTester(layoutPolygons, _xRef, _yRef, _selectionTesters);\n\n        if(_selectionTesters) {\n            var _searchTraces = searchTraces;\n            if(!hadSearchTraces) {\n                var _xA = getFromId(gd, _xRef, 'x');\n                var _yA = getFromId(gd, _yRef, 'y');\n\n                _searchTraces = determineSearchTraces(\n                    gd,\n                    [_xA],\n                    [_yA],\n                    subplot\n                );\n\n                for(var w = 0; w < _searchTraces.length; w++) {\n                    var s = _searchTraces[w];\n                    var cd0 = s.cd[0];\n                    var trace = cd0.trace;\n\n                    if(s._module.name === 'scattergl' && !cd0.t.xpx) {\n                        var x = trace.x;\n                        var y = trace.y;\n                        var len = trace._length;\n                        // generate stash for scattergl\n                        cd0.t.xpx = [];\n                        cd0.t.ypx = [];\n                        for(var j = 0; j < len; j++) {\n                            cd0.t.xpx[j] = _xA.c2p(x[j]);\n                            cd0.t.ypx[j] = _yA.c2p(y[j]);\n                        }\n                    }\n\n                    if(s._module.name === 'splom') {\n                        if(!seenSplom[trace.uid]) {\n                            seenSplom[trace.uid] = true;\n                        }\n                    }\n                }\n            }\n            var selection = _doSelect(_selectionTesters, _searchTraces);\n\n            allSelections = allSelections.concat(selection);\n            allSearchTraces = allSearchTraces.concat(_searchTraces);\n        }\n    }\n\n    var eventData = {points: allSelections};\n    updateSelectedState(gd, allSearchTraces, eventData);\n\n    var clickmode = fullLayout.clickmode;\n    var sendEvents = clickmode.indexOf('event') > -1 && mayEmitSelected;\n\n    if(\n        !plotinfo && // get called from plot_api & plots\n        mayEmitSelected\n    ) {\n        var activePolygons = getLayoutPolygons(gd, true);\n\n        if(activePolygons.length) {\n            var xref = activePolygons[0].xref;\n            var yref = activePolygons[0].yref;\n            if(xref && yref) {\n                var poly = castMultiPolygon(activePolygons);\n\n                var fillRangeItems = makeFillRangeItems([\n                    getFromId(gd, xref, 'x'),\n                    getFromId(gd, yref, 'y')\n                ]);\n\n                fillRangeItems(eventData, poly);\n            }\n        }\n\n        if(gd._fullLayout._noEmitSelectedAtStart) {\n            gd._fullLayout._noEmitSelectedAtStart = false;\n        } else {\n            if(sendEvents) emitSelected(gd, eventData);\n        }\n\n        fullLayout._reselect = false;\n    }\n\n    if(\n        !plotinfo && // get called from plot_api & plots\n        fullLayout._deselect\n    ) {\n        var deselect = fullLayout._deselect;\n        xRef = deselect.xref;\n        yRef = deselect.yref;\n\n        if(!subplotSelected(xRef, yRef, allSearchTraces)) {\n            deselectSubplot(gd, xRef, yRef, searchTraces);\n        }\n\n        if(sendEvents) {\n            if(eventData.points.length) {\n                emitSelected(gd, eventData);\n            } else {\n                emitDeselect(gd);\n            }\n        }\n\n        fullLayout._deselect = false;\n    }\n\n    return {\n        eventData: eventData,\n        selectionTesters: selectionTesters\n    };\n}\n\nfunction epmtySplomSelectionBatch(gd) {\n    var cd = gd.calcdata;\n    if(!cd) return;\n\n    for(var i = 0; i < cd.length; i++) {\n        var cd0 = cd[i][0];\n        var trace = cd0.trace;\n        var splomScenes = gd._fullLayout._splomScenes;\n        if(splomScenes) {\n            var scene = splomScenes[trace.uid];\n            if(scene) {\n                scene.selectBatch = [];\n            }\n        }\n    }\n}\n\nfunction subplotSelected(xRef, yRef, searchTraces) {\n    for(var i = 0; i < searchTraces.length; i++) {\n        var s = searchTraces[i];\n        if(\n            (s.xaxis && s.xaxis._id === xRef) &&\n            (s.yaxis && s.yaxis._id === yRef)\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction deselectSubplot(gd, xRef, yRef, searchTraces) {\n    searchTraces = determineSearchTraces(\n        gd,\n        [getFromId(gd, xRef, 'x')],\n        [getFromId(gd, yRef, 'y')],\n        xRef + yRef\n    );\n\n    for(var k = 0; k < searchTraces.length; k++) {\n        var searchInfo = searchTraces[k];\n        searchInfo._module.selectPoints(searchInfo, false);\n    }\n\n    updateSelectedState(gd, searchTraces);\n}\n\nfunction addTester(layoutPolygons, xRef, yRef, selectionTesters) {\n    var mergedPolygons;\n\n    for(var i = 0; i < layoutPolygons.length; i++) {\n        var currentPolygon = layoutPolygons[i];\n        if(xRef !== currentPolygon.xref || yRef !== currentPolygon.yref) continue;\n\n        if(mergedPolygons) {\n            var subtract = !!currentPolygon.subtract;\n            mergedPolygons = mergePolygons(mergedPolygons, currentPolygon, subtract);\n            selectionTesters = multiTester(mergedPolygons);\n        } else {\n            mergedPolygons = [currentPolygon];\n            selectionTesters = polygonTester(currentPolygon);\n        }\n    }\n\n    return selectionTesters;\n}\n\nfunction getLayoutPolygons(gd, onlyActiveOnes) {\n    var allPolygons = [];\n\n    var fullLayout = gd._fullLayout;\n    var allSelections = fullLayout.selections;\n    var len = allSelections.length;\n\n    for(var i = 0; i < len; i++) {\n        if(onlyActiveOnes && i !== fullLayout._activeSelectionIndex) continue;\n\n        var selection = allSelections[i];\n        if(!selection) continue;\n\n        var xref = selection.xref;\n        var yref = selection.yref;\n\n        var xaxis = getFromId(gd, xref, 'x');\n        var yaxis = getFromId(gd, yref, 'y');\n\n        var xmin, xmax, ymin, ymax;\n\n        var polygon;\n        if(selection.type === 'rect') {\n            polygon = [];\n\n            var x0 = convert(xaxis, selection.x0);\n            var x1 = convert(xaxis, selection.x1);\n            var y0 = convert(yaxis, selection.y0);\n            var y1 = convert(yaxis, selection.y1);\n            polygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n\n            xmin = Math.min(x0, x1);\n            xmax = Math.max(x0, x1);\n            ymin = Math.min(y0, y1);\n            ymax = Math.max(y0, y1);\n\n            polygon.xmin = xmin;\n            polygon.xmax = xmax;\n            polygon.ymin = ymin;\n            polygon.ymax = ymax;\n\n            polygon.xref = xref;\n            polygon.yref = yref;\n\n            polygon.subtract = false;\n            polygon.isRect = true;\n\n            allPolygons.push(polygon);\n        } else if(selection.type === 'path') {\n            var segments = selection.path.split('Z');\n\n            var multiPolygons = [];\n            for(var j = 0; j < segments.length; j++) {\n                var path = segments[j];\n                if(!path) continue;\n                path += 'Z';\n\n                var allX = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsX, 'raw');\n                var allY = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsY, 'raw');\n\n                xmin = Infinity;\n                xmax = -Infinity;\n                ymin = Infinity;\n                ymax = -Infinity;\n\n                polygon = [];\n\n                for(var k = 0; k < allX.length; k++) {\n                    var x = convert(xaxis, allX[k]);\n                    var y = convert(yaxis, allY[k]);\n\n                    polygon.push([x, y]);\n\n                    xmin = Math.min(x, xmin);\n                    xmax = Math.max(x, xmax);\n                    ymin = Math.min(y, ymin);\n                    ymax = Math.max(y, ymax);\n                }\n\n                polygon.xmin = xmin;\n                polygon.xmax = xmax;\n                polygon.ymin = ymin;\n                polygon.ymax = ymax;\n\n                polygon.xref = xref;\n                polygon.yref = yref;\n                polygon.subtract = getSubtract(polygon, multiPolygons);\n\n                multiPolygons.push(polygon);\n                allPolygons.push(polygon);\n            }\n        }\n    }\n\n    return allPolygons;\n}\n\nfunction getSubtract(polygon, previousPolygons) {\n    var subtract = false;\n    for(var i = 0; i < previousPolygons.length; i++) {\n        var previousPolygon = previousPolygons[i];\n\n        // find out if a point of polygon is inside previous polygons\n        for(var k = 0; k < polygon.length; k++) {\n            if(pointInPolygon(polygon[k], previousPolygon)) {\n                subtract = !subtract;\n                break;\n            }\n        }\n    }\n    return subtract;\n}\n\nfunction convert(ax, d) {\n    if(ax.type === 'date') d = d.replace('_', ' ');\n    return ax.type === 'log' ? ax.c2p(d) : ax.r2p(d, null, ax.calendar);\n}\n\nfunction castMultiPolygon(allPolygons) {\n    var len = allPolygons.length;\n\n    // descibe multi polygons in one polygon\n    var p = [];\n    for(var i = 0; i < len; i++) {\n        var polygon = allPolygons[i];\n        p = p.concat(polygon);\n\n        // add starting vertex to close\n        // which indicates next polygon\n        p = p.concat([polygon[0]]);\n    }\n\n    return computeRectAndRanges(p);\n}\n\nfunction computeRectAndRanges(poly) {\n    poly.isRect = poly.length === 5 &&\n        poly[0][0] === poly[4][0] &&\n        poly[0][1] === poly[4][1] &&\n        (\n            poly[0][0] === poly[1][0] &&\n            poly[2][0] === poly[3][0] &&\n            poly[0][1] === poly[3][1] &&\n            poly[1][1] === poly[2][1]\n        ) ||\n        (\n            poly[0][1] === poly[1][1] &&\n            poly[2][1] === poly[3][1] &&\n            poly[0][0] === poly[3][0] &&\n            poly[1][0] === poly[2][0]\n        );\n\n    if(poly.isRect) {\n        poly.xmin = Math.min(poly[0][0], poly[2][0]);\n        poly.xmax = Math.max(poly[0][0], poly[2][0]);\n        poly.ymin = Math.min(poly[0][1], poly[2][1]);\n        poly.ymax = Math.max(poly[0][1], poly[2][1]);\n    }\n\n    return poly;\n}\n\nfunction makeFillRangeItems(allAxes) {\n    return function(eventData, poly) {\n        var range;\n        var lassoPoints;\n\n        for(var i = 0; i < allAxes.length; i++) {\n            var ax = allAxes[i];\n            var id = ax._id;\n            var axLetter = id.charAt(0);\n\n            if(poly.isRect) {\n                if(!range) range = {};\n                var min = poly[axLetter + 'min'];\n                var max = poly[axLetter + 'max'];\n\n                if(min !== undefined && max !== undefined) {\n                    range[id] = [\n                        p2r(ax, min),\n                        p2r(ax, max)\n                    ].sort(ascending);\n                }\n            } else {\n                if(!lassoPoints) lassoPoints = {};\n                lassoPoints[id] = poly.map(axValue(ax));\n            }\n        }\n\n        if(range) {\n            eventData.range = range;\n        }\n\n        if(lassoPoints) {\n            eventData.lassoPoints = lassoPoints;\n        }\n    };\n}\n\nfunction getFillRangeItems(dragOptions) {\n    var plotinfo = dragOptions.plotinfo;\n\n    return (\n        plotinfo.fillRangeItems || // allow subplots (i.e. geo, mapbox, sankey) to override fillRangeItems routine\n        makeFillRangeItems(dragOptions.xaxes.concat(dragOptions.yaxes))\n    );\n}\n\nfunction emitSelecting(gd, eventData) {\n    gd.emit('plotly_selecting', eventData);\n}\n\nfunction emitSelected(gd, eventData) {\n    if(eventData) {\n        eventData.selections = (gd.layout || {}).selections || [];\n    }\n\n    gd.emit('plotly_selected', eventData);\n}\n\nfunction emitDeselect(gd) {\n    gd.emit('plotly_deselect', null);\n}\n\nmodule.exports = {\n    reselect: reselect,\n    prepSelect: prepSelect,\n    clearOutline: clearOutline,\n    clearSelectionsCache: clearSelectionsCache,\n    selectOnClick: selectOnClick\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}