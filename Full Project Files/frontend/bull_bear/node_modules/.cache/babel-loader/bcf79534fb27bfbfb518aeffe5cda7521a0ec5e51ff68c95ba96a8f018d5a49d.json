{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nfunction crossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var fullTraces = gd._fullData;\n  var calcTraces = gd.calcdata;\n  var calcTracesHorz = [];\n  var calcTracesVert = [];\n  for (var i = 0; i < fullTraces.length; i++) {\n    var fullTrace = fullTraces[i];\n    if (fullTrace.visible === true && Registry.traceIs(fullTrace, 'bar') && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {\n      if (fullTrace.orientation === 'h') {\n        calcTracesHorz.push(calcTraces[i]);\n      } else {\n        calcTracesVert.push(calcTraces[i]);\n      }\n      if (fullTrace._computePh) {\n        var cd = gd.calcdata[i];\n        for (var j = 0; j < cd.length; j++) {\n          if (typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();\n          if (typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();\n        }\n      }\n    }\n  }\n  var opts = {\n    xCat: xa.type === 'category' || xa.type === 'multicategory',\n    yCat: ya.type === 'category' || ya.type === 'multicategory',\n    mode: fullLayout.barmode,\n    norm: fullLayout.barnorm,\n    gap: fullLayout.bargap,\n    groupgap: fullLayout.bargroupgap\n  };\n  setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n  setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\nfunction setGroupPositions(gd, pa, sa, calcTraces, opts) {\n  if (!calcTraces.length) return;\n  var excluded;\n  var included;\n  var i, calcTrace, fullTrace;\n  initBase(sa, calcTraces);\n  switch (opts.mode) {\n    case 'overlay':\n      setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);\n      break;\n    case 'group':\n      // exclude from the group those traces for which the user set an offset\n      excluded = [];\n      included = [];\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.offset === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n      if (included.length) {\n        setGroupPositionsInGroupMode(gd, pa, sa, included, opts);\n      }\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n      break;\n    case 'stack':\n    case 'relative':\n      // exclude from the stack those traces for which the user set a base\n      excluded = [];\n      included = [];\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.base === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n      if (included.length) {\n        setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);\n      }\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n      break;\n  }\n  collectExtents(calcTraces, pa);\n}\nfunction initBase(sa, calcTraces) {\n  var i, j;\n  for (i = 0; i < calcTraces.length; i++) {\n    var cd = calcTraces[i];\n    var trace = cd[0].trace;\n    var base = trace.type === 'funnel' ? trace._base : trace.base;\n    var b;\n\n    // not sure if it really makes sense to have dates for bar size data...\n    // ideally if we want to make gantt charts or something we'd treat\n    // the actual size (trace.x or y) as time delta but base as absolute\n    // time. But included here for completeness.\n    var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar;\n\n    // 'base' on categorical axes makes no sense\n    var d2c = sa.type === 'category' || sa.type === 'multicategory' ? function () {\n      return null;\n    } : sa.d2c;\n    if (isArrayOrTypedArray(base)) {\n      for (j = 0; j < Math.min(base.length, cd.length); j++) {\n        b = d2c(base[j], 0, scalendar);\n        if (isNumeric(b)) {\n          cd[j].b = +b;\n          cd[j].hasB = 1;\n        } else cd[j].b = 0;\n      }\n      for (; j < cd.length; j++) {\n        cd[j].b = 0;\n      }\n    } else {\n      b = d2c(base, 0, scalendar);\n      var hasBase = isNumeric(b);\n      b = hasBase ? b : 0;\n      for (j = 0; j < cd.length; j++) {\n        cd[j].b = b;\n        if (hasBase) cd[j].hasB = 1;\n      }\n    }\n  }\n}\nfunction setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {\n  // update position axis and set bar offsets and widths\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var sieve = new Sieve([calcTrace], {\n      posAxis: pa,\n      sepNegVal: false,\n      overlapNoMerge: !opts.norm\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(pa, sieve, opts);\n\n    // set bar bases and sizes, and update size axis\n    //\n    // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n    // is defined, because this function is also invoked for traces that\n    // can't be grouped or stacked)\n    if (opts.norm) {\n      sieveBars(sieve);\n      normalizeBars(sa, sieve, opts);\n    } else {\n      setBaseAndTop(sa, sieve);\n    }\n  }\n}\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    posAxis: pa,\n    sepNegVal: false,\n    overlapNoMerge: !opts.norm\n  });\n\n  // set bar offsets and widths, and update position axis\n  setOffsetAndWidthInGroupMode(gd, pa, sieve, opts);\n\n  // relative-stack bars within the same trace that would otherwise\n  // be hidden\n  unhideBarsWithinTrace(sieve, pa);\n\n  // set bar bases and sizes, and update size axis\n  if (opts.norm) {\n    sieveBars(sieve);\n    normalizeBars(sa, sieve, opts);\n  } else {\n    setBaseAndTop(sa, sieve);\n  }\n}\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    posAxis: pa,\n    sepNegVal: opts.mode === 'relative',\n    overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')\n  });\n\n  // set bar offsets and widths, and update position axis\n  setOffsetAndWidth(pa, sieve, opts);\n\n  // set bar bases and sizes, and update size axis\n  stackBars(sa, sieve, opts);\n\n  // flag the outmost bar (for text display purposes)\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, bar.s);\n        if (isOutmostBar) bar._outmost = true;\n      }\n    }\n  }\n\n  // Note that marking the outmost bars has to be done\n  // before `normalizeBars` changes `bar.b` and `bar.s`.\n  if (opts.norm) normalizeBars(sa, sieve, opts);\n}\nfunction setOffsetAndWidth(pa, sieve, opts) {\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces;\n\n  // set bar offsets and widths\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var barWidthPlusGap = barGroupWidth;\n  var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n  // computer bar group center and bar offset\n  var offsetFromCenter = -barWidth / 2;\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n\n    // store bar width and offset for this trace\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  }\n\n  // stack bars that only differ by rounding\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n  // if defined, apply trace offset and width\n  applyAttributes(sieve);\n\n  // store the bar center in each calcdata item\n  setBarCenterAndWidth(pa, sieve);\n\n  // update position axes\n  updatePositionAxis(pa, sieve);\n}\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {\n  var fullLayout = gd._fullLayout;\n  var positions = sieve.positions;\n  var distinctPositions = sieve.distinctPositions;\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces;\n  var nTraces = calcTraces.length;\n\n  // if there aren't any overlapping positions,\n  // let them have full width even if mode is group\n  var overlap = positions.length !== distinctPositions.length;\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;\n  var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n  for (var i = 0; i < nTraces; i++) {\n    var calcTrace = calcTraces[i];\n    var trace = calcTrace[0].trace;\n    var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n    var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n    var barWidthPlusGap;\n    if (nOffsetGroups) {\n      barWidthPlusGap = barGroupWidth / nOffsetGroups;\n    } else {\n      barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n    }\n    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n    var offsetFromCenter;\n    if (nOffsetGroups) {\n      offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;\n    } else {\n      offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;\n    }\n    var t = calcTrace[0].t;\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  }\n\n  // stack bars that only differ by rounding\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n  // if defined, apply trace width\n  applyAttributes(sieve);\n\n  // store the bar center in each calcdata item\n  setBarCenterAndWidth(pa, sieve);\n\n  // update position axes\n  updatePositionAxis(pa, sieve, overlap);\n}\nfunction applyAttributes(sieve) {\n  var calcTraces = sieve.traces;\n  var i, j;\n  for (i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var t = calcTrace0.t;\n    var offset = fullTrace._offset || fullTrace.offset;\n    var initialPoffset = t.poffset;\n    var newPoffset;\n    if (isArrayOrTypedArray(offset)) {\n      // if offset is an array, then clone it into t.poffset.\n      newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);\n\n      // guard against non-numeric items\n      for (j = 0; j < newPoffset.length; j++) {\n        if (!isNumeric(newPoffset[j])) {\n          newPoffset[j] = initialPoffset;\n        }\n      }\n\n      // if the length of the array is too short,\n      // then extend it with the initial value of t.poffset\n      for (j = newPoffset.length; j < calcTrace.length; j++) {\n        newPoffset.push(initialPoffset);\n      }\n      t.poffset = newPoffset;\n    } else if (offset !== undefined) {\n      t.poffset = offset;\n    }\n    var width = fullTrace._width || fullTrace.width;\n    var initialBarwidth = t.barwidth;\n    if (isArrayOrTypedArray(width)) {\n      // if width is an array, then clone it into t.barwidth.\n      var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);\n\n      // guard against non-numeric items\n      for (j = 0; j < newBarwidth.length; j++) {\n        if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n      }\n\n      // if the length of the array is too short,\n      // then extend it with the initial value of t.barwidth\n      for (j = newBarwidth.length; j < calcTrace.length; j++) {\n        newBarwidth.push(initialBarwidth);\n      }\n      t.barwidth = newBarwidth;\n\n      // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n      if (offset === undefined) {\n        newPoffset = [];\n        for (j = 0; j < calcTrace.length; j++) {\n          newPoffset.push(initialPoffset + (initialBarwidth - newBarwidth[j]) / 2);\n        }\n        t.poffset = newPoffset;\n      }\n    } else if (width !== undefined) {\n      t.barwidth = width;\n\n      // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n      if (offset === undefined) {\n        t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n      }\n    }\n  }\n}\nfunction setBarCenterAndWidth(pa, sieve) {\n  var calcTraces = sieve.traces;\n  var pLetter = getAxisLetter(pa);\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n    var poffset = t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n    var barwidth = t.barwidth;\n    var barwidthIsArray = Array.isArray(barwidth);\n    for (var j = 0; j < calcTrace.length; j++) {\n      var calcBar = calcTrace[j];\n\n      // store the actual bar width and position, for use by hover\n      var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n      if (calcBar.p === undefined) {\n        calcBar.p = calcBar[pLetter];\n        calcBar['orig_' + pLetter] = calcBar[pLetter];\n      }\n      var delta = (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n      calcBar[pLetter] = calcBar.p + delta;\n    }\n  }\n}\nfunction updatePositionAxis(pa, sieve, allowMinDtick) {\n  var calcTraces = sieve.traces;\n  var minDiff = sieve.minDiff;\n  var vpad = minDiff / 2;\n  Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var pts = [];\n    var bar, l, r, j;\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n      l = bar.p - vpad;\n      r = bar.p + vpad;\n      pts.push(l, r);\n    }\n    if (fullTrace.width || fullTrace.offset) {\n      var t = calcTrace0.t;\n      var poffset = t.poffset;\n      var barwidth = t.barwidth;\n      var poffsetIsArray = Array.isArray(poffset);\n      var barwidthIsArray = Array.isArray(barwidth);\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n        var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n        var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n        l = bar.p + calcBarOffset;\n        r = l + calcBarWidth;\n        pts.push(l, r);\n      }\n    }\n    fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {\n      padded: false\n    });\n  }\n}\n\n// store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\nfunction setBaseAndTop(sa, sieve) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var isScatter = fullTrace.type === 'scatter';\n    var isVertical = fullTrace.orientation === 'v';\n    var pts = [];\n    var tozero = false;\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      var base = isScatter ? 0 : bar.b;\n      var top = isScatter ? isVertical ? bar.y : bar.x : base + bar.s;\n      bar[sLetter] = top;\n      pts.push(top);\n      if (bar.hasB) pts.push(base);\n      if (!bar.hasB || !bar.b) {\n        tozero = true;\n      }\n    }\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: true\n    });\n  }\n}\nfunction stackBars(sa, sieve, opts) {\n  var sLetter = getAxisLetter(sa);\n  var calcTraces = sieve.traces;\n  var calcTrace;\n  var fullTrace;\n  var isFunnel;\n  var i, j;\n  var bar;\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n    if (fullTrace.type === 'funnel') {\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n        if (bar.s !== BADNUM) {\n          // create base of funnels\n          sieve.put(bar.p, -0.5 * bar.s);\n        }\n      }\n    }\n  }\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n    isFunnel = fullTrace.type === 'funnel';\n    var pts = [];\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        // stack current bar and get previous sum\n        var value;\n        if (isFunnel) {\n          value = bar.s;\n        } else {\n          value = bar.s + bar.b;\n        }\n        var base = sieve.put(bar.p, value);\n        var top = base + value;\n\n        // store the bar base and top in each calcdata item\n        bar.b = base;\n        bar[sLetter] = top;\n        if (!opts.norm) {\n          pts.push(top);\n          if (bar.hasB) {\n            pts.push(base);\n          }\n        }\n      }\n    }\n\n    // if barnorm is set, let normalizeBars update the axis range\n    if (!opts.norm) {\n      fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n        // N.B. we don't stack base with 'base',\n        // so set tozero:true always!\n        tozero: true,\n        padded: true\n      });\n    }\n  }\n}\nfunction sieveBars(sieve) {\n  var calcTraces = sieve.traces;\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        sieve.put(bar.p, bar.b + bar.s);\n      }\n    }\n  }\n}\nfunction unhideBarsWithinTrace(sieve, pa) {\n  var calcTraces = sieve.traces;\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    if (fullTrace.base === undefined) {\n      var inTraceSieve = new Sieve([calcTrace], {\n        posAxis: pa,\n        sepNegVal: true,\n        overlapNoMerge: true\n      });\n      for (var j = 0; j < calcTrace.length; j++) {\n        var bar = calcTrace[j];\n        if (bar.p !== BADNUM) {\n          // stack current bar and get previous sum\n          var base = inTraceSieve.put(bar.p, bar.b + bar.s);\n\n          // if previous sum if non-zero, this means:\n          // multiple bars have same starting point are potentially hidden,\n          // shift them vertically so that all bars are visible by default\n          if (base) bar.b = base;\n        }\n      }\n    }\n  }\n}\n\n// Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\nfunction normalizeBars(sa, sieve, opts) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n  var sTop = opts.norm === 'fraction' ? 1 : 100;\n  var sTiny = sTop / 1e9; // in case of rounding error in sum\n  var sMin = sa.l2c(sa.c2l(0));\n  var sMax = opts.mode === 'stack' ? sTop : sMin;\n  function needsPadding(v) {\n    return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));\n  }\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var tozero = false;\n    var padded = false;\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n        bar.b *= scale;\n        bar.s *= scale;\n        var base = bar.b;\n        var top = base + bar.s;\n        bar[sLetter] = top;\n        pts.push(top);\n        padded = padded || needsPadding(top);\n        if (bar.hasB) {\n          pts.push(base);\n          padded = padded || needsPadding(base);\n        }\n        if (!bar.hasB || !bar.b) {\n          tozero = true;\n        }\n      }\n    }\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: padded\n    });\n  }\n}\n\n// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces, pa) {\n  var pLetter = getAxisLetter(pa);\n  var extents = {};\n  var i, j, cd;\n  var pMin = Infinity;\n  var pMax = -Infinity;\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n    for (j = 0; j < cd.length; j++) {\n      var p = cd[j].p;\n      if (isNumeric(p)) {\n        pMin = Math.min(pMin, p);\n        pMax = Math.max(pMax, p);\n      }\n    }\n  }\n\n  // this is just for positioning of hover labels, and nobody will care if\n  // the label is 1px too far out; so round positions to 1/10K in case\n  // position values don't exactly match from trace to trace\n  var roundFactor = 10000 / (pMax - pMin);\n  var round = extents.round = function (p) {\n    return String(Math.round(roundFactor * (p - pMin)));\n  };\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n    cd[0].t.extents = extents;\n    var poffset = cd[0].t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n    for (j = 0; j < cd.length; j++) {\n      var di = cd[j];\n      var p0 = di[pLetter] - di.w / 2;\n      if (isNumeric(p0)) {\n        var p1 = di[pLetter] + di.w / 2;\n        var pVal = round(di.p);\n        if (extents[pVal]) {\n          extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n        } else {\n          extents[pVal] = [p0, p1];\n        }\n      }\n      di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n      di.p1 = di.p0 + di.w;\n      di.s0 = di.b;\n      di.s1 = di.s0 + di.s;\n    }\n  }\n}\nfunction getAxisLetter(ax) {\n  return ax._id.charAt(0);\n}\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setGroupPositions: setGroupPositions\n};","map":{"version":3,"names":["isNumeric","require","isArrayOrTypedArray","BADNUM","Registry","Axes","getAxisGroup","Sieve","crossTraceCalc","gd","plotinfo","xa","xaxis","ya","yaxis","fullLayout","_fullLayout","fullTraces","_fullData","calcTraces","calcdata","calcTracesHorz","calcTracesVert","i","length","fullTrace","visible","traceIs","_id","orientation","push","_computePh","cd","j","ph0","ph1","opts","xCat","type","yCat","mode","barmode","norm","barnorm","gap","bargap","groupgap","bargroupgap","setGroupPositions","pa","sa","excluded","included","calcTrace","initBase","setGroupPositionsInOverlayMode","trace","offset","undefined","setGroupPositionsInGroupMode","base","setGroupPositionsInStackOrRelativeMode","collectExtents","_base","b","scalendar","xcalendar","ycalendar","d2c","Math","min","hasB","hasBase","sieve","posAxis","sepNegVal","overlapNoMerge","setOffsetAndWidth","sieveBars","normalizeBars","setBaseAndTop","setOffsetAndWidthInGroupMode","unhideBarsWithinTrace","stackBars","bar","s","isOutmostBar","get","p","_outmost","minDiff","traces","barGroupWidth","barWidthPlusGap","barWidth","offsetFromCenter","t","barwidth","poffset","bargroupwidth","bardelta","binWidth","applyAttributes","setBarCenterAndWidth","updatePositionAxis","positions","distinctPositions","nTraces","overlap","groupId","alignmentGroups","_alignmentOpts","alignmentGroupOpts","alignmentgroup","nOffsetGroups","Object","keys","offsetGroups","_offsetIndex","calcTrace0","_offset","initialPoffset","newPoffset","Array","prototype","slice","call","width","_width","initialBarwidth","newBarwidth","pLetter","getAxisLetter","poffsetIsArray","isArray","barwidthIsArray","calcBar","w","delta","allowMinDtick","vpad","minDtick","pts","l","r","calcBarOffset","calcBarWidth","_extremes","findExtremes","padded","sLetter","isScatter","isVertical","tozero","top","y","x","isFunnel","put","value","inTraceSieve","sTop","sTiny","sMin","l2c","c2l","sMax","needsPadding","v","scale","abs","extents","pMin","Infinity","pMax","max","roundFactor","round","String","di","p0","p1","pVal","s0","s1","ax","charAt","module","exports"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/traces/bar/cross_trace_calc.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nfunction crossTraceCalc(gd, plotinfo) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var fullLayout = gd._fullLayout;\n    var fullTraces = gd._fullData;\n    var calcTraces = gd.calcdata;\n    var calcTracesHorz = [];\n    var calcTracesVert = [];\n\n    for(var i = 0; i < fullTraces.length; i++) {\n        var fullTrace = fullTraces[i];\n        if(\n            fullTrace.visible === true &&\n            Registry.traceIs(fullTrace, 'bar') &&\n            fullTrace.xaxis === xa._id &&\n            fullTrace.yaxis === ya._id\n        ) {\n            if(fullTrace.orientation === 'h') {\n                calcTracesHorz.push(calcTraces[i]);\n            } else {\n                calcTracesVert.push(calcTraces[i]);\n            }\n\n            if(fullTrace._computePh) {\n                var cd = gd.calcdata[i];\n                for(var j = 0; j < cd.length; j++) {\n                    if(typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();\n                    if(typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();\n                }\n            }\n        }\n    }\n\n    var opts = {\n        xCat: xa.type === 'category' || xa.type === 'multicategory',\n        yCat: ya.type === 'category' || ya.type === 'multicategory',\n\n        mode: fullLayout.barmode,\n        norm: fullLayout.barnorm,\n        gap: fullLayout.bargap,\n        groupgap: fullLayout.bargroupgap\n    };\n\n    setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n    setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\n\nfunction setGroupPositions(gd, pa, sa, calcTraces, opts) {\n    if(!calcTraces.length) return;\n\n    var excluded;\n    var included;\n    var i, calcTrace, fullTrace;\n\n    initBase(sa, calcTraces);\n\n    switch(opts.mode) {\n        case 'overlay':\n            setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);\n            break;\n\n        case 'group':\n            // exclude from the group those traces for which the user set an offset\n            excluded = [];\n            included = [];\n            for(i = 0; i < calcTraces.length; i++) {\n                calcTrace = calcTraces[i];\n                fullTrace = calcTrace[0].trace;\n\n                if(fullTrace.offset === undefined) included.push(calcTrace);\n                else excluded.push(calcTrace);\n            }\n\n            if(included.length) {\n                setGroupPositionsInGroupMode(gd, pa, sa, included, opts);\n            }\n            if(excluded.length) {\n                setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n            }\n            break;\n\n        case 'stack':\n        case 'relative':\n            // exclude from the stack those traces for which the user set a base\n            excluded = [];\n            included = [];\n            for(i = 0; i < calcTraces.length; i++) {\n                calcTrace = calcTraces[i];\n                fullTrace = calcTrace[0].trace;\n\n                if(fullTrace.base === undefined) included.push(calcTrace);\n                else excluded.push(calcTrace);\n            }\n\n            if(included.length) {\n                setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);\n            }\n            if(excluded.length) {\n                setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n            }\n            break;\n    }\n\n    collectExtents(calcTraces, pa);\n}\n\nfunction initBase(sa, calcTraces) {\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var cd = calcTraces[i];\n        var trace = cd[0].trace;\n        var base = (trace.type === 'funnel') ? trace._base : trace.base;\n        var b;\n\n        // not sure if it really makes sense to have dates for bar size data...\n        // ideally if we want to make gantt charts or something we'd treat\n        // the actual size (trace.x or y) as time delta but base as absolute\n        // time. But included here for completeness.\n        var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar;\n\n        // 'base' on categorical axes makes no sense\n        var d2c = sa.type === 'category' || sa.type === 'multicategory' ?\n            function() { return null; } :\n            sa.d2c;\n\n        if(isArrayOrTypedArray(base)) {\n            for(j = 0; j < Math.min(base.length, cd.length); j++) {\n                b = d2c(base[j], 0, scalendar);\n                if(isNumeric(b)) {\n                    cd[j].b = +b;\n                    cd[j].hasB = 1;\n                } else cd[j].b = 0;\n            }\n            for(; j < cd.length; j++) {\n                cd[j].b = 0;\n            }\n        } else {\n            b = d2c(base, 0, scalendar);\n            var hasBase = isNumeric(b);\n            b = hasBase ? b : 0;\n            for(j = 0; j < cd.length; j++) {\n                cd[j].b = b;\n                if(hasBase) cd[j].hasB = 1;\n            }\n        }\n    }\n}\n\nfunction setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {\n    // update position axis and set bar offsets and widths\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        var sieve = new Sieve([calcTrace], {\n            posAxis: pa,\n            sepNegVal: false,\n            overlapNoMerge: !opts.norm\n        });\n\n        // set bar offsets and widths, and update position axis\n        setOffsetAndWidth(pa, sieve, opts);\n\n        // set bar bases and sizes, and update size axis\n        //\n        // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n        // is defined, because this function is also invoked for traces that\n        // can't be grouped or stacked)\n        if(opts.norm) {\n            sieveBars(sieve);\n            normalizeBars(sa, sieve, opts);\n        } else {\n            setBaseAndTop(sa, sieve);\n        }\n    }\n}\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {\n    var sieve = new Sieve(calcTraces, {\n        posAxis: pa,\n        sepNegVal: false,\n        overlapNoMerge: !opts.norm\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidthInGroupMode(gd, pa, sieve, opts);\n\n    // relative-stack bars within the same trace that would otherwise\n    // be hidden\n    unhideBarsWithinTrace(sieve, pa);\n\n    // set bar bases and sizes, and update size axis\n    if(opts.norm) {\n        sieveBars(sieve);\n        normalizeBars(sa, sieve, opts);\n    } else {\n        setBaseAndTop(sa, sieve);\n    }\n}\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {\n    var sieve = new Sieve(calcTraces, {\n        posAxis: pa,\n        sepNegVal: opts.mode === 'relative',\n        overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(pa, sieve, opts);\n\n    // set bar bases and sizes, and update size axis\n    stackBars(sa, sieve, opts);\n\n    // flag the outmost bar (for text display purposes)\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var isOutmostBar = ((bar.b + bar.s) === sieve.get(bar.p, bar.s));\n                if(isOutmostBar) bar._outmost = true;\n            }\n        }\n    }\n\n    // Note that marking the outmost bars has to be done\n    // before `normalizeBars` changes `bar.b` and `bar.s`.\n    if(opts.norm) normalizeBars(sa, sieve, opts);\n}\n\nfunction setOffsetAndWidth(pa, sieve, opts) {\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n\n    // set bar offsets and widths\n    var barGroupWidth = minDiff * (1 - opts.gap);\n    var barWidthPlusGap = barGroupWidth;\n    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n    // computer bar group center and bar offset\n    var offsetFromCenter = -barWidth / 2;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n\n        // store bar width and offset for this trace\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace offset and width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(pa, sieve);\n\n    // update position axes\n    updatePositionAxis(pa, sieve);\n}\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {\n    var fullLayout = gd._fullLayout;\n    var positions = sieve.positions;\n    var distinctPositions = sieve.distinctPositions;\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n    var nTraces = calcTraces.length;\n\n    // if there aren't any overlapping positions,\n    // let them have full width even if mode is group\n    var overlap = (positions.length !== distinctPositions.length);\n    var barGroupWidth = minDiff * (1 - opts.gap);\n\n    var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;\n    var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n\n    for(var i = 0; i < nTraces; i++) {\n        var calcTrace = calcTraces[i];\n        var trace = calcTrace[0].trace;\n\n        var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n        var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n\n        var barWidthPlusGap;\n        if(nOffsetGroups) {\n            barWidthPlusGap = barGroupWidth / nOffsetGroups;\n        } else {\n            barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n        }\n\n        var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n        var offsetFromCenter;\n        if(nOffsetGroups) {\n            offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;\n        } else {\n            offsetFromCenter = overlap ?\n                ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 :\n                -barWidth / 2;\n        }\n\n        var t = calcTrace[0].t;\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(pa, sieve);\n\n    // update position axes\n    updatePositionAxis(pa, sieve, overlap);\n}\n\nfunction applyAttributes(sieve) {\n    var calcTraces = sieve.traces;\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var t = calcTrace0.t;\n        var offset = fullTrace._offset || fullTrace.offset;\n        var initialPoffset = t.poffset;\n        var newPoffset;\n\n        if(isArrayOrTypedArray(offset)) {\n            // if offset is an array, then clone it into t.poffset.\n            newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newPoffset.length; j++) {\n                if(!isNumeric(newPoffset[j])) {\n                    newPoffset[j] = initialPoffset;\n                }\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.poffset\n            for(j = newPoffset.length; j < calcTrace.length; j++) {\n                newPoffset.push(initialPoffset);\n            }\n\n            t.poffset = newPoffset;\n        } else if(offset !== undefined) {\n            t.poffset = offset;\n        }\n\n        var width = fullTrace._width || fullTrace.width;\n        var initialBarwidth = t.barwidth;\n\n        if(isArrayOrTypedArray(width)) {\n            // if width is an array, then clone it into t.barwidth.\n            var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newBarwidth.length; j++) {\n                if(!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.barwidth\n            for(j = newBarwidth.length; j < calcTrace.length; j++) {\n                newBarwidth.push(initialBarwidth);\n            }\n\n            t.barwidth = newBarwidth;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                newPoffset = [];\n                for(j = 0; j < calcTrace.length; j++) {\n                    newPoffset.push(\n                        initialPoffset + (initialBarwidth - newBarwidth[j]) / 2\n                    );\n                }\n                t.poffset = newPoffset;\n            }\n        } else if(width !== undefined) {\n            t.barwidth = width;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n            }\n        }\n    }\n}\n\nfunction setBarCenterAndWidth(pa, sieve) {\n    var calcTraces = sieve.traces;\n    var pLetter = getAxisLetter(pa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n        var poffset = t.poffset;\n        var poffsetIsArray = Array.isArray(poffset);\n        var barwidth = t.barwidth;\n        var barwidthIsArray = Array.isArray(barwidth);\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var calcBar = calcTrace[j];\n\n            // store the actual bar width and position, for use by hover\n            var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n\n            if(calcBar.p === undefined) {\n                calcBar.p = calcBar[pLetter];\n                calcBar['orig_' + pLetter] = calcBar[pLetter];\n            }\n\n            var delta = (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n            calcBar[pLetter] = calcBar.p + delta;\n        }\n    }\n}\n\nfunction updatePositionAxis(pa, sieve, allowMinDtick) {\n    var calcTraces = sieve.traces;\n    var minDiff = sieve.minDiff;\n    var vpad = minDiff / 2;\n\n    Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var pts = [];\n        var bar, l, r, j;\n\n        for(j = 0; j < calcTrace.length; j++) {\n            bar = calcTrace[j];\n            l = bar.p - vpad;\n            r = bar.p + vpad;\n            pts.push(l, r);\n        }\n\n        if(fullTrace.width || fullTrace.offset) {\n            var t = calcTrace0.t;\n            var poffset = t.poffset;\n            var barwidth = t.barwidth;\n            var poffsetIsArray = Array.isArray(poffset);\n            var barwidthIsArray = Array.isArray(barwidth);\n\n            for(j = 0; j < calcTrace.length; j++) {\n                bar = calcTrace[j];\n                var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n                var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n                l = bar.p + calcBarOffset;\n                r = l + calcBarWidth;\n                pts.push(l, r);\n            }\n        }\n\n        fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {padded: false});\n    }\n}\n\n// store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\nfunction setBaseAndTop(sa, sieve) {\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var isScatter = fullTrace.type === 'scatter';\n        var isVertical = fullTrace.orientation === 'v';\n        var pts = [];\n        var tozero = false;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n            var base = isScatter ? 0 : bar.b;\n            var top = isScatter ? (\n                isVertical ? bar.y : bar.x\n            ) : base + bar.s;\n\n            bar[sLetter] = top;\n            pts.push(top);\n            if(bar.hasB) pts.push(base);\n\n            if(!bar.hasB || !bar.b) {\n                tozero = true;\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: tozero,\n            padded: true\n        });\n    }\n}\n\nfunction stackBars(sa, sieve, opts) {\n    var sLetter = getAxisLetter(sa);\n    var calcTraces = sieve.traces;\n    var calcTrace;\n    var fullTrace;\n    var isFunnel;\n    var i, j;\n    var bar;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n\n        if(fullTrace.type === 'funnel') {\n            for(j = 0; j < calcTrace.length; j++) {\n                bar = calcTrace[j];\n\n                if(bar.s !== BADNUM) {\n                    // create base of funnels\n                    sieve.put(bar.p, -0.5 * bar.s);\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n\n        isFunnel = (fullTrace.type === 'funnel');\n\n        var pts = [];\n\n        for(j = 0; j < calcTrace.length; j++) {\n            bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                // stack current bar and get previous sum\n                var value;\n                if(isFunnel) {\n                    value = bar.s;\n                } else {\n                    value = bar.s + bar.b;\n                }\n\n                var base = sieve.put(bar.p, value);\n\n                var top = base + value;\n\n                // store the bar base and top in each calcdata item\n                bar.b = base;\n                bar[sLetter] = top;\n\n                if(!opts.norm) {\n                    pts.push(top);\n                    if(bar.hasB) {\n                        pts.push(base);\n                    }\n                }\n            }\n        }\n\n        // if barnorm is set, let normalizeBars update the axis range\n        if(!opts.norm) {\n            fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n                // N.B. we don't stack base with 'base',\n                // so set tozero:true always!\n                tozero: true,\n                padded: true\n            });\n        }\n    }\n}\n\nfunction sieveBars(sieve) {\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                sieve.put(bar.p, bar.b + bar.s);\n            }\n        }\n    }\n}\n\nfunction unhideBarsWithinTrace(sieve, pa) {\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n\n        if(fullTrace.base === undefined) {\n            var inTraceSieve = new Sieve([calcTrace], {\n                posAxis: pa,\n                sepNegVal: true,\n                overlapNoMerge: true\n            });\n\n            for(var j = 0; j < calcTrace.length; j++) {\n                var bar = calcTrace[j];\n\n                if(bar.p !== BADNUM) {\n                    // stack current bar and get previous sum\n                    var base = inTraceSieve.put(bar.p, bar.b + bar.s);\n\n                    // if previous sum if non-zero, this means:\n                    // multiple bars have same starting point are potentially hidden,\n                    // shift them vertically so that all bars are visible by default\n                    if(base) bar.b = base;\n                }\n            }\n        }\n    }\n}\n\n// Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\nfunction normalizeBars(sa, sieve, opts) {\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n    var sTop = opts.norm === 'fraction' ? 1 : 100;\n    var sTiny = sTop / 1e9; // in case of rounding error in sum\n    var sMin = sa.l2c(sa.c2l(0));\n    var sMax = opts.mode === 'stack' ? sTop : sMin;\n\n    function needsPadding(v) {\n        return (\n            isNumeric(sa.c2l(v)) &&\n            ((v < sMin - sTiny) || (v > sMax + sTiny) || !isNumeric(sMin))\n        );\n    }\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var pts = [];\n        var tozero = false;\n        var padded = false;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n                bar.b *= scale;\n                bar.s *= scale;\n\n                var base = bar.b;\n                var top = base + bar.s;\n\n                bar[sLetter] = top;\n                pts.push(top);\n                padded = padded || needsPadding(top);\n\n                if(bar.hasB) {\n                    pts.push(base);\n                    padded = padded || needsPadding(base);\n                }\n\n                if(!bar.hasB || !bar.b) {\n                    tozero = true;\n                }\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: tozero,\n            padded: padded\n        });\n    }\n}\n\n// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces, pa) {\n    var pLetter = getAxisLetter(pa);\n    var extents = {};\n    var i, j, cd;\n\n    var pMin = Infinity;\n    var pMax = -Infinity;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        for(j = 0; j < cd.length; j++) {\n            var p = cd[j].p;\n            if(isNumeric(p)) {\n                pMin = Math.min(pMin, p);\n                pMax = Math.max(pMax, p);\n            }\n        }\n    }\n\n    // this is just for positioning of hover labels, and nobody will care if\n    // the label is 1px too far out; so round positions to 1/10K in case\n    // position values don't exactly match from trace to trace\n    var roundFactor = 10000 / (pMax - pMin);\n    var round = extents.round = function(p) {\n        return String(Math.round(roundFactor * (p - pMin)));\n    };\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        cd[0].t.extents = extents;\n\n        var poffset = cd[0].t.poffset;\n        var poffsetIsArray = Array.isArray(poffset);\n\n        for(j = 0; j < cd.length; j++) {\n            var di = cd[j];\n            var p0 = di[pLetter] - di.w / 2;\n\n            if(isNumeric(p0)) {\n                var p1 = di[pLetter] + di.w / 2;\n                var pVal = round(di.p);\n                if(extents[pVal]) {\n                    extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n                } else {\n                    extents[pVal] = [p0, p1];\n                }\n            }\n\n            di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n            di.p1 = di.p0 + di.w;\n            di.s0 = di.b;\n            di.s1 = di.s0 + di.s;\n        }\n    }\n}\n\nfunction getAxisLetter(ax) {\n    return ax._id.charAt(0);\n}\n\nmodule.exports = {\n    crossTraceCalc: crossTraceCalc,\n    setGroupPositions: setGroupPositions\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}