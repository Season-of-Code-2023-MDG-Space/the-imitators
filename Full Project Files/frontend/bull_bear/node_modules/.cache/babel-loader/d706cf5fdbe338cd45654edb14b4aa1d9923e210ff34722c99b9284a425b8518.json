{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\nvar SHOWISOLATETIP = true;\nmodule.exports = function handleClick(g, gd, numClicks) {\n  var fullLayout = gd._fullLayout;\n  if (gd._dragged || gd._editing) return;\n  var itemClick = fullLayout.legend.itemclick;\n  var itemDoubleClick = fullLayout.legend.itemdoubleclick;\n  var groupClick = fullLayout.legend.groupclick;\n  if (numClicks === 1 && itemClick === 'toggle' && itemDoubleClick === 'toggleothers' && SHOWISOLATETIP && gd.data && gd._context.showTips) {\n    Lib.notifier(Lib._(gd, 'Double-click on legend to isolate one trace'), 'long');\n    SHOWISOLATETIP = false;\n  } else {\n    SHOWISOLATETIP = false;\n  }\n  var mode;\n  if (numClicks === 1) mode = itemClick;else if (numClicks === 2) mode = itemDoubleClick;\n  if (!mode) return;\n  var toggleGroup = groupClick === 'togglegroup';\n  var hiddenSlices = fullLayout.hiddenlabels ? fullLayout.hiddenlabels.slice() : [];\n  var legendItem = g.data()[0][0];\n  if (legendItem.groupTitle && legendItem.noClick) return;\n  var fullData = gd._fullData;\n  var fullTrace = legendItem.trace;\n  var legendgroup = fullTrace.legendgroup;\n  var i, j, kcont, key, keys, val;\n  var attrUpdate = {};\n  var attrIndices = [];\n  var carrs = [];\n  var carrIdx = [];\n  function insertUpdate(traceIndex, key, value) {\n    var attrIndex = attrIndices.indexOf(traceIndex);\n    var valueArray = attrUpdate[key];\n    if (!valueArray) {\n      valueArray = attrUpdate[key] = [];\n    }\n    if (attrIndices.indexOf(traceIndex) === -1) {\n      attrIndices.push(traceIndex);\n      attrIndex = attrIndices.length - 1;\n    }\n    valueArray[attrIndex] = value;\n    return attrIndex;\n  }\n  function setVisibility(fullTrace, visibility) {\n    if (legendItem.groupTitle && !toggleGroup) return;\n    var fullInput = fullTrace._fullInput;\n    if (Registry.hasTransform(fullInput, 'groupby')) {\n      var kcont = carrs[fullInput.index];\n      if (!kcont) {\n        var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');\n        var lastGroupbyIndex = groupbyIndices[groupbyIndices.length - 1];\n        kcont = Lib.keyedContainer(fullInput, 'transforms[' + lastGroupbyIndex + '].styles', 'target', 'value.visible');\n        carrs[fullInput.index] = kcont;\n      }\n      var curState = kcont.get(fullTrace._group);\n\n      // If not specified, assume visible. This happens if there are other style\n      // properties set for a group but not the visibility. There are many similar\n      // ways to do this (e.g. why not just `curState = fullTrace.visible`??? The\n      // answer is: because it breaks other things like groupby trace names in\n      // subtle ways.)\n      if (curState === undefined) {\n        curState = true;\n      }\n      if (curState !== false) {\n        // true -> legendonly. All others toggle to true:\n        kcont.set(fullTrace._group, visibility);\n      }\n      carrIdx[fullInput.index] = insertUpdate(fullInput.index, 'visible', fullInput.visible === false ? false : true);\n    } else {\n      // false -> false (not possible since will not be visible in legend)\n      // true -> legendonly\n      // legendonly -> true\n      var nextVisibility = fullInput.visible === false ? false : visibility;\n      insertUpdate(fullInput.index, 'visible', nextVisibility);\n    }\n  }\n  if (Registry.traceIs(fullTrace, 'pie-like')) {\n    var thisLabel = legendItem.label;\n    var thisLabelIndex = hiddenSlices.indexOf(thisLabel);\n    if (mode === 'toggle') {\n      if (thisLabelIndex === -1) hiddenSlices.push(thisLabel);else hiddenSlices.splice(thisLabelIndex, 1);\n    } else if (mode === 'toggleothers') {\n      hiddenSlices = [];\n      gd.calcdata[0].forEach(function (d) {\n        if (thisLabel !== d.label) {\n          hiddenSlices.push(d.label);\n        }\n      });\n      if (gd._fullLayout.hiddenlabels && gd._fullLayout.hiddenlabels.length === hiddenSlices.length && thisLabelIndex === -1) {\n        hiddenSlices = [];\n      }\n    }\n    Registry.call('_guiRelayout', gd, 'hiddenlabels', hiddenSlices);\n  } else {\n    var hasLegendgroup = legendgroup && legendgroup.length;\n    var traceIndicesInGroup = [];\n    var tracei;\n    if (hasLegendgroup) {\n      for (i = 0; i < fullData.length; i++) {\n        tracei = fullData[i];\n        if (!tracei.visible) continue;\n        if (tracei.legendgroup === legendgroup) {\n          traceIndicesInGroup.push(i);\n        }\n      }\n    }\n    if (mode === 'toggle') {\n      var nextVisibility;\n      switch (fullTrace.visible) {\n        case true:\n          nextVisibility = 'legendonly';\n          break;\n        case false:\n          nextVisibility = false;\n          break;\n        case 'legendonly':\n          nextVisibility = true;\n          break;\n      }\n      if (hasLegendgroup) {\n        if (toggleGroup) {\n          for (i = 0; i < fullData.length; i++) {\n            if (fullData[i].visible !== false && fullData[i].legendgroup === legendgroup) {\n              setVisibility(fullData[i], nextVisibility);\n            }\n          }\n        } else {\n          setVisibility(fullTrace, nextVisibility);\n        }\n      } else {\n        setVisibility(fullTrace, nextVisibility);\n      }\n    } else if (mode === 'toggleothers') {\n      // Compute the clicked index. expandedIndex does what we want for expanded traces\n      // but also culls hidden traces. That means we have some work to do.\n      var isClicked, isInGroup, notInLegend, otherState;\n      var isIsolated = true;\n      for (i = 0; i < fullData.length; i++) {\n        isClicked = fullData[i] === fullTrace;\n        notInLegend = fullData[i].showlegend !== true;\n        if (isClicked || notInLegend) continue;\n        isInGroup = hasLegendgroup && fullData[i].legendgroup === legendgroup;\n        if (!isInGroup && fullData[i].visible === true && !Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n          isIsolated = false;\n          break;\n        }\n      }\n      for (i = 0; i < fullData.length; i++) {\n        // False is sticky; we don't change it.\n        if (fullData[i].visible === false) continue;\n        if (Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n          continue;\n        }\n        switch (fullTrace.visible) {\n          case 'legendonly':\n            setVisibility(fullData[i], true);\n            break;\n          case true:\n            otherState = isIsolated ? true : 'legendonly';\n            isClicked = fullData[i] === fullTrace;\n            // N.B. consider traces that have a set legendgroup as toggleable\n            notInLegend = fullData[i].showlegend !== true && !fullData[i].legendgroup;\n            isInGroup = isClicked || hasLegendgroup && fullData[i].legendgroup === legendgroup;\n            setVisibility(fullData[i], isInGroup || notInLegend ? true : otherState);\n            break;\n        }\n      }\n    }\n    for (i = 0; i < carrs.length; i++) {\n      kcont = carrs[i];\n      if (!kcont) continue;\n      var update = kcont.constructUpdate();\n      var updateKeys = Object.keys(update);\n      for (j = 0; j < updateKeys.length; j++) {\n        key = updateKeys[j];\n        val = attrUpdate[key] = attrUpdate[key] || [];\n        val[carrIdx[i]] = update[key];\n      }\n    }\n\n    // The length of the value arrays should be equal and any unspecified\n    // values should be explicitly undefined for them to get properly culled\n    // as updates and not accidentally reset to the default value. This fills\n    // out sparse arrays with the required number of undefined values:\n    keys = Object.keys(attrUpdate);\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n      for (j = 0; j < attrIndices.length; j++) {\n        // Use hasOwnProperty to protect against falsy values:\n        if (!attrUpdate[key].hasOwnProperty(j)) {\n          attrUpdate[key][j] = undefined;\n        }\n      }\n    }\n    Registry.call('_guiRestyle', gd, attrUpdate, attrIndices);\n  }\n};","map":{"version":3,"names":["Lib","require","Registry","SHOWISOLATETIP","module","exports","handleClick","g","gd","numClicks","fullLayout","_fullLayout","_dragged","_editing","itemClick","legend","itemclick","itemDoubleClick","itemdoubleclick","groupClick","groupclick","data","_context","showTips","notifier","_","mode","toggleGroup","hiddenSlices","hiddenlabels","slice","legendItem","groupTitle","noClick","fullData","_fullData","fullTrace","trace","legendgroup","i","j","kcont","key","keys","val","attrUpdate","attrIndices","carrs","carrIdx","insertUpdate","traceIndex","value","attrIndex","indexOf","valueArray","push","length","setVisibility","visibility","fullInput","_fullInput","hasTransform","index","groupbyIndices","getTransformIndices","lastGroupbyIndex","keyedContainer","curState","get","_group","undefined","set","visible","nextVisibility","traceIs","thisLabel","label","thisLabelIndex","splice","calcdata","forEach","d","call","hasLegendgroup","traceIndicesInGroup","tracei","isClicked","isInGroup","notInLegend","otherState","isIsolated","showlegend","update","constructUpdate","updateKeys","Object","hasOwnProperty"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/components/legend/handle_click.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\n\nvar SHOWISOLATETIP = true;\n\nmodule.exports = function handleClick(g, gd, numClicks) {\n    var fullLayout = gd._fullLayout;\n\n    if(gd._dragged || gd._editing) return;\n\n    var itemClick = fullLayout.legend.itemclick;\n    var itemDoubleClick = fullLayout.legend.itemdoubleclick;\n    var groupClick = fullLayout.legend.groupclick;\n\n    if(numClicks === 1 && itemClick === 'toggle' && itemDoubleClick === 'toggleothers' &&\n        SHOWISOLATETIP && gd.data && gd._context.showTips\n    ) {\n        Lib.notifier(Lib._(gd, 'Double-click on legend to isolate one trace'), 'long');\n        SHOWISOLATETIP = false;\n    } else {\n        SHOWISOLATETIP = false;\n    }\n\n    var mode;\n    if(numClicks === 1) mode = itemClick;\n    else if(numClicks === 2) mode = itemDoubleClick;\n    if(!mode) return;\n\n    var toggleGroup = groupClick === 'togglegroup';\n\n    var hiddenSlices = fullLayout.hiddenlabels ?\n        fullLayout.hiddenlabels.slice() :\n        [];\n\n    var legendItem = g.data()[0][0];\n    if(legendItem.groupTitle && legendItem.noClick) return;\n\n    var fullData = gd._fullData;\n    var fullTrace = legendItem.trace;\n    var legendgroup = fullTrace.legendgroup;\n\n    var i, j, kcont, key, keys, val;\n    var attrUpdate = {};\n    var attrIndices = [];\n    var carrs = [];\n    var carrIdx = [];\n\n    function insertUpdate(traceIndex, key, value) {\n        var attrIndex = attrIndices.indexOf(traceIndex);\n        var valueArray = attrUpdate[key];\n        if(!valueArray) {\n            valueArray = attrUpdate[key] = [];\n        }\n\n        if(attrIndices.indexOf(traceIndex) === -1) {\n            attrIndices.push(traceIndex);\n            attrIndex = attrIndices.length - 1;\n        }\n\n        valueArray[attrIndex] = value;\n\n        return attrIndex;\n    }\n\n    function setVisibility(fullTrace, visibility) {\n        if(legendItem.groupTitle && !toggleGroup) return;\n\n        var fullInput = fullTrace._fullInput;\n        if(Registry.hasTransform(fullInput, 'groupby')) {\n            var kcont = carrs[fullInput.index];\n            if(!kcont) {\n                var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');\n                var lastGroupbyIndex = groupbyIndices[groupbyIndices.length - 1];\n                kcont = Lib.keyedContainer(fullInput, 'transforms[' + lastGroupbyIndex + '].styles', 'target', 'value.visible');\n                carrs[fullInput.index] = kcont;\n            }\n\n            var curState = kcont.get(fullTrace._group);\n\n            // If not specified, assume visible. This happens if there are other style\n            // properties set for a group but not the visibility. There are many similar\n            // ways to do this (e.g. why not just `curState = fullTrace.visible`??? The\n            // answer is: because it breaks other things like groupby trace names in\n            // subtle ways.)\n            if(curState === undefined) {\n                curState = true;\n            }\n\n            if(curState !== false) {\n                // true -> legendonly. All others toggle to true:\n                kcont.set(fullTrace._group, visibility);\n            }\n            carrIdx[fullInput.index] = insertUpdate(fullInput.index, 'visible', fullInput.visible === false ? false : true);\n        } else {\n            // false -> false (not possible since will not be visible in legend)\n            // true -> legendonly\n            // legendonly -> true\n            var nextVisibility = fullInput.visible === false ? false : visibility;\n\n            insertUpdate(fullInput.index, 'visible', nextVisibility);\n        }\n    }\n\n    if(Registry.traceIs(fullTrace, 'pie-like')) {\n        var thisLabel = legendItem.label;\n        var thisLabelIndex = hiddenSlices.indexOf(thisLabel);\n\n        if(mode === 'toggle') {\n            if(thisLabelIndex === -1) hiddenSlices.push(thisLabel);\n            else hiddenSlices.splice(thisLabelIndex, 1);\n        } else if(mode === 'toggleothers') {\n            hiddenSlices = [];\n            gd.calcdata[0].forEach(function(d) {\n                if(thisLabel !== d.label) {\n                    hiddenSlices.push(d.label);\n                }\n            });\n            if(gd._fullLayout.hiddenlabels && gd._fullLayout.hiddenlabels.length === hiddenSlices.length && thisLabelIndex === -1) {\n                hiddenSlices = [];\n            }\n        }\n\n        Registry.call('_guiRelayout', gd, 'hiddenlabels', hiddenSlices);\n    } else {\n        var hasLegendgroup = legendgroup && legendgroup.length;\n        var traceIndicesInGroup = [];\n        var tracei;\n        if(hasLegendgroup) {\n            for(i = 0; i < fullData.length; i++) {\n                tracei = fullData[i];\n                if(!tracei.visible) continue;\n                if(tracei.legendgroup === legendgroup) {\n                    traceIndicesInGroup.push(i);\n                }\n            }\n        }\n\n        if(mode === 'toggle') {\n            var nextVisibility;\n\n            switch(fullTrace.visible) {\n                case true:\n                    nextVisibility = 'legendonly';\n                    break;\n                case false:\n                    nextVisibility = false;\n                    break;\n                case 'legendonly':\n                    nextVisibility = true;\n                    break;\n            }\n\n            if(hasLegendgroup) {\n                if(toggleGroup) {\n                    for(i = 0; i < fullData.length; i++) {\n                        if(fullData[i].visible !== false && fullData[i].legendgroup === legendgroup) {\n                            setVisibility(fullData[i], nextVisibility);\n                        }\n                    }\n                } else {\n                    setVisibility(fullTrace, nextVisibility);\n                }\n            } else {\n                setVisibility(fullTrace, nextVisibility);\n            }\n        } else if(mode === 'toggleothers') {\n            // Compute the clicked index. expandedIndex does what we want for expanded traces\n            // but also culls hidden traces. That means we have some work to do.\n            var isClicked, isInGroup, notInLegend, otherState;\n            var isIsolated = true;\n            for(i = 0; i < fullData.length; i++) {\n                isClicked = fullData[i] === fullTrace;\n                notInLegend = fullData[i].showlegend !== true;\n                if(isClicked || notInLegend) continue;\n\n                isInGroup = (hasLegendgroup && fullData[i].legendgroup === legendgroup);\n\n                if(!isInGroup && fullData[i].visible === true && !Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n                    isIsolated = false;\n                    break;\n                }\n            }\n\n            for(i = 0; i < fullData.length; i++) {\n                // False is sticky; we don't change it.\n                if(fullData[i].visible === false) continue;\n\n                if(Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n                    continue;\n                }\n\n                switch(fullTrace.visible) {\n                    case 'legendonly':\n                        setVisibility(fullData[i], true);\n                        break;\n                    case true:\n                        otherState = isIsolated ? true : 'legendonly';\n                        isClicked = fullData[i] === fullTrace;\n                        // N.B. consider traces that have a set legendgroup as toggleable\n                        notInLegend = (fullData[i].showlegend !== true && !fullData[i].legendgroup);\n                        isInGroup = isClicked || (hasLegendgroup && fullData[i].legendgroup === legendgroup);\n                        setVisibility(fullData[i], (isInGroup || notInLegend) ? true : otherState);\n                        break;\n                }\n            }\n        }\n\n        for(i = 0; i < carrs.length; i++) {\n            kcont = carrs[i];\n            if(!kcont) continue;\n            var update = kcont.constructUpdate();\n\n            var updateKeys = Object.keys(update);\n            for(j = 0; j < updateKeys.length; j++) {\n                key = updateKeys[j];\n                val = attrUpdate[key] = attrUpdate[key] || [];\n                val[carrIdx[i]] = update[key];\n            }\n        }\n\n        // The length of the value arrays should be equal and any unspecified\n        // values should be explicitly undefined for them to get properly culled\n        // as updates and not accidentally reset to the default value. This fills\n        // out sparse arrays with the required number of undefined values:\n        keys = Object.keys(attrUpdate);\n        for(i = 0; i < keys.length; i++) {\n            key = keys[i];\n            for(j = 0; j < attrIndices.length; j++) {\n                // Use hasOwnProperty to protect against falsy values:\n                if(!attrUpdate[key].hasOwnProperty(j)) {\n                    attrUpdate[key][j] = undefined;\n                }\n            }\n        }\n\n        Registry.call('_guiRestyle', gd, attrUpdate, attrIndices);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}