{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\nvar Registry = require('../../registry');\nvar Color = require('../color');\nvar Colorscale = require('../colorscale');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignment = require('../../constants/alignment');\nvar LINE_SPACING = alignment.LINE_SPACING;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\nvar subTypes = require('../../traces/scatter/subtypes');\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\nvar drawing = module.exports = {};\n\n// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\ndrawing.font = function (s, family, size, color) {\n  // also allow the form font(s, {family, size, color})\n  if (Lib.isPlainObject(family)) {\n    color = family.color;\n    size = family.size;\n    family = family.family;\n  }\n  if (family) s.style('font-family', family);\n  if (size + 1) s.style('font-size', size + 'px');\n  if (color) s.call(Color.fill, color);\n};\n\n/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */\ndrawing.setPosition = function (s, x, y) {\n  s.attr('x', x).attr('y', y);\n};\ndrawing.setSize = function (s, w, h) {\n  s.attr('width', w).attr('height', h);\n};\ndrawing.setRect = function (s, x, y, w, h) {\n  s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n\n/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */\ndrawing.translatePoint = function (d, sel, xa, ya) {\n  var x = xa.c2p(d.x);\n  var y = ya.c2p(d.y);\n  if (isNumeric(x) && isNumeric(y) && sel.node()) {\n    // for multiline text this works better\n    if (sel.node().nodeName === 'text') {\n      sel.attr('x', x).attr('y', y);\n    } else {\n      sel.attr('transform', strTranslate(x, y));\n    }\n  } else {\n    return false;\n  }\n  return true;\n};\ndrawing.translatePoints = function (s, xa, ya) {\n  s.each(function (d) {\n    var sel = d3.select(this);\n    drawing.translatePoint(d, sel, xa, ya);\n  });\n};\ndrawing.hideOutsideRangePoint = function (d, sel, xa, ya, xcalendar, ycalendar) {\n  sel.attr('display', xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar) ? null : 'none');\n};\ndrawing.hideOutsideRangePoints = function (traceGroups, subplot) {\n  if (!subplot._hasClipOnAxisFalse) return;\n  var xa = subplot.xaxis;\n  var ya = subplot.yaxis;\n  traceGroups.each(function (d) {\n    var trace = d[0].trace;\n    var xcalendar = trace.xcalendar;\n    var ycalendar = trace.ycalendar;\n    var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';\n    traceGroups.selectAll(selector).each(function (d) {\n      drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);\n    });\n  });\n};\ndrawing.crispRound = function (gd, lineWidth, dflt) {\n  // for lines that disable antialiasing we want to\n  // make sure the width is an integer, and at least 1 if it's nonzero\n\n  if (!lineWidth || !isNumeric(lineWidth)) return dflt || 0;\n\n  // but not for static plots - these don't get antialiased anyway.\n  if (gd._context.staticPlot) return lineWidth;\n  if (lineWidth < 1) return 1;\n  return Math.round(lineWidth);\n};\ndrawing.singleLineStyle = function (d, s, lw, lc, ld) {\n  s.style('fill', 'none');\n  var line = (((d || [])[0] || {}).trace || {}).line || {};\n  var lw1 = lw || line.width || 0;\n  var dash = ld || line.dash || '';\n  Color.stroke(s, lc || line.color);\n  drawing.dashLine(s, dash, lw1);\n};\ndrawing.lineGroupStyle = function (s, lw, lc, ld) {\n  s.style('fill', 'none').each(function (d) {\n    var line = (((d || [])[0] || {}).trace || {}).line || {};\n    var lw1 = lw || line.width || 0;\n    var dash = ld || line.dash || '';\n    d3.select(this).call(Color.stroke, lc || line.color).call(drawing.dashLine, dash, lw1);\n  });\n};\ndrawing.dashLine = function (s, dash, lineWidth) {\n  lineWidth = +lineWidth || 0;\n  dash = drawing.dashStyle(dash, lineWidth);\n  s.style({\n    'stroke-dasharray': dash,\n    'stroke-width': lineWidth + 'px'\n  });\n};\ndrawing.dashStyle = function (dash, lineWidth) {\n  lineWidth = +lineWidth || 1;\n  var dlw = Math.max(lineWidth, 3);\n  if (dash === 'solid') dash = '';else if (dash === 'dot') dash = dlw + 'px,' + dlw + 'px';else if (dash === 'dash') dash = 3 * dlw + 'px,' + 3 * dlw + 'px';else if (dash === 'longdash') dash = 5 * dlw + 'px,' + 5 * dlw + 'px';else if (dash === 'dashdot') {\n    dash = 3 * dlw + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n  } else if (dash === 'longdashdot') {\n    dash = 5 * dlw + 'px,' + 2 * dlw + 'px,' + dlw + 'px,' + 2 * dlw + 'px';\n  }\n  // otherwise user wrote the dasharray themselves - leave it be\n\n  return dash;\n};\nfunction setFillStyle(sel, trace, gd) {\n  var markerPattern = trace.fillpattern;\n  var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, '');\n  if (patternShape) {\n    var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);\n    var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);\n    var patternFGOpacity = markerPattern.fgopacity;\n    var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);\n    var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);\n    var patternID = trace.uid;\n    drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, undefined, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);\n  } else if (trace.fillcolor) {\n    sel.call(Color.fill, trace.fillcolor);\n  }\n}\n\n// Same as fillGroupStyle, except in this case the selection may be a transition\ndrawing.singleFillStyle = function (sel, gd) {\n  var node = d3.select(sel.node());\n  var data = node.data();\n  var trace = ((data[0] || [])[0] || {}).trace || {};\n  setFillStyle(sel, trace, gd);\n};\ndrawing.fillGroupStyle = function (s, gd) {\n  s.style('stroke-width', 0).each(function (d) {\n    var shape = d3.select(this);\n    // N.B. 'd' won't be a calcdata item when\n    // fill !== 'none' on a segment-less and marker-less trace\n    if (d[0].trace) {\n      setFillStyle(shape, d[0].trace, gd);\n    }\n  });\n};\nvar SYMBOLDEFS = require('./symbol_defs');\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolBackOffs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolNoFill = {};\ndrawing.symbolList = [];\nObject.keys(SYMBOLDEFS).forEach(function (k) {\n  var symDef = SYMBOLDEFS[k];\n  var n = symDef.n;\n  drawing.symbolList.push(n, String(n), k, n + 100, String(n + 100), k + '-open');\n  drawing.symbolNames[n] = k;\n  drawing.symbolFuncs[n] = symDef.f;\n  drawing.symbolBackOffs[n] = symDef.backoff || 0;\n  if (symDef.needLine) {\n    drawing.symbolNeedLines[n] = true;\n  }\n  if (symDef.noDot) {\n    drawing.symbolNoDot[n] = true;\n  } else {\n    drawing.symbolList.push(n + 200, String(n + 200), k + '-dot', n + 300, String(n + 300), k + '-open-dot');\n  }\n  if (symDef.noFill) {\n    drawing.symbolNoFill[n] = true;\n  }\n});\nvar MAXSYMBOL = drawing.symbolNames.length;\n// add a dot in the middle of the symbol\nvar DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\ndrawing.symbolNumber = function (v) {\n  if (isNumeric(v)) {\n    v = +v;\n  } else if (typeof v === 'string') {\n    var vbase = 0;\n    if (v.indexOf('-open') > 0) {\n      vbase = 100;\n      v = v.replace('-open', '');\n    }\n    if (v.indexOf('-dot') > 0) {\n      vbase += 200;\n      v = v.replace('-dot', '');\n    }\n    v = drawing.symbolNames.indexOf(v);\n    if (v >= 0) {\n      v += vbase;\n    }\n  }\n  return v % 100 >= MAXSYMBOL || v >= 400 ? 0 : Math.floor(Math.max(v, 0));\n};\nfunction makePointPath(symbolNumber, r, t, s) {\n  var base = symbolNumber % 100;\n  return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : '');\n}\nvar HORZGRADIENT = {\n  x1: 1,\n  x2: 0,\n  y1: 0,\n  y2: 0\n};\nvar VERTGRADIENT = {\n  x1: 0,\n  x2: 0,\n  y1: 1,\n  y2: 0\n};\nvar stopFormatter = numberFormat('~f');\nvar gradientInfo = {\n  radial: {\n    node: 'radialGradient'\n  },\n  radialreversed: {\n    node: 'radialGradient',\n    reversed: true\n  },\n  horizontal: {\n    node: 'linearGradient',\n    attrs: HORZGRADIENT\n  },\n  horizontalreversed: {\n    node: 'linearGradient',\n    attrs: HORZGRADIENT,\n    reversed: true\n  },\n  vertical: {\n    node: 'linearGradient',\n    attrs: VERTGRADIENT\n  },\n  verticalreversed: {\n    node: 'linearGradient',\n    attrs: VERTGRADIENT,\n    reversed: true\n  }\n};\n\n/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */\ndrawing.gradient = function (sel, gd, gradientID, type, colorscale, prop) {\n  var len = colorscale.length;\n  var info = gradientInfo[type];\n  var colorStops = new Array(len);\n  for (var i = 0; i < len; i++) {\n    if (info.reversed) {\n      colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];\n    } else {\n      colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];\n    }\n  }\n  var fullLayout = gd._fullLayout;\n  var fullID = 'g' + fullLayout._uid + '-' + gradientID;\n  var gradient = fullLayout._defs.select('.gradients').selectAll('#' + fullID).data([type + colorStops.join(';')], Lib.identity);\n  gradient.exit().remove();\n  gradient.enter().append(info.node).each(function () {\n    var el = d3.select(this);\n    if (info.attrs) el.attr(info.attrs);\n    el.attr('id', fullID);\n    var stops = el.selectAll('stop').data(colorStops);\n    stops.exit().remove();\n    stops.enter().append('stop');\n    stops.each(function (d) {\n      var tc = tinycolor(d[1]);\n      d3.select(this).attr({\n        offset: d[0] + '%',\n        'stop-color': Color.tinyRGB(tc),\n        'stop-opacity': tc.getAlpha()\n      });\n    });\n  });\n  sel.style(prop, getFullUrl(fullID, gd)).style(prop + '-opacity', null);\n  sel.classed('gradient_filled', true);\n};\n\n/**\n * pattern: create and apply a pattern fill\n *\n * @param {object} sel: d3 selection to apply this pattern to\n *     You can use `selection.call(Drawing.pattern, ...)`\n * @param {string} calledBy: option to know the caller component\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} patternID: a unique (within this plot) identifier\n *     for this pattern, so that we don't create unnecessary definitions\n * @param {number} size: size of unit squares for repetition of this pattern\n * @param {number} solidity: how solid lines of this pattern are\n * @param {string} mcc: color when painted with colorscale\n * @param {string} fillmode: fillmode for this pattern\n * @param {string} bgcolor: background color for this pattern\n * @param {string} fgcolor: foreground color for this pattern\n * @param {number} fgopacity: foreground opacity for this pattern\n */\ndrawing.pattern = function (sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {\n  var isLegend = calledBy === 'legend';\n  if (mcc) {\n    if (fillmode === 'overlay') {\n      bgcolor = mcc;\n      fgcolor = Color.contrast(bgcolor);\n    } else {\n      bgcolor = undefined;\n      fgcolor = mcc;\n    }\n  }\n  var fullLayout = gd._fullLayout;\n  var fullID = 'p' + fullLayout._uid + '-' + patternID;\n  var width, height;\n\n  // linear interpolation\n  var linearFn = function (x, x0, x1, y0, y1) {\n    return y0 + (y1 - y0) * (x - x0) / (x1 - x0);\n  };\n  var path, linewidth, radius;\n  var patternTag;\n  var patternAttrs = {};\n  var fgC = tinycolor(fgcolor);\n  var fgRGB = Color.tinyRGB(fgC);\n  var fgAlpha = fgC.getAlpha();\n  var opacity = fgopacity * fgAlpha;\n  switch (shape) {\n    case '/':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '\\\\':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case 'x':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2 + 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;\n      linewidth = size - size * Math.sqrt(1.0 - solidity);\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '|':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '-':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M0,' + height / 2 + 'L' + width + ',' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '+':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height + 'M0,' + height / 2 + 'L' + width + ',' + height / 2;\n      linewidth = size - size * Math.sqrt(1.0 - solidity);\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '.':\n      width = size;\n      height = size;\n      if (solidity < Math.PI / 4) {\n        radius = Math.sqrt(solidity * size * size / Math.PI);\n      } else {\n        radius = linearFn(solidity, Math.PI / 4, 1.0, size / 2, size / Math.sqrt(2));\n      }\n      patternTag = 'circle';\n      patternAttrs = {\n        cx: width / 2,\n        cy: height / 2,\n        r: radius,\n        opacity: opacity,\n        fill: fgRGB\n      };\n      break;\n  }\n  var str = [shape || 'noSh', bgcolor || 'noBg', fgcolor || 'noFg', size, solidity].join(';');\n  var pattern = fullLayout._defs.select('.patterns').selectAll('#' + fullID).data([str], Lib.identity);\n  pattern.exit().remove();\n  pattern.enter().append('pattern').each(function () {\n    var el = d3.select(this);\n    el.attr({\n      id: fullID,\n      width: width + 'px',\n      height: height + 'px',\n      patternUnits: 'userSpaceOnUse',\n      // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons\n      patternTransform: isLegend ? 'scale(0.8)' : ''\n    });\n    if (bgcolor) {\n      var bgC = tinycolor(bgcolor);\n      var bgRGB = Color.tinyRGB(bgC);\n      var bgAlpha = bgC.getAlpha();\n      var rects = el.selectAll('rect').data([0]);\n      rects.exit().remove();\n      rects.enter().append('rect').attr({\n        width: width + 'px',\n        height: height + 'px',\n        fill: bgRGB,\n        'fill-opacity': bgAlpha\n      });\n    }\n    var patterns = el.selectAll(patternTag).data([0]);\n    patterns.exit().remove();\n    patterns.enter().append(patternTag).attr(patternAttrs);\n  });\n  sel.style('fill', getFullUrl(fullID, gd)).style('fill-opacity', null);\n  sel.classed('pattern_filled', true);\n};\n\n/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */\ndrawing.initGradients = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var gradientsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'gradients');\n  gradientsGroup.selectAll('linearGradient,radialGradient').remove();\n  d3.select(gd).selectAll('.gradient_filled').classed('gradient_filled', false);\n};\ndrawing.initPatterns = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var patternsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'patterns');\n  patternsGroup.selectAll('pattern').remove();\n  d3.select(gd).selectAll('.pattern_filled').classed('pattern_filled', false);\n};\ndrawing.getPatternAttr = function (mp, i, dflt) {\n  if (mp && Lib.isArrayOrTypedArray(mp)) {\n    return i < mp.length ? mp[i] : dflt;\n  }\n  return mp;\n};\ndrawing.pointStyle = function (s, trace, gd) {\n  if (!s.size()) return;\n  var fns = drawing.makePointStyleFns(trace);\n  s.each(function (d) {\n    drawing.singlePointStyle(d, d3.select(this), trace, fns, gd);\n  });\n};\ndrawing.singlePointStyle = function (d, sel, trace, fns, gd) {\n  var marker = trace.marker;\n  var markerLine = marker.line;\n  sel.style('opacity', fns.selectedOpacityFn ? fns.selectedOpacityFn(d) : d.mo === undefined ? marker.opacity : d.mo);\n  if (fns.ms2mrc) {\n    var r;\n\n    // handle multi-trace graph edit case\n    if (d.ms === 'various' || marker.size === 'various') {\n      r = 3;\n    } else {\n      r = fns.ms2mrc(d.ms);\n    }\n\n    // store the calculated size so hover can use it\n    d.mrc = r;\n    if (fns.selectedSizeFn) {\n      r = d.mrc = fns.selectedSizeFn(d);\n    }\n\n    // turn the symbol into a sanitized number\n    var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;\n\n    // save if this marker is open\n    // because that impacts how to handle colors\n    d.om = x % 200 >= 100;\n    var angle = getMarkerAngle(d, trace);\n    var standoff = getMarkerStandoff(d, trace);\n    sel.attr('d', makePointPath(x, r, angle, standoff));\n  }\n  var perPointGradient = false;\n  var fillColor, lineColor, lineWidth;\n\n  // 'so' is suspected outliers, for box plots\n  if (d.so) {\n    lineWidth = markerLine.outlierwidth;\n    lineColor = markerLine.outliercolor;\n    fillColor = marker.outliercolor;\n  } else {\n    var markerLineWidth = (markerLine || {}).width;\n    lineWidth = (d.mlw + 1 || markerLineWidth + 1 ||\n    // TODO: we need the latter for legends... can we get rid of it?\n    (d.trace ? (d.trace.marker.line || {}).width : 0) + 1) - 1 || 0;\n    if ('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc);\n    // weird case: array wasn't long enough to apply to every point\n    else if (Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;else lineColor = markerLine.color;\n    if (Lib.isArrayOrTypedArray(marker.color)) {\n      fillColor = Color.defaultLine;\n      perPointGradient = true;\n    }\n    if ('mc' in d) {\n      fillColor = d.mcc = fns.markerScale(d.mc);\n    } else {\n      fillColor = marker.color || 'rgba(0,0,0,0)';\n    }\n    if (fns.selectedColorFn) {\n      fillColor = fns.selectedColorFn(d);\n    }\n  }\n  if (d.om) {\n    // open markers can't have zero linewidth, default to 1px,\n    // and use fill color as stroke color\n    sel.call(Color.stroke, fillColor).style({\n      'stroke-width': (lineWidth || 1) + 'px',\n      fill: 'none'\n    });\n  } else {\n    sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');\n    var markerGradient = marker.gradient;\n    var gradientType = d.mgt;\n    if (gradientType) perPointGradient = true;else gradientType = markerGradient && markerGradient.type;\n\n    // for legend - arrays will propagate through here, but we don't need\n    // to treat it as per-point.\n    if (Lib.isArrayOrTypedArray(gradientType)) {\n      gradientType = gradientType[0];\n      if (!gradientInfo[gradientType]) gradientType = 0;\n    }\n    var markerPattern = marker.pattern;\n    var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, '');\n    if (gradientType && gradientType !== 'none') {\n      var gradientColor = d.mgc;\n      if (gradientColor) perPointGradient = true;else gradientColor = markerGradient.color;\n      var gradientID = trace.uid;\n      if (perPointGradient) gradientID += '-' + d.i;\n      drawing.gradient(sel, gd, gradientID, gradientType, [[0, gradientColor], [1, fillColor]], 'fill');\n    } else if (patternShape) {\n      var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);\n      var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, d.i, null);\n      var patternFGOpacity = markerPattern.fgopacity;\n      var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);\n      var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);\n      var perPointPattern = d.mcc || Lib.isArrayOrTypedArray(markerPattern.shape) || Lib.isArrayOrTypedArray(markerPattern.bgcolor) || Lib.isArrayOrTypedArray(markerPattern.size) || Lib.isArrayOrTypedArray(markerPattern.solidity);\n      var patternID = trace.uid;\n      if (perPointPattern) patternID += '-' + d.i;\n      drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, d.mcc, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);\n    } else {\n      Color.fill(sel, fillColor);\n    }\n    if (lineWidth) {\n      Color.stroke(sel, lineColor);\n    }\n  }\n};\ndrawing.makePointStyleFns = function (trace) {\n  var out = {};\n  var marker = trace.marker;\n\n  // allow array marker and marker line colors to be\n  // scaled by given max and min to colorscales\n  out.markerScale = drawing.tryColorscale(marker, '');\n  out.lineScale = drawing.tryColorscale(marker, 'line');\n  if (Registry.traceIs(trace, 'symbols')) {\n    out.ms2mrc = subTypes.isBubble(trace) ? makeBubbleSizeFn(trace) : function () {\n      return (marker.size || 6) / 2;\n    };\n  }\n  if (trace.selectedpoints) {\n    Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));\n  }\n  return out;\n};\ndrawing.makeSelectedPointStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var marker = trace.marker || {};\n  var selectedMarker = selectedAttrs.marker || {};\n  var unselectedMarker = unselectedAttrs.marker || {};\n  var mo = marker.opacity;\n  var smo = selectedMarker.opacity;\n  var usmo = unselectedMarker.opacity;\n  var smoIsDefined = smo !== undefined;\n  var usmoIsDefined = usmo !== undefined;\n  if (Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {\n    out.selectedOpacityFn = function (d) {\n      var base = d.mo === undefined ? marker.opacity : d.mo;\n      if (d.selected) {\n        return smoIsDefined ? smo : base;\n      } else {\n        return usmoIsDefined ? usmo : DESELECTDIM * base;\n      }\n    };\n  }\n  var mc = marker.color;\n  var smc = selectedMarker.color;\n  var usmc = unselectedMarker.color;\n  if (smc || usmc) {\n    out.selectedColorFn = function (d) {\n      var base = d.mcc || mc;\n      if (d.selected) {\n        return smc || base;\n      } else {\n        return usmc || base;\n      }\n    };\n  }\n  var ms = marker.size;\n  var sms = selectedMarker.size;\n  var usms = unselectedMarker.size;\n  var smsIsDefined = sms !== undefined;\n  var usmsIsDefined = usms !== undefined;\n  if (Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {\n    out.selectedSizeFn = function (d) {\n      var base = d.mrc || ms / 2;\n      if (d.selected) {\n        return smsIsDefined ? sms / 2 : base;\n      } else {\n        return usmsIsDefined ? usms / 2 : base;\n      }\n    };\n  }\n  return out;\n};\ndrawing.makeSelectedTextStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var textFont = trace.textfont || {};\n  var selectedTextFont = selectedAttrs.textfont || {};\n  var unselectedTextFont = unselectedAttrs.textfont || {};\n  var tc = textFont.color;\n  var stc = selectedTextFont.color;\n  var utc = unselectedTextFont.color;\n  out.selectedTextColorFn = function (d) {\n    var base = d.tc || tc;\n    if (d.selected) {\n      return stc || base;\n    } else {\n      if (utc) return utc;else return stc ? base : Color.addOpacity(base, DESELECTDIM);\n    }\n  };\n  return out;\n};\ndrawing.selectedPointStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedPointStyleFns(trace);\n  var marker = trace.marker || {};\n  var seq = [];\n  if (fns.selectedOpacityFn) {\n    seq.push(function (pt, d) {\n      pt.style('opacity', fns.selectedOpacityFn(d));\n    });\n  }\n  if (fns.selectedColorFn) {\n    seq.push(function (pt, d) {\n      Color.fill(pt, fns.selectedColorFn(d));\n    });\n  }\n  if (fns.selectedSizeFn) {\n    seq.push(function (pt, d) {\n      var mx = d.mx || marker.symbol || 0;\n      var mrc2 = fns.selectedSizeFn(d);\n      pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));\n\n      // save for Drawing.selectedTextStyle\n      d.mrc2 = mrc2;\n    });\n  }\n  if (seq.length) {\n    s.each(function (d) {\n      var pt = d3.select(this);\n      for (var i = 0; i < seq.length; i++) {\n        seq[i](pt, d);\n      }\n    });\n  }\n};\ndrawing.tryColorscale = function (marker, prefix) {\n  var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;\n  if (cont) {\n    var colorArray = cont.color;\n    if ((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {\n      return Colorscale.makeColorScaleFuncFromTrace(cont);\n    }\n  }\n  return Lib.identity;\n};\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  end: -1,\n  middle: 0,\n  bottom: 1,\n  top: -1\n};\nfunction textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {\n  var group = d3.select(s.node().parentNode);\n  var v = textPosition.indexOf('top') !== -1 ? 'top' : textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';\n  var h = textPosition.indexOf('left') !== -1 ? 'end' : textPosition.indexOf('right') !== -1 ? 'start' : 'middle';\n\n  // if markers are shown, offset a little more than\n  // the nominal marker size\n  // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n  var r = markerRadius ? markerRadius / 0.8 + 1 : 0;\n  var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;\n  var dx = TEXTOFFSETSIGN[h] * r;\n  var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r + (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;\n\n  // fix the overall text group position\n  s.attr('text-anchor', h);\n  if (!dontTouchParent) {\n    group.attr('transform', strTranslate(dx, dy));\n  }\n}\nfunction extracTextFontSize(d, trace) {\n  var fontSize = d.ts || trace.textfont.size;\n  return isNumeric(fontSize) && fontSize > 0 ? fontSize : 0;\n}\n\n// draw text at points\ndrawing.textPointStyle = function (s, trace, gd) {\n  if (!s.size()) return;\n  var selectedTextColorFn;\n  if (trace.selectedpoints) {\n    var fns = drawing.makeSelectedTextStyleFns(trace);\n    selectedTextColorFn = fns.selectedTextColorFn;\n  }\n  var texttemplate = trace.texttemplate;\n  var fullLayout = gd._fullLayout;\n  s.each(function (d) {\n    var p = d3.select(this);\n    var text = texttemplate ? Lib.extractOption(d, trace, 'txt', 'texttemplate') : Lib.extractOption(d, trace, 'tx', 'text');\n    if (!text && text !== 0) {\n      p.remove();\n      return;\n    }\n    if (texttemplate) {\n      var fn = trace._module.formatLabels;\n      var labels = fn ? fn(d, trace, fullLayout) : {};\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, d.i);\n      var meta = trace._meta || {};\n      text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);\n    }\n    var pos = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    var fontColor = selectedTextColorFn ? selectedTextColorFn(d) : d.tc || trace.textfont.color;\n    p.call(drawing.font, d.tf || trace.textfont.family, fontSize, fontColor).text(text).call(svgTextUtils.convertToTspans, gd).call(textPointPosition, pos, fontSize, d.mrc);\n  });\n};\ndrawing.selectedTextStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedTextStyleFns(trace);\n  s.each(function (d) {\n    var tx = d3.select(this);\n    var tc = fns.selectedTextColorFn(d);\n    var tp = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    Color.fill(tx, tc);\n    var dontTouchParent = Registry.traceIs(trace, 'bar-like');\n    textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);\n  });\n};\n\n// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp = 0.5;\ndrawing.smoothopen = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L');\n  }\n  var path = 'M' + pts[0];\n  var tangents = [];\n  var i;\n  for (i = 1; i < pts.length - 1; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n  path += 'Q' + tangents[0][0] + ' ' + pts[1];\n  for (i = 2; i < pts.length - 1; i++) {\n    path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n  }\n  path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n  return path;\n};\ndrawing.smoothclosed = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L') + 'Z';\n  }\n  var path = 'M' + pts[0];\n  var pLast = pts.length - 1;\n  var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];\n  var i;\n  for (i = 1; i < pLast; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n  tangents.push(makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness));\n  for (i = 1; i <= pLast; i++) {\n    path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n  }\n  path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n  return path;\n};\nvar lastDrawnX, lastDrawnY;\nfunction roundEnd(pt, isY, isLastPoint) {\n  if (isLastPoint) pt = applyBackoff(pt);\n  return isY ? roundY(pt[1]) : roundX(pt[0]);\n}\nfunction roundX(p) {\n  var v = d3.round(p, 2);\n  lastDrawnX = v;\n  return v;\n}\nfunction roundY(p) {\n  var v = d3.round(p, 2);\n  lastDrawnY = v;\n  return v;\n}\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n  var d1x = prevpt[0] - thispt[0];\n  var d1y = prevpt[1] - thispt[1];\n  var d2x = nextpt[0] - thispt[0];\n  var d2y = nextpt[1] - thispt[1];\n  var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);\n  var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);\n  var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;\n  var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;\n  var denom1 = 3 * d2a * (d1a + d2a);\n  var denom2 = 3 * d1a * (d1a + d2a);\n  return [[roundX(thispt[0] + (denom1 && numx / denom1)), roundY(thispt[1] + (denom1 && numy / denom1))], [roundX(thispt[0] - (denom2 && numx / denom2)), roundY(thispt[1] - (denom2 && numy / denom2))]];\n}\n\n// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH = {\n  hv: function (p0, p1, isLastPoint) {\n    return 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);\n  },\n  vh: function (p0, p1, isLastPoint) {\n    return 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);\n  },\n  hvh: function (p0, p1, isLastPoint) {\n    return 'H' + roundX((p0[0] + p1[0]) / 2) + 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);\n  },\n  vhv: function (p0, p1, isLastPoint) {\n    return 'V' + roundY((p0[1] + p1[1]) / 2) + 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);\n  }\n};\nvar STEPLINEAR = function (p0, p1, isLastPoint) {\n  return 'L' + roundEnd(p1, 0, isLastPoint) + ',' + roundEnd(p1, 1, isLastPoint);\n};\ndrawing.steps = function (shape) {\n  var onestep = STEPPATH[shape] || STEPLINEAR;\n  return function (pts) {\n    var path = 'M' + roundX(pts[0][0]) + ',' + roundY(pts[0][1]);\n    var len = pts.length;\n    for (var i = 1; i < len; i++) {\n      path += onestep(pts[i - 1], pts[i], i === len - 1);\n    }\n    return path;\n  };\n};\nfunction applyBackoff(pt, start) {\n  var backoff = pt.backoff;\n  var trace = pt.trace;\n  var d = pt.d;\n  var i = pt.i;\n  if (backoff && trace && trace.marker && trace.marker.angle % 360 === 0 && trace.line && trace.line.shape !== 'spline') {\n    var arrayBackoff = Lib.isArrayOrTypedArray(backoff);\n    var end = pt;\n    var x1 = start ? start[0] : lastDrawnX || 0;\n    var y1 = start ? start[1] : lastDrawnY || 0;\n    var x2 = end[0];\n    var y2 = end[1];\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var t = Math.atan2(dy, dx);\n    var b = arrayBackoff ? backoff[i] : backoff;\n    if (b === 'auto') {\n      var endI = end.i;\n      if (trace.type === 'scatter') endI--; // Why we need this hack?\n\n      var endMarker = end.marker;\n      var endMarkerSymbol = endMarker.symbol;\n      if (Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];\n      var endMarkerSize = endMarker.size;\n      if (Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];\n      b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;\n      b += drawing.getMarkerStandoff(d[endI], trace) || 0;\n    }\n    var x = x2 - b * Math.cos(t);\n    var y = y2 - b * Math.sin(t);\n    if ((x <= x2 && x >= x1 || x >= x2 && x <= x1) && (y <= y2 && y >= y1 || y >= y2 && y <= y1)) {\n      pt = [x, y];\n    }\n  }\n  return pt;\n}\ndrawing.applyBackoff = applyBackoff;\n\n// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\ndrawing.makeTester = function () {\n  var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function (s) {\n    s.attr(xmlnsNamespaces.svgAttrs).style({\n      position: 'absolute',\n      left: '-10000px',\n      top: '-10000px',\n      width: '9000px',\n      height: '9000px',\n      'z-index': '1'\n    });\n  });\n\n  // browsers differ on how they describe the bounding rect of\n  // the svg if its contents spill over... so make a 1x1px\n  // reference point we can measure off of.\n  var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function (s) {\n    s.attr('d', 'M0,0H1V1H0Z').style({\n      'stroke-width': 0,\n      fill: 'black'\n    });\n  });\n  drawing.tester = tester;\n  drawing.testref = testref;\n};\n\n/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */\ndrawing.savedBBoxes = {};\nvar savedBBoxesCount = 0;\nvar maxSavedBBoxes = 10000;\ndrawing.bBox = function (node, inTester, hash) {\n  /*\n   * Cache elements we've already measured so we don't have to\n   * remeasure the same thing many times\n   * We have a few bBox callers though who pass a node larger than\n   * a <text> or a MathJax <g>, such as an axis group containing many labels.\n   * These will not generate a hash (unless we figure out an appropriate\n   * hash key for them) and thus we will not hash them.\n   */\n  if (!hash) hash = nodeHash(node);\n  var out;\n  if (hash) {\n    out = drawing.savedBBoxes[hash];\n    if (out) return Lib.extendFlat({}, out);\n  } else if (node.childNodes.length === 1) {\n    /*\n     * If we have only one child element, which is itself hashable, make\n     * a new hash from this element plus its x,y,transform\n     * These bounding boxes *include* x,y,transform - mostly for use by\n     * callers trying to avoid overlaps (ie titles)\n     */\n    var innerNode = node.childNodes[0];\n    hash = nodeHash(innerNode);\n    if (hash) {\n      var x = +innerNode.getAttribute('x') || 0;\n      var y = +innerNode.getAttribute('y') || 0;\n      var transform = innerNode.getAttribute('transform');\n      if (!transform) {\n        // in this case, just varying x and y, don't bother caching\n        // the final bBox because the alteration is quick.\n        var innerBB = drawing.bBox(innerNode, false, hash);\n        if (x) {\n          innerBB.left += x;\n          innerBB.right += x;\n        }\n        if (y) {\n          innerBB.top += y;\n          innerBB.bottom += y;\n        }\n        return innerBB;\n      }\n      /*\n       * else we have a transform - rather than make a complicated\n       * (and error-prone and probably slow) transform parser/calculator,\n       * just continue on calculating the boundingClientRect of the group\n       * and use the new composite hash to cache it.\n       * That said, `innerNode.transform.baseVal` is an array of\n       * `SVGTransform` objects, that *do* seem to have a nice matrix\n       * multiplication interface that we could use to avoid making\n       * another getBoundingClientRect call...\n       */\n      hash += '~' + x + '~' + y + '~' + transform;\n      out = drawing.savedBBoxes[hash];\n      if (out) return Lib.extendFlat({}, out);\n    }\n  }\n  var testNode, tester;\n  if (inTester) {\n    testNode = node;\n  } else {\n    tester = drawing.tester.node();\n\n    // copy the node to test into the tester\n    testNode = node.cloneNode(true);\n    tester.appendChild(testNode);\n  }\n\n  // standardize its position (and newline tspans if any)\n  d3.select(testNode).attr('transform', null).call(svgTextUtils.positionText, 0, 0);\n  var testRect = testNode.getBoundingClientRect();\n  var refRect = drawing.testref.node().getBoundingClientRect();\n  if (!inTester) tester.removeChild(testNode);\n  var bb = {\n    height: testRect.height,\n    width: testRect.width,\n    left: testRect.left - refRect.left,\n    top: testRect.top - refRect.top,\n    right: testRect.right - refRect.left,\n    bottom: testRect.bottom - refRect.top\n  };\n\n  // make sure we don't have too many saved boxes,\n  // or a long session could overload on memory\n  // by saving boxes for long-gone elements\n  if (savedBBoxesCount >= maxSavedBBoxes) {\n    drawing.savedBBoxes = {};\n    savedBBoxesCount = 0;\n  }\n\n  // cache this bbox\n  if (hash) drawing.savedBBoxes[hash] = bb;\n  savedBBoxesCount++;\n  return Lib.extendFlat({}, bb);\n};\n\n// capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\nfunction nodeHash(node) {\n  var inputText = node.getAttribute('data-unformatted');\n  if (inputText === null) return;\n  return inputText + node.getAttribute('data-math') + node.getAttribute('text-anchor') + node.getAttribute('style');\n}\n\n/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */\ndrawing.setClipUrl = function (s, localId, gd) {\n  s.attr('clip-path', getFullUrl(localId, gd));\n};\nfunction getFullUrl(localId, gd) {\n  if (!localId) return null;\n  var context = gd._context;\n  var baseUrl = context._exportedPlot ? '' : context._baseUrl || '';\n  return baseUrl ? 'url(\\'' + baseUrl + '#' + localId + '\\')' : 'url(#' + localId + ')';\n}\ndrawing.getTranslate = function (element) {\n  // Note the separator [^\\d] between x and y in this regex\n  // We generally use ',' but IE will convert it to ' '\n  var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 0,\n    y: +translate[1] || 0\n  };\n};\ndrawing.setTranslate = function (element, x, y) {\n  var re = /(\\btranslate\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 0;\n  y = y || 0;\n  transform = transform.replace(re, '').trim();\n  transform += strTranslate(x, y);\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\ndrawing.getScale = function (element) {\n  var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 1,\n    y: +translate[1] || 1\n  };\n};\ndrawing.setScale = function (element, x, y) {\n  var re = /(\\bscale\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 1;\n  y = y || 1;\n  transform = transform.replace(re, '').trim();\n  transform += 'scale(' + x + ',' + y + ')';\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\nvar SCALE_RE = /\\s*sc.*/;\ndrawing.setPointGroupScale = function (selection, xScale, yScale) {\n  xScale = xScale || 1;\n  yScale = yScale || 1;\n  if (!selection) return;\n\n  // The same scale transform for every point:\n  var scale = xScale === 1 && yScale === 1 ? '' : 'scale(' + xScale + ',' + yScale + ')';\n  selection.each(function () {\n    var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');\n    t += scale;\n    t = t.trim();\n    this.setAttribute('transform', t);\n  });\n};\nvar TEXT_POINT_LAST_TRANSLATION_RE = /translate\\([^)]*\\)\\s*$/;\ndrawing.setTextPointsScale = function (selection, xScale, yScale) {\n  if (!selection) return;\n  selection.each(function () {\n    var transforms;\n    var el = d3.select(this);\n    var text = el.select('text');\n    if (!text.node()) return;\n    var x = parseFloat(text.attr('x') || 0);\n    var y = parseFloat(text.attr('y') || 0);\n    var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);\n    if (xScale === 1 && yScale === 1) {\n      transforms = [];\n    } else {\n      transforms = [strTranslate(x, y), 'scale(' + xScale + ',' + yScale + ')', strTranslate(-x, -y)];\n    }\n    if (existingTransform) {\n      transforms.push(existingTransform);\n    }\n    el.attr('transform', transforms.join(''));\n  });\n};\nfunction getMarkerStandoff(d, trace) {\n  var standoff;\n  if (d) standoff = d.mf;\n  if (standoff === undefined) {\n    standoff = trace.marker ? trace.marker.standoff || 0 : 0;\n  }\n  if (!trace._geo && !trace._xA) {\n    // case of legends\n    return -standoff;\n  }\n  return standoff;\n}\ndrawing.getMarkerStandoff = getMarkerStandoff;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar sin = Math.sin;\nfunction rotate(t, xy) {\n  var x = xy[0];\n  var y = xy[1];\n  return [x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)];\n}\nvar previousLon;\nvar previousLat;\nvar previousX;\nvar previousY;\nvar previousI;\nvar previousTraceUid;\nfunction getMarkerAngle(d, trace) {\n  var angle = d.ma;\n  if (angle === undefined) {\n    angle = trace.marker.angle || 0;\n  }\n  var x, y;\n  var ref = trace.marker.angleref;\n  if (ref === 'previous' || ref === 'north') {\n    if (trace._geo) {\n      var p = trace._geo.project(d.lonlat);\n      x = p[0];\n      y = p[1];\n    } else {\n      var xa = trace._xA;\n      var ya = trace._yA;\n      if (xa && ya) {\n        x = xa.c2p(d.x);\n        y = ya.c2p(d.y);\n      } else {\n        // case of legends\n        return 90;\n      }\n    }\n    if (trace._geo) {\n      var lon = d.lonlat[0];\n      var lat = d.lonlat[1];\n      var north = trace._geo.project([lon, lat + 1e-5 // epsilon\n      ]);\n\n      var east = trace._geo.project([lon + 1e-5,\n      // epsilon\n      lat]);\n      var u = atan2(east[1] - y, east[0] - x);\n      var v = atan2(north[1] - y, north[0] - x);\n      var t;\n      if (ref === 'north') {\n        t = angle / 180 * Math.PI;\n        // To use counter-clockwise angles i.e.\n        // East: 90, West: -90\n        // to facilitate wind visualisations\n        // in future we should use t = -t here.\n      } else if (ref === 'previous') {\n        var lon1 = lon / 180 * Math.PI;\n        var lat1 = lat / 180 * Math.PI;\n        var lon2 = previousLon / 180 * Math.PI;\n        var lat2 = previousLat / 180 * Math.PI;\n        var dLon = lon2 - lon1;\n        var deltaY = cos(lat2) * sin(dLon);\n        var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);\n        t = -atan2(deltaY, deltaX) - Math.PI;\n        previousLon = lon;\n        previousLat = lat;\n      }\n      var A = rotate(u, [cos(t), 0]);\n      var B = rotate(v, [sin(t), 0]);\n      angle = atan2(A[1] + B[1], A[0] + B[0]) / Math.PI * 180;\n      if (ref === 'previous' && !(previousTraceUid === trace.uid && d.i === previousI + 1)) {\n        angle = null;\n      }\n    }\n    if (ref === 'previous' && !trace._geo) {\n      if (previousTraceUid === trace.uid && d.i === previousI + 1 && isNumeric(x) && isNumeric(y)) {\n        var dX = x - previousX;\n        var dY = y - previousY;\n        var shape = trace.line ? trace.line.shape || '' : '';\n        var lastShapeChar = shape.slice(shape.length - 1);\n        if (lastShapeChar === 'h') dY = 0;\n        if (lastShapeChar === 'v') dX = 0;\n        angle += atan2(dY, dX) / Math.PI * 180 + 90;\n      } else {\n        angle = null;\n      }\n    }\n  }\n  previousX = x;\n  previousY = y;\n  previousI = d.i;\n  previousTraceUid = trace.uid;\n  return angle;\n}\ndrawing.getMarkerAngle = getMarkerAngle;","map":{"version":3,"names":["d3","require","Lib","numberFormat","isNumeric","tinycolor","Registry","Color","Colorscale","strTranslate","svgTextUtils","xmlnsNamespaces","alignment","LINE_SPACING","DESELECTDIM","subTypes","makeBubbleSizeFn","appendArrayPointValue","drawing","module","exports","font","s","family","size","color","isPlainObject","style","call","fill","setPosition","x","y","attr","setSize","w","h","setRect","translatePoint","d","sel","xa","ya","c2p","node","nodeName","translatePoints","each","select","hideOutsideRangePoint","xcalendar","ycalendar","isPtWithinRange","hideOutsideRangePoints","traceGroups","subplot","_hasClipOnAxisFalse","xaxis","yaxis","trace","selector","traceIs","selectAll","crispRound","gd","lineWidth","dflt","_context","staticPlot","Math","round","singleLineStyle","lw","lc","ld","line","lw1","width","dash","stroke","dashLine","lineGroupStyle","dashStyle","dlw","max","setFillStyle","markerPattern","fillpattern","patternShape","getPatternAttr","shape","patternBGColor","bgcolor","patternFGColor","fgcolor","patternFGOpacity","fgopacity","patternSize","patternSolidity","solidity","patternID","uid","pattern","undefined","fillmode","fillcolor","singleFillStyle","data","fillGroupStyle","SYMBOLDEFS","symbolNames","symbolFuncs","symbolBackOffs","symbolNeedLines","symbolNoDot","symbolNoFill","symbolList","Object","keys","forEach","k","symDef","n","push","String","f","backoff","needLine","noDot","noFill","MAXSYMBOL","length","DOTPATH","symbolNumber","v","vbase","indexOf","replace","floor","makePointPath","r","t","base","HORZGRADIENT","x1","x2","y1","y2","VERTGRADIENT","stopFormatter","gradientInfo","radial","radialreversed","reversed","horizontal","attrs","horizontalreversed","vertical","verticalreversed","gradient","gradientID","type","colorscale","prop","len","info","colorStops","Array","i","fullLayout","_fullLayout","fullID","_uid","_defs","join","identity","exit","remove","enter","append","el","stops","tc","offset","tinyRGB","getAlpha","getFullUrl","classed","calledBy","mcc","isLegend","contrast","height","linearFn","x0","y0","path","linewidth","radius","patternTag","patternAttrs","fgC","fgRGB","fgAlpha","opacity","sqrt","PI","cx","cy","str","id","patternUnits","patternTransform","bgC","bgRGB","bgAlpha","rects","patterns","initGradients","gradientsGroup","ensureSingle","initPatterns","patternsGroup","mp","isArrayOrTypedArray","pointStyle","fns","makePointStyleFns","singlePointStyle","marker","markerLine","selectedOpacityFn","mo","ms2mrc","ms","mrc","selectedSizeFn","mx","symbol","om","angle","getMarkerAngle","standoff","getMarkerStandoff","perPointGradient","fillColor","lineColor","so","outlierwidth","outliercolor","markerLineWidth","mlw","mlcc","lineScale","mlc","defaultLine","markerScale","mc","selectedColorFn","isBlank","markerGradient","gradientType","mgt","gradientColor","mgc","perPointPattern","out","tryColorscale","isBubble","selectedpoints","extendFlat","makeSelectedPointStyleFns","selectedAttrs","selected","unselectedAttrs","unselected","selectedMarker","unselectedMarker","smo","usmo","smoIsDefined","usmoIsDefined","smc","usmc","sms","usms","smsIsDefined","usmsIsDefined","makeSelectedTextStyleFns","textFont","textfont","selectedTextFont","unselectedTextFont","stc","utc","selectedTextColorFn","addOpacity","selectedPointStyle","seq","pt","mrc2","prefix","cont","nestedProperty","get","colorArray","_colorAx","makeColorScaleFuncFromTrace","TEXTOFFSETSIGN","start","end","middle","bottom","top","textPointPosition","textPosition","fontSize","markerRadius","dontTouchParent","group","parentNode","numLines","lineCount","dx","dy","extracTextFontSize","ts","textPointStyle","texttemplate","p","text","extractOption","fn","_module","formatLabels","labels","pointValues","meta","_meta","texttemplateString","_d3locale","pos","tp","textposition","fontColor","tf","convertToTspans","selectedTextStyle","tx","CatmullRomExp","smoothopen","pts","smoothness","tangents","makeTangent","smoothclosed","pLast","lastDrawnX","lastDrawnY","roundEnd","isY","isLastPoint","applyBackoff","roundY","roundX","prevpt","thispt","nextpt","d1x","d1y","d2x","d2y","d1a","pow","d2a","numx","numy","denom1","denom2","STEPPATH","hv","p0","p1","vh","hvh","vhv","STEPLINEAR","steps","onestep","arrayBackoff","atan2","b","endI","endMarker","endMarkerSymbol","endMarkerSize","cos","sin","makeTester","tester","ensureSingleById","svgAttrs","position","left","testref","savedBBoxes","savedBBoxesCount","maxSavedBBoxes","bBox","inTester","hash","nodeHash","childNodes","innerNode","getAttribute","transform","innerBB","right","testNode","cloneNode","appendChild","positionText","testRect","getBoundingClientRect","refRect","removeChild","bb","inputText","setClipUrl","localId","context","baseUrl","_exportedPlot","_baseUrl","getTranslate","element","re","getter","translate","match","p2","split","setTranslate","setter","trim","getScale","setScale","SCALE_RE","setPointGroupScale","selection","xScale","yScale","scale","setAttribute","TEXT_POINT_LAST_TRANSLATION_RE","setTextPointsScale","transforms","parseFloat","existingTransform","mf","_geo","_xA","rotate","xy","previousLon","previousLat","previousX","previousY","previousI","previousTraceUid","ma","ref","angleref","project","lonlat","_yA","lon","lat","north","east","u","lon1","lat1","lon2","lat2","dLon","deltaY","deltaX","A","B","dX","dY","lastShapeChar","slice"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/components/drawing/index.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Color = require('../color');\nvar Colorscale = require('../colorscale');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignment = require('../../constants/alignment');\nvar LINE_SPACING = alignment.LINE_SPACING;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar subTypes = require('../../traces/scatter/subtypes');\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar drawing = module.exports = {};\n\n// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\ndrawing.font = function(s, family, size, color) {\n    // also allow the form font(s, {family, size, color})\n    if(Lib.isPlainObject(family)) {\n        color = family.color;\n        size = family.size;\n        family = family.family;\n    }\n    if(family) s.style('font-family', family);\n    if(size + 1) s.style('font-size', size + 'px');\n    if(color) s.call(Color.fill, color);\n};\n\n/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */\ndrawing.setPosition = function(s, x, y) { s.attr('x', x).attr('y', y); };\ndrawing.setSize = function(s, w, h) { s.attr('width', w).attr('height', h); };\ndrawing.setRect = function(s, x, y, w, h) {\n    s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n\n/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */\ndrawing.translatePoint = function(d, sel, xa, ya) {\n    var x = xa.c2p(d.x);\n    var y = ya.c2p(d.y);\n\n    if(isNumeric(x) && isNumeric(y) && sel.node()) {\n        // for multiline text this works better\n        if(sel.node().nodeName === 'text') {\n            sel.attr('x', x).attr('y', y);\n        } else {\n            sel.attr('transform', strTranslate(x, y));\n        }\n    } else {\n        return false;\n    }\n\n    return true;\n};\n\ndrawing.translatePoints = function(s, xa, ya) {\n    s.each(function(d) {\n        var sel = d3.select(this);\n        drawing.translatePoint(d, sel, xa, ya);\n    });\n};\n\ndrawing.hideOutsideRangePoint = function(d, sel, xa, ya, xcalendar, ycalendar) {\n    sel.attr(\n        'display',\n        (xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar)) ? null : 'none'\n    );\n};\n\ndrawing.hideOutsideRangePoints = function(traceGroups, subplot) {\n    if(!subplot._hasClipOnAxisFalse) return;\n\n    var xa = subplot.xaxis;\n    var ya = subplot.yaxis;\n\n    traceGroups.each(function(d) {\n        var trace = d[0].trace;\n        var xcalendar = trace.xcalendar;\n        var ycalendar = trace.ycalendar;\n        var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';\n\n        traceGroups.selectAll(selector).each(function(d) {\n            drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);\n        });\n    });\n};\n\ndrawing.crispRound = function(gd, lineWidth, dflt) {\n    // for lines that disable antialiasing we want to\n    // make sure the width is an integer, and at least 1 if it's nonzero\n\n    if(!lineWidth || !isNumeric(lineWidth)) return dflt || 0;\n\n    // but not for static plots - these don't get antialiased anyway.\n    if(gd._context.staticPlot) return lineWidth;\n\n    if(lineWidth < 1) return 1;\n    return Math.round(lineWidth);\n};\n\ndrawing.singleLineStyle = function(d, s, lw, lc, ld) {\n    s.style('fill', 'none');\n    var line = (((d || [])[0] || {}).trace || {}).line || {};\n    var lw1 = lw || line.width || 0;\n    var dash = ld || line.dash || '';\n\n    Color.stroke(s, lc || line.color);\n    drawing.dashLine(s, dash, lw1);\n};\n\ndrawing.lineGroupStyle = function(s, lw, lc, ld) {\n    s.style('fill', 'none')\n    .each(function(d) {\n        var line = (((d || [])[0] || {}).trace || {}).line || {};\n        var lw1 = lw || line.width || 0;\n        var dash = ld || line.dash || '';\n\n        d3.select(this)\n            .call(Color.stroke, lc || line.color)\n            .call(drawing.dashLine, dash, lw1);\n    });\n};\n\ndrawing.dashLine = function(s, dash, lineWidth) {\n    lineWidth = +lineWidth || 0;\n\n    dash = drawing.dashStyle(dash, lineWidth);\n\n    s.style({\n        'stroke-dasharray': dash,\n        'stroke-width': lineWidth + 'px'\n    });\n};\n\ndrawing.dashStyle = function(dash, lineWidth) {\n    lineWidth = +lineWidth || 1;\n    var dlw = Math.max(lineWidth, 3);\n\n    if(dash === 'solid') dash = '';\n    else if(dash === 'dot') dash = dlw + 'px,' + dlw + 'px';\n    else if(dash === 'dash') dash = (3 * dlw) + 'px,' + (3 * dlw) + 'px';\n    else if(dash === 'longdash') dash = (5 * dlw) + 'px,' + (5 * dlw) + 'px';\n    else if(dash === 'dashdot') {\n        dash = (3 * dlw) + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n    } else if(dash === 'longdashdot') {\n        dash = (5 * dlw) + 'px,' + (2 * dlw) + 'px,' + dlw + 'px,' + (2 * dlw) + 'px';\n    }\n    // otherwise user wrote the dasharray themselves - leave it be\n\n    return dash;\n};\n\nfunction setFillStyle(sel, trace, gd) {\n    var markerPattern = trace.fillpattern;\n    var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, '');\n    if(patternShape) {\n        var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);\n        var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);\n        var patternFGOpacity = markerPattern.fgopacity;\n        var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);\n        var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);\n        var patternID = trace.uid;\n        drawing.pattern(sel, 'point', gd, patternID,\n            patternShape, patternSize, patternSolidity,\n            undefined, markerPattern.fillmode,\n            patternBGColor, patternFGColor, patternFGOpacity\n        );\n    } else if(trace.fillcolor) {\n        sel.call(Color.fill, trace.fillcolor);\n    }\n}\n\n// Same as fillGroupStyle, except in this case the selection may be a transition\ndrawing.singleFillStyle = function(sel, gd) {\n    var node = d3.select(sel.node());\n    var data = node.data();\n    var trace = ((data[0] || [])[0] || {}).trace || {};\n    setFillStyle(sel, trace, gd);\n};\n\ndrawing.fillGroupStyle = function(s, gd) {\n    s.style('stroke-width', 0)\n    .each(function(d) {\n        var shape = d3.select(this);\n        // N.B. 'd' won't be a calcdata item when\n        // fill !== 'none' on a segment-less and marker-less trace\n        if(d[0].trace) {\n            setFillStyle(shape, d[0].trace, gd);\n        }\n    });\n};\n\nvar SYMBOLDEFS = require('./symbol_defs');\n\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolBackOffs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolNoFill = {};\ndrawing.symbolList = [];\n\nObject.keys(SYMBOLDEFS).forEach(function(k) {\n    var symDef = SYMBOLDEFS[k];\n    var n = symDef.n;\n    drawing.symbolList.push(\n        n,\n        String(n),\n        k,\n\n        n + 100,\n        String(n + 100),\n        k + '-open'\n    );\n    drawing.symbolNames[n] = k;\n    drawing.symbolFuncs[n] = symDef.f;\n    drawing.symbolBackOffs[n] = symDef.backoff || 0;\n\n    if(symDef.needLine) {\n        drawing.symbolNeedLines[n] = true;\n    }\n    if(symDef.noDot) {\n        drawing.symbolNoDot[n] = true;\n    } else {\n        drawing.symbolList.push(\n            n + 200,\n            String(n + 200),\n            k + '-dot',\n\n            n + 300,\n            String(n + 300),\n            k + '-open-dot'\n        );\n    }\n    if(symDef.noFill) {\n        drawing.symbolNoFill[n] = true;\n    }\n});\n\nvar MAXSYMBOL = drawing.symbolNames.length;\n// add a dot in the middle of the symbol\nvar DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\n\ndrawing.symbolNumber = function(v) {\n    if(isNumeric(v)) {\n        v = +v;\n    } else if(typeof v === 'string') {\n        var vbase = 0;\n        if(v.indexOf('-open') > 0) {\n            vbase = 100;\n            v = v.replace('-open', '');\n        }\n        if(v.indexOf('-dot') > 0) {\n            vbase += 200;\n            v = v.replace('-dot', '');\n        }\n        v = drawing.symbolNames.indexOf(v);\n        if(v >= 0) { v += vbase; }\n    }\n\n    return (v % 100 >= MAXSYMBOL || v >= 400) ?\n        0 : Math.floor(Math.max(v, 0));\n};\n\nfunction makePointPath(symbolNumber, r, t, s) {\n    var base = symbolNumber % 100;\n    return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : '');\n}\n\nvar HORZGRADIENT = {x1: 1, x2: 0, y1: 0, y2: 0};\nvar VERTGRADIENT = {x1: 0, x2: 0, y1: 1, y2: 0};\nvar stopFormatter = numberFormat('~f');\nvar gradientInfo = {\n    radial: {node: 'radialGradient'},\n    radialreversed: {node: 'radialGradient', reversed: true},\n    horizontal: {node: 'linearGradient', attrs: HORZGRADIENT},\n    horizontalreversed: {node: 'linearGradient', attrs: HORZGRADIENT, reversed: true},\n    vertical: {node: 'linearGradient', attrs: VERTGRADIENT},\n    verticalreversed: {node: 'linearGradient', attrs: VERTGRADIENT, reversed: true}\n};\n\n/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */\ndrawing.gradient = function(sel, gd, gradientID, type, colorscale, prop) {\n    var len = colorscale.length;\n    var info = gradientInfo[type];\n    var colorStops = new Array(len);\n    for(var i = 0; i < len; i++) {\n        if(info.reversed) {\n            colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];\n        } else {\n            colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];\n        }\n    }\n\n    var fullLayout = gd._fullLayout;\n    var fullID = 'g' + fullLayout._uid + '-' + gradientID;\n\n    var gradient = fullLayout._defs.select('.gradients')\n        .selectAll('#' + fullID)\n        .data([type + colorStops.join(';')], Lib.identity);\n\n    gradient.exit().remove();\n\n    gradient.enter()\n        .append(info.node)\n        .each(function() {\n            var el = d3.select(this);\n            if(info.attrs) el.attr(info.attrs);\n\n            el.attr('id', fullID);\n\n            var stops = el.selectAll('stop')\n                .data(colorStops);\n            stops.exit().remove();\n            stops.enter().append('stop');\n\n            stops.each(function(d) {\n                var tc = tinycolor(d[1]);\n                d3.select(this).attr({\n                    offset: d[0] + '%',\n                    'stop-color': Color.tinyRGB(tc),\n                    'stop-opacity': tc.getAlpha()\n                });\n            });\n        });\n\n    sel.style(prop, getFullUrl(fullID, gd))\n        .style(prop + '-opacity', null);\n\n    sel.classed('gradient_filled', true);\n};\n\n/**\n * pattern: create and apply a pattern fill\n *\n * @param {object} sel: d3 selection to apply this pattern to\n *     You can use `selection.call(Drawing.pattern, ...)`\n * @param {string} calledBy: option to know the caller component\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} patternID: a unique (within this plot) identifier\n *     for this pattern, so that we don't create unnecessary definitions\n * @param {number} size: size of unit squares for repetition of this pattern\n * @param {number} solidity: how solid lines of this pattern are\n * @param {string} mcc: color when painted with colorscale\n * @param {string} fillmode: fillmode for this pattern\n * @param {string} bgcolor: background color for this pattern\n * @param {string} fgcolor: foreground color for this pattern\n * @param {number} fgopacity: foreground opacity for this pattern\n */\ndrawing.pattern = function(sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {\n    var isLegend = calledBy === 'legend';\n\n    if(mcc) {\n        if(fillmode === 'overlay') {\n            bgcolor = mcc;\n            fgcolor = Color.contrast(bgcolor);\n        } else {\n            bgcolor = undefined;\n            fgcolor = mcc;\n        }\n    }\n\n    var fullLayout = gd._fullLayout;\n    var fullID = 'p' + fullLayout._uid + '-' + patternID;\n    var width, height;\n\n    // linear interpolation\n    var linearFn = function(x, x0, x1, y0, y1) {\n        return y0 + (y1 - y0) * (x - x0) / (x1 - x0);\n    };\n\n    var path, linewidth, radius;\n    var patternTag;\n    var patternAttrs = {};\n\n    var fgC = tinycolor(fgcolor);\n    var fgRGB = Color.tinyRGB(fgC);\n    var fgAlpha = fgC.getAlpha();\n    var opacity = fgopacity * fgAlpha;\n\n    switch(shape) {\n        case '/':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M-' + (width / 4) + ',' + (height / 4) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M0,' + height + 'L' + width + ',0' +\n                   'M' + (width / 4 * 3) + ',' + (height / 4 * 5) + 'l' + (width / 2) + ',-' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '\\\\':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M' + (width / 4 * 3) + ',-' + (height / 4) + 'l' + (width / 2) + ',' + (height / 2) +\n                   'M0,0L' + width + ',' + height +\n                   'M-' + (width / 4) + ',' + (height / 4 * 3) + 'l' + (width / 2) + ',' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case 'x':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M-' + (width / 4) + ',' + (height / 4) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M0,' + height + 'L' + width + ',0' +\n                   'M' + (width / 4 * 3) + ',' + (height / 4 * 5) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M' + (width / 4 * 3) + ',-' + (height / 4) + 'l' + (width / 2) + ',' + (height / 2) +\n                   'M0,0L' + width + ',' + height +\n                   'M-' + (width / 4) + ',' + (height / 4 * 3) + 'l' + (width / 2) + ',' + (height / 2);\n            linewidth = size - size * Math.sqrt(1.0 - solidity);\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '|':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M' + (width / 2) + ',0L' + (width / 2) + ',' + height;\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '-':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M0,' + (height / 2) + 'L' + width + ',' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '+':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M' + (width / 2) + ',0L' + (width / 2) + ',' + height +\n                   'M0,' + (height / 2) + 'L' + width + ',' + (height / 2);\n            linewidth = size - size * Math.sqrt(1.0 - solidity);\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '.':\n            width = size;\n            height = size;\n            if(solidity < Math.PI / 4) {\n                radius = Math.sqrt(solidity * size * size / Math.PI);\n            } else {\n                radius = linearFn(solidity, Math.PI / 4, 1.0, size / 2, size / Math.sqrt(2));\n            }\n            patternTag = 'circle';\n            patternAttrs = {\n                cx: width / 2,\n                cy: height / 2,\n                r: radius,\n                opacity: opacity,\n                fill: fgRGB\n            };\n            break;\n    }\n\n    var str = [\n        shape || 'noSh',\n        bgcolor || 'noBg',\n        fgcolor || 'noFg',\n        size,\n        solidity\n    ].join(';');\n\n    var pattern = fullLayout._defs.select('.patterns')\n        .selectAll('#' + fullID)\n        .data([str], Lib.identity);\n\n    pattern.exit().remove();\n\n    pattern.enter()\n        .append('pattern')\n        .each(function() {\n            var el = d3.select(this);\n\n            el.attr({\n                id: fullID,\n                width: width + 'px',\n                height: height + 'px',\n                patternUnits: 'userSpaceOnUse',\n                // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons\n                patternTransform: isLegend ? 'scale(0.8)' : ''\n            });\n\n            if(bgcolor) {\n                var bgC = tinycolor(bgcolor);\n                var bgRGB = Color.tinyRGB(bgC);\n                var bgAlpha = bgC.getAlpha();\n\n                var rects = el.selectAll('rect').data([0]);\n                rects.exit().remove();\n                rects.enter()\n                    .append('rect')\n                    .attr({\n                        width: width + 'px',\n                        height: height + 'px',\n                        fill: bgRGB,\n                        'fill-opacity': bgAlpha,\n                    });\n            }\n\n            var patterns = el.selectAll(patternTag).data([0]);\n            patterns.exit().remove();\n            patterns.enter()\n                .append(patternTag)\n                .attr(patternAttrs);\n        });\n\n    sel.style('fill', getFullUrl(fullID, gd))\n        .style('fill-opacity', null);\n\n    sel.classed('pattern_filled', true);\n};\n\n/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */\ndrawing.initGradients = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var gradientsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'gradients');\n    gradientsGroup.selectAll('linearGradient,radialGradient').remove();\n\n    d3.select(gd).selectAll('.gradient_filled').classed('gradient_filled', false);\n};\n\ndrawing.initPatterns = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var patternsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'patterns');\n    patternsGroup.selectAll('pattern').remove();\n\n    d3.select(gd).selectAll('.pattern_filled').classed('pattern_filled', false);\n};\n\ndrawing.getPatternAttr = function(mp, i, dflt) {\n    if(mp && Lib.isArrayOrTypedArray(mp)) {\n        return i < mp.length ? mp[i] : dflt;\n    }\n    return mp;\n};\n\ndrawing.pointStyle = function(s, trace, gd) {\n    if(!s.size()) return;\n\n    var fns = drawing.makePointStyleFns(trace);\n\n    s.each(function(d) {\n        drawing.singlePointStyle(d, d3.select(this), trace, fns, gd);\n    });\n};\n\ndrawing.singlePointStyle = function(d, sel, trace, fns, gd) {\n    var marker = trace.marker;\n    var markerLine = marker.line;\n\n    sel.style('opacity',\n        fns.selectedOpacityFn ? fns.selectedOpacityFn(d) :\n            (d.mo === undefined ? marker.opacity : d.mo)\n    );\n\n    if(fns.ms2mrc) {\n        var r;\n\n        // handle multi-trace graph edit case\n        if(d.ms === 'various' || marker.size === 'various') {\n            r = 3;\n        } else {\n            r = fns.ms2mrc(d.ms);\n        }\n\n        // store the calculated size so hover can use it\n        d.mrc = r;\n\n        if(fns.selectedSizeFn) {\n            r = d.mrc = fns.selectedSizeFn(d);\n        }\n\n        // turn the symbol into a sanitized number\n        var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;\n\n        // save if this marker is open\n        // because that impacts how to handle colors\n        d.om = x % 200 >= 100;\n\n        var angle = getMarkerAngle(d, trace);\n        var standoff = getMarkerStandoff(d, trace);\n\n        sel.attr('d', makePointPath(x, r, angle, standoff));\n    }\n\n    var perPointGradient = false;\n    var fillColor, lineColor, lineWidth;\n\n    // 'so' is suspected outliers, for box plots\n    if(d.so) {\n        lineWidth = markerLine.outlierwidth;\n        lineColor = markerLine.outliercolor;\n        fillColor = marker.outliercolor;\n    } else {\n        var markerLineWidth = (markerLine || {}).width;\n\n        lineWidth = (\n            d.mlw + 1 ||\n            markerLineWidth + 1 ||\n            // TODO: we need the latter for legends... can we get rid of it?\n            (d.trace ? (d.trace.marker.line || {}).width : 0) + 1\n        ) - 1 || 0;\n\n        if('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc);\n        // weird case: array wasn't long enough to apply to every point\n        else if(Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;\n        else lineColor = markerLine.color;\n\n        if(Lib.isArrayOrTypedArray(marker.color)) {\n            fillColor = Color.defaultLine;\n            perPointGradient = true;\n        }\n\n        if('mc' in d) {\n            fillColor = d.mcc = fns.markerScale(d.mc);\n        } else {\n            fillColor = marker.color || 'rgba(0,0,0,0)';\n        }\n\n        if(fns.selectedColorFn) {\n            fillColor = fns.selectedColorFn(d);\n        }\n    }\n\n    if(d.om) {\n        // open markers can't have zero linewidth, default to 1px,\n        // and use fill color as stroke color\n        sel.call(Color.stroke, fillColor)\n            .style({\n                'stroke-width': (lineWidth || 1) + 'px',\n                fill: 'none'\n            });\n    } else {\n        sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');\n\n        var markerGradient = marker.gradient;\n\n        var gradientType = d.mgt;\n        if(gradientType) perPointGradient = true;\n        else gradientType = markerGradient && markerGradient.type;\n\n        // for legend - arrays will propagate through here, but we don't need\n        // to treat it as per-point.\n        if(Lib.isArrayOrTypedArray(gradientType)) {\n            gradientType = gradientType[0];\n            if(!gradientInfo[gradientType]) gradientType = 0;\n        }\n\n        var markerPattern = marker.pattern;\n        var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, '');\n\n        if(gradientType && gradientType !== 'none') {\n            var gradientColor = d.mgc;\n            if(gradientColor) perPointGradient = true;\n            else gradientColor = markerGradient.color;\n\n            var gradientID = trace.uid;\n            if(perPointGradient) gradientID += '-' + d.i;\n\n            drawing.gradient(sel, gd, gradientID, gradientType,\n                [[0, gradientColor], [1, fillColor]], 'fill');\n        } else if(patternShape) {\n            var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);\n            var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, d.i, null);\n            var patternFGOpacity = markerPattern.fgopacity;\n            var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);\n            var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);\n            var perPointPattern = d.mcc ||\n                Lib.isArrayOrTypedArray(markerPattern.shape) ||\n                Lib.isArrayOrTypedArray(markerPattern.bgcolor) ||\n                Lib.isArrayOrTypedArray(markerPattern.size) ||\n                Lib.isArrayOrTypedArray(markerPattern.solidity);\n\n            var patternID = trace.uid;\n            if(perPointPattern) patternID += '-' + d.i;\n\n            drawing.pattern(\n                sel, 'point', gd, patternID,\n                patternShape, patternSize, patternSolidity,\n                d.mcc, markerPattern.fillmode,\n                patternBGColor, patternFGColor, patternFGOpacity\n            );\n        } else {\n            Color.fill(sel, fillColor);\n        }\n\n        if(lineWidth) {\n            Color.stroke(sel, lineColor);\n        }\n    }\n};\n\ndrawing.makePointStyleFns = function(trace) {\n    var out = {};\n    var marker = trace.marker;\n\n    // allow array marker and marker line colors to be\n    // scaled by given max and min to colorscales\n    out.markerScale = drawing.tryColorscale(marker, '');\n    out.lineScale = drawing.tryColorscale(marker, 'line');\n\n    if(Registry.traceIs(trace, 'symbols')) {\n        out.ms2mrc = subTypes.isBubble(trace) ?\n            makeBubbleSizeFn(trace) :\n            function() { return (marker.size || 6) / 2; };\n    }\n\n    if(trace.selectedpoints) {\n        Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));\n    }\n\n    return out;\n};\n\ndrawing.makeSelectedPointStyleFns = function(trace) {\n    var out = {};\n\n    var selectedAttrs = trace.selected || {};\n    var unselectedAttrs = trace.unselected || {};\n\n    var marker = trace.marker || {};\n    var selectedMarker = selectedAttrs.marker || {};\n    var unselectedMarker = unselectedAttrs.marker || {};\n\n    var mo = marker.opacity;\n    var smo = selectedMarker.opacity;\n    var usmo = unselectedMarker.opacity;\n    var smoIsDefined = smo !== undefined;\n    var usmoIsDefined = usmo !== undefined;\n\n    if(Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {\n        out.selectedOpacityFn = function(d) {\n            var base = d.mo === undefined ? marker.opacity : d.mo;\n\n            if(d.selected) {\n                return smoIsDefined ? smo : base;\n            } else {\n                return usmoIsDefined ? usmo : DESELECTDIM * base;\n            }\n        };\n    }\n\n    var mc = marker.color;\n    var smc = selectedMarker.color;\n    var usmc = unselectedMarker.color;\n\n    if(smc || usmc) {\n        out.selectedColorFn = function(d) {\n            var base = d.mcc || mc;\n\n            if(d.selected) {\n                return smc || base;\n            } else {\n                return usmc || base;\n            }\n        };\n    }\n\n    var ms = marker.size;\n    var sms = selectedMarker.size;\n    var usms = unselectedMarker.size;\n    var smsIsDefined = sms !== undefined;\n    var usmsIsDefined = usms !== undefined;\n\n    if(Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {\n        out.selectedSizeFn = function(d) {\n            var base = d.mrc || ms / 2;\n\n            if(d.selected) {\n                return smsIsDefined ? sms / 2 : base;\n            } else {\n                return usmsIsDefined ? usms / 2 : base;\n            }\n        };\n    }\n\n    return out;\n};\n\ndrawing.makeSelectedTextStyleFns = function(trace) {\n    var out = {};\n\n    var selectedAttrs = trace.selected || {};\n    var unselectedAttrs = trace.unselected || {};\n\n    var textFont = trace.textfont || {};\n    var selectedTextFont = selectedAttrs.textfont || {};\n    var unselectedTextFont = unselectedAttrs.textfont || {};\n\n    var tc = textFont.color;\n    var stc = selectedTextFont.color;\n    var utc = unselectedTextFont.color;\n\n    out.selectedTextColorFn = function(d) {\n        var base = d.tc || tc;\n\n        if(d.selected) {\n            return stc || base;\n        } else {\n            if(utc) return utc;\n            else return stc ? base : Color.addOpacity(base, DESELECTDIM);\n        }\n    };\n\n    return out;\n};\n\ndrawing.selectedPointStyle = function(s, trace) {\n    if(!s.size() || !trace.selectedpoints) return;\n\n    var fns = drawing.makeSelectedPointStyleFns(trace);\n    var marker = trace.marker || {};\n    var seq = [];\n\n    if(fns.selectedOpacityFn) {\n        seq.push(function(pt, d) {\n            pt.style('opacity', fns.selectedOpacityFn(d));\n        });\n    }\n\n    if(fns.selectedColorFn) {\n        seq.push(function(pt, d) {\n            Color.fill(pt, fns.selectedColorFn(d));\n        });\n    }\n\n    if(fns.selectedSizeFn) {\n        seq.push(function(pt, d) {\n            var mx = d.mx || marker.symbol || 0;\n            var mrc2 = fns.selectedSizeFn(d);\n\n            pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));\n\n            // save for Drawing.selectedTextStyle\n            d.mrc2 = mrc2;\n        });\n    }\n\n    if(seq.length) {\n        s.each(function(d) {\n            var pt = d3.select(this);\n            for(var i = 0; i < seq.length; i++) {\n                seq[i](pt, d);\n            }\n        });\n    }\n};\n\ndrawing.tryColorscale = function(marker, prefix) {\n    var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;\n\n    if(cont) {\n        var colorArray = cont.color;\n        if((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {\n            return Colorscale.makeColorScaleFuncFromTrace(cont);\n        }\n    }\n    return Lib.identity;\n};\n\nvar TEXTOFFSETSIGN = {\n    start: 1, end: -1, middle: 0, bottom: 1, top: -1\n};\n\nfunction textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {\n    var group = d3.select(s.node().parentNode);\n\n    var v = textPosition.indexOf('top') !== -1 ?\n        'top' :\n        textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';\n    var h = textPosition.indexOf('left') !== -1 ?\n        'end' :\n        textPosition.indexOf('right') !== -1 ? 'start' : 'middle';\n\n    // if markers are shown, offset a little more than\n    // the nominal marker size\n    // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n    var r = markerRadius ? markerRadius / 0.8 + 1 : 0;\n\n    var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;\n    var dx = TEXTOFFSETSIGN[h] * r;\n    var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r +\n        (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;\n\n    // fix the overall text group position\n    s.attr('text-anchor', h);\n    if(!dontTouchParent) {\n        group.attr('transform', strTranslate(dx, dy));\n    }\n}\n\nfunction extracTextFontSize(d, trace) {\n    var fontSize = d.ts || trace.textfont.size;\n    return (isNumeric(fontSize) && fontSize > 0) ? fontSize : 0;\n}\n\n// draw text at points\ndrawing.textPointStyle = function(s, trace, gd) {\n    if(!s.size()) return;\n\n    var selectedTextColorFn;\n    if(trace.selectedpoints) {\n        var fns = drawing.makeSelectedTextStyleFns(trace);\n        selectedTextColorFn = fns.selectedTextColorFn;\n    }\n\n    var texttemplate = trace.texttemplate;\n    var fullLayout = gd._fullLayout;\n\n    s.each(function(d) {\n        var p = d3.select(this);\n\n        var text = texttemplate ?\n            Lib.extractOption(d, trace, 'txt', 'texttemplate') :\n            Lib.extractOption(d, trace, 'tx', 'text');\n\n        if(!text && text !== 0) {\n            p.remove();\n            return;\n        }\n\n        if(texttemplate) {\n            var fn = trace._module.formatLabels;\n            var labels = fn ? fn(d, trace, fullLayout) : {};\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, d.i);\n            var meta = trace._meta || {};\n            text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);\n        }\n\n        var pos = d.tp || trace.textposition;\n        var fontSize = extracTextFontSize(d, trace);\n        var fontColor = selectedTextColorFn ?\n            selectedTextColorFn(d) :\n            (d.tc || trace.textfont.color);\n\n        p.call(drawing.font,\n                d.tf || trace.textfont.family,\n                fontSize,\n                fontColor)\n            .text(text)\n            .call(svgTextUtils.convertToTspans, gd)\n            .call(textPointPosition, pos, fontSize, d.mrc);\n    });\n};\n\ndrawing.selectedTextStyle = function(s, trace) {\n    if(!s.size() || !trace.selectedpoints) return;\n\n    var fns = drawing.makeSelectedTextStyleFns(trace);\n\n    s.each(function(d) {\n        var tx = d3.select(this);\n        var tc = fns.selectedTextColorFn(d);\n        var tp = d.tp || trace.textposition;\n        var fontSize = extracTextFontSize(d, trace);\n\n        Color.fill(tx, tc);\n        var dontTouchParent = Registry.traceIs(trace, 'bar-like');\n        textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);\n    });\n};\n\n// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp = 0.5;\ndrawing.smoothopen = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L');}\n    var path = 'M' + pts[0];\n    var tangents = [];\n    var i;\n    for(i = 1; i < pts.length - 1; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    path += 'Q' + tangents[0][0] + ' ' + pts[1];\n    for(i = 2; i < pts.length - 1; i++) {\n        path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n    }\n    path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n    return path;\n};\n\ndrawing.smoothclosed = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L') + 'Z'; }\n    var path = 'M' + pts[0];\n    var pLast = pts.length - 1;\n    var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];\n    var i;\n    for(i = 1; i < pLast; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    tangents.push(\n        makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness)\n    );\n\n    for(i = 1; i <= pLast; i++) {\n        path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n    }\n    path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n    return path;\n};\n\nvar lastDrawnX, lastDrawnY;\n\nfunction roundEnd(pt, isY, isLastPoint) {\n    if(isLastPoint) pt = applyBackoff(pt);\n\n    return isY ? roundY(pt[1]) : roundX(pt[0]);\n}\n\nfunction roundX(p) {\n    var v = d3.round(p, 2);\n    lastDrawnX = v;\n    return v;\n}\n\nfunction roundY(p) {\n    var v = d3.round(p, 2);\n    lastDrawnY = v;\n    return v;\n}\n\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n    var d1x = prevpt[0] - thispt[0];\n    var d1y = prevpt[1] - thispt[1];\n    var d2x = nextpt[0] - thispt[0];\n    var d2y = nextpt[1] - thispt[1];\n    var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);\n    var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);\n    var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;\n    var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;\n    var denom1 = 3 * d2a * (d1a + d2a);\n    var denom2 = 3 * d1a * (d1a + d2a);\n    return [\n        [\n            roundX(thispt[0] + (denom1 && numx / denom1)),\n            roundY(thispt[1] + (denom1 && numy / denom1))\n        ], [\n            roundX(thispt[0] - (denom2 && numx / denom2)),\n            roundY(thispt[1] - (denom2 && numy / denom2))\n        ]\n    ];\n}\n\n// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH = {\n    hv: function(p0, p1, isLastPoint) {\n        return 'H' +\n            roundX(p1[0]) + 'V' +\n            roundEnd(p1, 1, isLastPoint);\n    },\n    vh: function(p0, p1, isLastPoint) {\n        return 'V' +\n            roundY(p1[1]) + 'H' +\n            roundEnd(p1, 0, isLastPoint);\n    },\n    hvh: function(p0, p1, isLastPoint) {\n        return 'H' +\n            roundX((p0[0] + p1[0]) / 2) + 'V' +\n            roundY(p1[1]) + 'H' +\n            roundEnd(p1, 0, isLastPoint);\n    },\n    vhv: function(p0, p1, isLastPoint) {\n        return 'V' +\n            roundY((p0[1] + p1[1]) / 2) + 'H' +\n            roundX(p1[0]) + 'V' +\n            roundEnd(p1, 1, isLastPoint);\n    }\n};\nvar STEPLINEAR = function(p0, p1, isLastPoint) {\n    return 'L' +\n        roundEnd(p1, 0, isLastPoint) + ',' +\n        roundEnd(p1, 1, isLastPoint);\n};\ndrawing.steps = function(shape) {\n    var onestep = STEPPATH[shape] || STEPLINEAR;\n    return function(pts) {\n        var path = 'M' + roundX(pts[0][0]) + ',' + roundY(pts[0][1]);\n        var len = pts.length;\n        for(var i = 1; i < len; i++) {\n            path += onestep(pts[i - 1], pts[i], i === len - 1);\n        }\n        return path;\n    };\n};\n\nfunction applyBackoff(pt, start) {\n    var backoff = pt.backoff;\n    var trace = pt.trace;\n    var d = pt.d;\n    var i = pt.i;\n\n    if(backoff && trace &&\n        trace.marker &&\n        trace.marker.angle % 360 === 0 &&\n        trace.line &&\n        trace.line.shape !== 'spline'\n    ) {\n        var arrayBackoff = Lib.isArrayOrTypedArray(backoff);\n        var end = pt;\n\n        var x1 = start ? start[0] : lastDrawnX || 0;\n        var y1 = start ? start[1] : lastDrawnY || 0;\n\n        var x2 = end[0];\n        var y2 = end[1];\n\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n\n        var t = Math.atan2(dy, dx);\n\n        var b = arrayBackoff ? backoff[i] : backoff;\n\n        if(b === 'auto') {\n            var endI = end.i;\n            if(trace.type === 'scatter') endI--; // Why we need this hack?\n\n            var endMarker = end.marker;\n            var endMarkerSymbol = endMarker.symbol;\n            if(Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];\n\n            var endMarkerSize = endMarker.size;\n            if(Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];\n\n            b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;\n            b += drawing.getMarkerStandoff(d[endI], trace) || 0;\n        }\n\n        var x = x2 - b * Math.cos(t);\n        var y = y2 - b * Math.sin(t);\n\n        if(\n            ((x <= x2 && x >= x1) || (x >= x2 && x <= x1)) &&\n            ((y <= y2 && y >= y1) || (y >= y2 && y <= y1))\n        ) {\n            pt = [x, y];\n        }\n    }\n\n    return pt;\n}\n\ndrawing.applyBackoff = applyBackoff;\n\n// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\ndrawing.makeTester = function() {\n    var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function(s) {\n        s.attr(xmlnsNamespaces.svgAttrs)\n            .style({\n                position: 'absolute',\n                left: '-10000px',\n                top: '-10000px',\n                width: '9000px',\n                height: '9000px',\n                'z-index': '1'\n            });\n    });\n\n    // browsers differ on how they describe the bounding rect of\n    // the svg if its contents spill over... so make a 1x1px\n    // reference point we can measure off of.\n    var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function(s) {\n        s.attr('d', 'M0,0H1V1H0Z')\n            .style({\n                'stroke-width': 0,\n                fill: 'black'\n            });\n    });\n\n    drawing.tester = tester;\n    drawing.testref = testref;\n};\n\n/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */\ndrawing.savedBBoxes = {};\nvar savedBBoxesCount = 0;\nvar maxSavedBBoxes = 10000;\n\ndrawing.bBox = function(node, inTester, hash) {\n    /*\n     * Cache elements we've already measured so we don't have to\n     * remeasure the same thing many times\n     * We have a few bBox callers though who pass a node larger than\n     * a <text> or a MathJax <g>, such as an axis group containing many labels.\n     * These will not generate a hash (unless we figure out an appropriate\n     * hash key for them) and thus we will not hash them.\n     */\n    if(!hash) hash = nodeHash(node);\n    var out;\n    if(hash) {\n        out = drawing.savedBBoxes[hash];\n        if(out) return Lib.extendFlat({}, out);\n    } else if(node.childNodes.length === 1) {\n        /*\n         * If we have only one child element, which is itself hashable, make\n         * a new hash from this element plus its x,y,transform\n         * These bounding boxes *include* x,y,transform - mostly for use by\n         * callers trying to avoid overlaps (ie titles)\n         */\n        var innerNode = node.childNodes[0];\n\n        hash = nodeHash(innerNode);\n        if(hash) {\n            var x = +innerNode.getAttribute('x') || 0;\n            var y = +innerNode.getAttribute('y') || 0;\n            var transform = innerNode.getAttribute('transform');\n\n            if(!transform) {\n                // in this case, just varying x and y, don't bother caching\n                // the final bBox because the alteration is quick.\n                var innerBB = drawing.bBox(innerNode, false, hash);\n                if(x) {\n                    innerBB.left += x;\n                    innerBB.right += x;\n                }\n                if(y) {\n                    innerBB.top += y;\n                    innerBB.bottom += y;\n                }\n                return innerBB;\n            }\n            /*\n             * else we have a transform - rather than make a complicated\n             * (and error-prone and probably slow) transform parser/calculator,\n             * just continue on calculating the boundingClientRect of the group\n             * and use the new composite hash to cache it.\n             * That said, `innerNode.transform.baseVal` is an array of\n             * `SVGTransform` objects, that *do* seem to have a nice matrix\n             * multiplication interface that we could use to avoid making\n             * another getBoundingClientRect call...\n             */\n            hash += '~' + x + '~' + y + '~' + transform;\n\n            out = drawing.savedBBoxes[hash];\n            if(out) return Lib.extendFlat({}, out);\n        }\n    }\n    var testNode, tester;\n    if(inTester) {\n        testNode = node;\n    } else {\n        tester = drawing.tester.node();\n\n        // copy the node to test into the tester\n        testNode = node.cloneNode(true);\n        tester.appendChild(testNode);\n    }\n\n    // standardize its position (and newline tspans if any)\n    d3.select(testNode)\n        .attr('transform', null)\n        .call(svgTextUtils.positionText, 0, 0);\n\n    var testRect = testNode.getBoundingClientRect();\n    var refRect = drawing.testref\n        .node()\n        .getBoundingClientRect();\n\n    if(!inTester) tester.removeChild(testNode);\n\n    var bb = {\n        height: testRect.height,\n        width: testRect.width,\n        left: testRect.left - refRect.left,\n        top: testRect.top - refRect.top,\n        right: testRect.right - refRect.left,\n        bottom: testRect.bottom - refRect.top\n    };\n\n    // make sure we don't have too many saved boxes,\n    // or a long session could overload on memory\n    // by saving boxes for long-gone elements\n    if(savedBBoxesCount >= maxSavedBBoxes) {\n        drawing.savedBBoxes = {};\n        savedBBoxesCount = 0;\n    }\n\n    // cache this bbox\n    if(hash) drawing.savedBBoxes[hash] = bb;\n    savedBBoxesCount++;\n\n    return Lib.extendFlat({}, bb);\n};\n\n// capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\nfunction nodeHash(node) {\n    var inputText = node.getAttribute('data-unformatted');\n    if(inputText === null) return;\n    return inputText +\n        node.getAttribute('data-math') +\n        node.getAttribute('text-anchor') +\n        node.getAttribute('style');\n}\n\n/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */\ndrawing.setClipUrl = function(s, localId, gd) {\n    s.attr('clip-path', getFullUrl(localId, gd));\n};\n\nfunction getFullUrl(localId, gd) {\n    if(!localId) return null;\n\n    var context = gd._context;\n    var baseUrl = context._exportedPlot ? '' : (context._baseUrl || '');\n    return baseUrl ?\n        'url(\\'' + baseUrl + '#' + localId + '\\')' :\n        'url(#' + localId + ')';\n}\n\ndrawing.getTranslate = function(element) {\n    // Note the separator [^\\d] between x and y in this regex\n    // We generally use ',' but IE will convert it to ' '\n    var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 0,\n        y: +translate[1] || 0\n    };\n};\n\ndrawing.setTranslate = function(element, x, y) {\n    var re = /(\\btranslate\\(.*?\\);?)/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var setter = element.attr ? 'attr' : 'setAttribute';\n    var transform = element[getter]('transform') || '';\n\n    x = x || 0;\n    y = y || 0;\n\n    transform = transform.replace(re, '').trim();\n    transform += strTranslate(x, y);\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\ndrawing.getScale = function(element) {\n    var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 1,\n        y: +translate[1] || 1\n    };\n};\n\ndrawing.setScale = function(element, x, y) {\n    var re = /(\\bscale\\(.*?\\);?)/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var setter = element.attr ? 'attr' : 'setAttribute';\n    var transform = element[getter]('transform') || '';\n\n    x = x || 1;\n    y = y || 1;\n\n    transform = transform.replace(re, '').trim();\n    transform += 'scale(' + x + ',' + y + ')';\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\nvar SCALE_RE = /\\s*sc.*/;\n\ndrawing.setPointGroupScale = function(selection, xScale, yScale) {\n    xScale = xScale || 1;\n    yScale = yScale || 1;\n\n    if(!selection) return;\n\n    // The same scale transform for every point:\n    var scale = (xScale === 1 && yScale === 1) ?\n        '' :\n        'scale(' + xScale + ',' + yScale + ')';\n\n    selection.each(function() {\n        var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');\n        t += scale;\n        t = t.trim();\n        this.setAttribute('transform', t);\n    });\n};\n\nvar TEXT_POINT_LAST_TRANSLATION_RE = /translate\\([^)]*\\)\\s*$/;\n\ndrawing.setTextPointsScale = function(selection, xScale, yScale) {\n    if(!selection) return;\n\n    selection.each(function() {\n        var transforms;\n        var el = d3.select(this);\n        var text = el.select('text');\n\n        if(!text.node()) return;\n\n        var x = parseFloat(text.attr('x') || 0);\n        var y = parseFloat(text.attr('y') || 0);\n\n        var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);\n\n        if(xScale === 1 && yScale === 1) {\n            transforms = [];\n        } else {\n            transforms = [\n                strTranslate(x, y),\n                'scale(' + xScale + ',' + yScale + ')',\n                strTranslate(-x, -y),\n            ];\n        }\n\n        if(existingTransform) {\n            transforms.push(existingTransform);\n        }\n\n        el.attr('transform', transforms.join(''));\n    });\n};\n\nfunction getMarkerStandoff(d, trace) {\n    var standoff;\n\n    if(d) standoff = d.mf;\n\n    if(standoff === undefined) {\n        standoff = trace.marker ? trace.marker.standoff || 0 : 0;\n    }\n\n    if(!trace._geo && !trace._xA) {\n        // case of legends\n        return -standoff;\n    }\n\n    return standoff;\n}\n\ndrawing.getMarkerStandoff = getMarkerStandoff;\n\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar sin = Math.sin;\n\nfunction rotate(t, xy) {\n    var x = xy[0];\n    var y = xy[1];\n    return [\n        x * cos(t) - y * sin(t),\n        x * sin(t) + y * cos(t)\n    ];\n}\n\nvar previousLon;\nvar previousLat;\nvar previousX;\nvar previousY;\nvar previousI;\nvar previousTraceUid;\n\nfunction getMarkerAngle(d, trace) {\n    var angle = d.ma;\n\n    if(angle === undefined) {\n        angle = trace.marker.angle || 0;\n    }\n\n    var x, y;\n    var ref = trace.marker.angleref;\n    if(ref === 'previous' || ref === 'north') {\n        if(trace._geo) {\n            var p = trace._geo.project(d.lonlat);\n            x = p[0];\n            y = p[1];\n        } else {\n            var xa = trace._xA;\n            var ya = trace._yA;\n            if(xa && ya) {\n                x = xa.c2p(d.x);\n                y = ya.c2p(d.y);\n            } else {\n                // case of legends\n                return 90;\n            }\n        }\n\n        if(trace._geo) {\n            var lon = d.lonlat[0];\n            var lat = d.lonlat[1];\n\n            var north = trace._geo.project([\n                lon,\n                lat + 1e-5 // epsilon\n            ]);\n\n            var east = trace._geo.project([\n                lon + 1e-5, // epsilon\n                lat\n            ]);\n\n            var u = atan2(\n                east[1] - y,\n                east[0] - x\n            );\n\n            var v = atan2(\n                north[1] - y,\n                north[0] - x\n            );\n\n            var t;\n            if(ref === 'north') {\n                t = angle / 180 * Math.PI;\n                // To use counter-clockwise angles i.e.\n                // East: 90, West: -90\n                // to facilitate wind visualisations\n                // in future we should use t = -t here.\n            } else if(ref === 'previous') {\n                var lon1 = lon / 180 * Math.PI;\n                var lat1 = lat / 180 * Math.PI;\n                var lon2 = previousLon / 180 * Math.PI;\n                var lat2 = previousLat / 180 * Math.PI;\n\n                var dLon = lon2 - lon1;\n\n                var deltaY = cos(lat2) * sin(dLon);\n                var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);\n\n                t = -atan2(\n                    deltaY,\n                    deltaX\n                ) - Math.PI;\n\n                previousLon = lon;\n                previousLat = lat;\n            }\n\n            var A = rotate(u, [cos(t), 0]);\n            var B = rotate(v, [sin(t), 0]);\n\n            angle = atan2(\n                A[1] + B[1],\n                A[0] + B[0]\n            ) / Math.PI * 180;\n\n            if(ref === 'previous' && !(\n                previousTraceUid === trace.uid &&\n                d.i === previousI + 1\n            )) {\n                angle = null;\n            }\n        }\n\n        if(ref === 'previous' && !trace._geo) {\n            if(\n                previousTraceUid === trace.uid &&\n                d.i === previousI + 1 &&\n                isNumeric(x) &&\n                isNumeric(y)\n            ) {\n                var dX = x - previousX;\n                var dY = y - previousY;\n\n                var shape = trace.line ? trace.line.shape || '' : '';\n\n                var lastShapeChar = shape.slice(shape.length - 1);\n                if(lastShapeChar === 'h') dY = 0;\n                if(lastShapeChar === 'v') dX = 0;\n\n                angle += atan2(dY, dX) / Math.PI * 180 + 90;\n            } else {\n                angle = null;\n            }\n        }\n    }\n\n    previousX = x;\n    previousY = y;\n    previousI = d.i;\n    previousTraceUid = trace.uid;\n\n    return angle;\n}\n\ndrawing.getMarkerAngle = getMarkerAngle;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}