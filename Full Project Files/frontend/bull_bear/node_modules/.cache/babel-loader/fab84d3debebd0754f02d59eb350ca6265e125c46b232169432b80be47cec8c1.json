{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\nvar tinycolor = require('tinycolor2');\nvar Registry = require('../../registry');\nvar Drawing = require('../../components/drawing');\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar formatLabels = require('../scatter/format_labels');\nvar Color = require('../../components/color');\nvar extractOpts = require('../../components/colorscale').extractOpts;\nvar makeColorScaleFuncFromTrace = require('../../components/colorscale').makeColorScaleFuncFromTrace;\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignmentConstants = require('../../constants/alignment');\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar labelClass = 'heatmap-label';\nfunction selectLabels(plotGroup) {\n  return plotGroup.selectAll('g.' + labelClass);\n}\nfunction removeLabels(plotGroup) {\n  selectLabels(plotGroup).remove();\n}\nmodule.exports = function (gd, plotinfo, cdheatmaps, heatmapLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(heatmapLayer, cdheatmaps, 'hm').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var xGap = trace.xgap || 0;\n    var yGap = trace.ygap || 0;\n    var z = cd0.z;\n    var x = cd0.x;\n    var y = cd0.y;\n    var xc = cd0.xCenter;\n    var yc = cd0.yCenter;\n    var isContour = Registry.traceIs(trace, 'contour');\n    var zsmooth = isContour ? 'best' : trace.zsmooth;\n\n    // get z dims\n    var m = z.length;\n    var n = Lib.maxRowLength(z);\n    var xrev = false;\n    var yrev = false;\n    var left, right, temp, top, bottom, i, j, k;\n\n    // TODO: if there are multiple overlapping categorical heatmaps,\n    // or if we allow category sorting, then the categories may not be\n    // sequential... may need to reorder and/or expand z\n\n    // Get edges of png in pixels (xa.c2p() maps axes coordinates to pixel coordinates)\n    // figure out if either axis is reversed (y is usually reversed, in pixel coords)\n    // also clip the image to maximum 50% outside the visible plot area\n    // bigger image lets you pan more naturally, but slows performance.\n    // TODO: use low-resolution images outside the visible plot for panning\n    // these while loops find the first and last brick bounds that are defined\n    // (in case of log of a negative)\n    i = 0;\n    while (left === undefined && i < x.length - 1) {\n      left = xa.c2p(x[i]);\n      i++;\n    }\n    i = x.length - 1;\n    while (right === undefined && i > 0) {\n      right = xa.c2p(x[i]);\n      i--;\n    }\n    if (right < left) {\n      temp = right;\n      right = left;\n      left = temp;\n      xrev = true;\n    }\n    i = 0;\n    while (top === undefined && i < y.length - 1) {\n      top = ya.c2p(y[i]);\n      i++;\n    }\n    i = y.length - 1;\n    while (bottom === undefined && i > 0) {\n      bottom = ya.c2p(y[i]);\n      i--;\n    }\n    if (bottom < top) {\n      temp = top;\n      top = bottom;\n      bottom = temp;\n      yrev = true;\n    }\n\n    // for contours with heatmap fill, we generate the boundaries based on\n    // brick centers but then use the brick edges for drawing the bricks\n    if (isContour) {\n      xc = x;\n      yc = y;\n      x = cd0.xfill;\n      y = cd0.yfill;\n    }\n\n    // make an image that goes at most half a screen off either side, to keep\n    // time reasonable when you zoom in. if zsmooth is true/fast, don't worry\n    // about this, because zooming doesn't increase number of pixels\n    // if zsmooth is best, don't include anything off screen because it takes too long\n    if (zsmooth !== 'fast') {\n      var extra = zsmooth === 'best' ? 0 : 0.5;\n      left = Math.max(-extra * xa._length, left);\n      right = Math.min((1 + extra) * xa._length, right);\n      top = Math.max(-extra * ya._length, top);\n      bottom = Math.min((1 + extra) * ya._length, bottom);\n    }\n    var imageWidth = Math.round(right - left);\n    var imageHeight = Math.round(bottom - top);\n\n    // setup image nodes\n\n    // if image is entirely off-screen, don't even draw it\n    var isOffScreen = imageWidth <= 0 || imageHeight <= 0;\n    if (isOffScreen) {\n      var noImage = plotGroup.selectAll('image').data([]);\n      noImage.exit().remove();\n      removeLabels(plotGroup);\n      return;\n    }\n\n    // generate image data\n\n    var canvasW, canvasH;\n    if (zsmooth === 'fast') {\n      canvasW = n;\n      canvasH = m;\n    } else {\n      canvasW = imageWidth;\n      canvasH = imageHeight;\n    }\n    var canvas = document.createElement('canvas');\n    canvas.width = canvasW;\n    canvas.height = canvasH;\n    var context = canvas.getContext('2d');\n    var sclFunc = makeColorScaleFuncFromTrace(trace, {\n      noNumericCheck: true,\n      returnArray: true\n    });\n\n    // map brick boundaries to image pixels\n    var xpx, ypx;\n    if (zsmooth === 'fast') {\n      xpx = xrev ? function (index) {\n        return n - 1 - index;\n      } : Lib.identity;\n      ypx = yrev ? function (index) {\n        return m - 1 - index;\n      } : Lib.identity;\n    } else {\n      xpx = function (index) {\n        return Lib.constrain(Math.round(xa.c2p(x[index]) - left), 0, imageWidth);\n      };\n      ypx = function (index) {\n        return Lib.constrain(Math.round(ya.c2p(y[index]) - top), 0, imageHeight);\n      };\n    }\n\n    // build the pixel map brick-by-brick\n    // cruise through z-matrix row-by-row\n    // build a brick at each z-matrix value\n    var yi = ypx(0);\n    var yb = [yi, yi];\n    var xbi = xrev ? 0 : 1;\n    var ybi = yrev ? 0 : 1;\n    // for collecting an average luminosity of the heatmap\n    var pixcount = 0;\n    var rcount = 0;\n    var gcount = 0;\n    var bcount = 0;\n    var xb, xi, v, row, c;\n    function setColor(v, pixsize) {\n      if (v !== undefined) {\n        var c = sclFunc(v);\n        c[0] = Math.round(c[0]);\n        c[1] = Math.round(c[1]);\n        c[2] = Math.round(c[2]);\n        pixcount += pixsize;\n        rcount += c[0] * pixsize;\n        gcount += c[1] * pixsize;\n        bcount += c[2] * pixsize;\n        return c;\n      }\n      return [0, 0, 0, 0];\n    }\n    function interpColor(r0, r1, xinterp, yinterp) {\n      var z00 = r0[xinterp.bin0];\n      if (z00 === undefined) return setColor(undefined, 1);\n      var z01 = r0[xinterp.bin1];\n      var z10 = r1[xinterp.bin0];\n      var z11 = r1[xinterp.bin1];\n      var dx = z01 - z00 || 0;\n      var dy = z10 - z00 || 0;\n      var dxy;\n\n      // the bilinear interpolation term needs different calculations\n      // for all the different permutations of missing data\n      // among the neighbors of the main point, to ensure\n      // continuity across brick boundaries.\n      if (z01 === undefined) {\n        if (z11 === undefined) dxy = 0;else if (z10 === undefined) dxy = 2 * (z11 - z00);else dxy = (2 * z11 - z10 - z00) * 2 / 3;\n      } else if (z11 === undefined) {\n        if (z10 === undefined) dxy = 0;else dxy = (2 * z00 - z01 - z10) * 2 / 3;\n      } else if (z10 === undefined) dxy = (2 * z11 - z01 - z00) * 2 / 3;else dxy = z11 + z00 - z01 - z10;\n      return setColor(z00 + xinterp.frac * dx + yinterp.frac * (dy + xinterp.frac * dxy));\n    }\n    if (zsmooth) {\n      // best or fast, works fastest with imageData\n      var pxIndex = 0;\n      var pixels;\n      try {\n        pixels = new Uint8Array(imageWidth * imageHeight * 4);\n      } catch (e) {\n        pixels = new Array(imageWidth * imageHeight * 4);\n      }\n      if (zsmooth === 'best') {\n        var xForPx = xc || x;\n        var yForPx = yc || y;\n        var xPixArray = new Array(xForPx.length);\n        var yPixArray = new Array(yForPx.length);\n        var xinterpArray = new Array(imageWidth);\n        var findInterpX = xc ? findInterpFromCenters : findInterp;\n        var findInterpY = yc ? findInterpFromCenters : findInterp;\n        var yinterp, r0, r1;\n\n        // first make arrays of x and y pixel locations of brick boundaries\n        for (i = 0; i < xForPx.length; i++) xPixArray[i] = Math.round(xa.c2p(xForPx[i]) - left);\n        for (i = 0; i < yForPx.length; i++) yPixArray[i] = Math.round(ya.c2p(yForPx[i]) - top);\n\n        // then make arrays of interpolations\n        // (bin0=closest, bin1=next, frac=fractional dist.)\n        for (i = 0; i < imageWidth; i++) xinterpArray[i] = findInterpX(i, xPixArray);\n\n        // now do the interpolations and fill the png\n        for (j = 0; j < imageHeight; j++) {\n          yinterp = findInterpY(j, yPixArray);\n          r0 = z[yinterp.bin0];\n          r1 = z[yinterp.bin1];\n          for (i = 0; i < imageWidth; i++, pxIndex += 4) {\n            c = interpColor(r0, r1, xinterpArray[i], yinterp);\n            putColor(pixels, pxIndex, c);\n          }\n        }\n      } else {\n        // zsmooth = fast\n        for (j = 0; j < m; j++) {\n          row = z[j];\n          yb = ypx(j);\n          for (i = 0; i < imageWidth; i++) {\n            c = setColor(row[i], 1);\n            pxIndex = (yb * imageWidth + xpx(i)) * 4;\n            putColor(pixels, pxIndex, c);\n          }\n        }\n      }\n      var imageData = context.createImageData(imageWidth, imageHeight);\n      try {\n        imageData.data.set(pixels);\n      } catch (e) {\n        var pxArray = imageData.data;\n        var dlen = pxArray.length;\n        for (j = 0; j < dlen; j++) {\n          pxArray[j] = pixels[j];\n        }\n      }\n      context.putImageData(imageData, 0, 0);\n    } else {\n      // zsmooth = false -> filling potentially large bricks works fastest with fillRect\n      // gaps do not need to be exact integers, but if they *are* we will get\n      // cleaner edges by rounding at least one edge\n      var xGapLeft = Math.floor(xGap / 2);\n      var yGapTop = Math.floor(yGap / 2);\n      for (j = 0; j < m; j++) {\n        row = z[j];\n        yb.reverse();\n        yb[ybi] = ypx(j + 1);\n        if (yb[0] === yb[1] || yb[0] === undefined || yb[1] === undefined) {\n          continue;\n        }\n        xi = xpx(0);\n        xb = [xi, xi];\n        for (i = 0; i < n; i++) {\n          // build one color brick!\n          xb.reverse();\n          xb[xbi] = xpx(i + 1);\n          if (xb[0] === xb[1] || xb[0] === undefined || xb[1] === undefined) {\n            continue;\n          }\n          v = row[i];\n          c = setColor(v, (xb[1] - xb[0]) * (yb[1] - yb[0]));\n          context.fillStyle = 'rgba(' + c.join(',') + ')';\n          context.fillRect(xb[0] + xGapLeft, yb[0] + yGapTop, xb[1] - xb[0] - xGap, yb[1] - yb[0] - yGap);\n        }\n      }\n    }\n    rcount = Math.round(rcount / pixcount);\n    gcount = Math.round(gcount / pixcount);\n    bcount = Math.round(bcount / pixcount);\n    var avgColor = tinycolor('rgb(' + rcount + ',' + gcount + ',' + bcount + ')');\n    gd._hmpixcount = (gd._hmpixcount || 0) + pixcount;\n    gd._hmlumcount = (gd._hmlumcount || 0) + pixcount * avgColor.getLuminance();\n    var image3 = plotGroup.selectAll('image').data(cd);\n    image3.enter().append('svg:image').attr({\n      xmlns: xmlnsNamespaces.svg,\n      preserveAspectRatio: 'none'\n    });\n    image3.attr({\n      height: imageHeight,\n      width: imageWidth,\n      x: left,\n      y: top,\n      'xlink:href': canvas.toDataURL('image/png')\n    });\n    removeLabels(plotGroup);\n    var texttemplate = trace.texttemplate;\n    if (texttemplate) {\n      // dummy axis for formatting the z value\n      var cOpts = extractOpts(trace);\n      var dummyAx = {\n        type: 'linear',\n        range: [cOpts.min, cOpts.max],\n        _separators: xa._separators,\n        _numFormat: xa._numFormat\n      };\n      var aHistogram2dContour = trace.type === 'histogram2dcontour';\n      var aContour = trace.type === 'contour';\n      var iStart = aContour ? 1 : 0;\n      var iStop = aContour ? m - 1 : m;\n      var jStart = aContour ? 1 : 0;\n      var jStop = aContour ? n - 1 : n;\n      var textData = [];\n      for (i = iStart; i < iStop; i++) {\n        var yVal;\n        if (aContour) {\n          yVal = cd0.y[i];\n        } else if (aHistogram2dContour) {\n          if (i === 0 || i === m - 1) continue;\n          yVal = cd0.y[i];\n        } else if (cd0.yCenter) {\n          yVal = cd0.yCenter[i];\n        } else {\n          if (i + 1 === m && cd0.y[i + 1] === undefined) continue;\n          yVal = (cd0.y[i] + cd0.y[i + 1]) / 2;\n        }\n        var _y = Math.round(ya.c2p(yVal));\n        if (0 > _y || _y > ya._length) continue;\n        for (j = jStart; j < jStop; j++) {\n          var xVal;\n          if (aContour) {\n            xVal = cd0.x[j];\n          } else if (aHistogram2dContour) {\n            if (j === 0 || j === n - 1) continue;\n            xVal = cd0.x[j];\n          } else if (cd0.xCenter) {\n            xVal = cd0.xCenter[j];\n          } else {\n            if (j + 1 === n && cd0.x[j + 1] === undefined) continue;\n            xVal = (cd0.x[j] + cd0.x[j + 1]) / 2;\n          }\n          var _x = Math.round(xa.c2p(xVal));\n          if (0 > _x || _x > xa._length) continue;\n          var obj = formatLabels({\n            x: xVal,\n            y: yVal\n          }, trace, gd._fullLayout);\n          obj.x = xVal;\n          obj.y = yVal;\n          var zVal = cd0.z[i][j];\n          if (zVal === undefined) {\n            obj.z = '';\n            obj.zLabel = '';\n          } else {\n            obj.z = zVal;\n            obj.zLabel = Axes.tickText(dummyAx, zVal, 'hover').text;\n          }\n          var theText = cd0.text && cd0.text[i] && cd0.text[i][j];\n          if (theText === undefined || theText === false) theText = '';\n          obj.text = theText;\n          var _t = Lib.texttemplateString(texttemplate, obj, gd._fullLayout._d3locale, obj, trace._meta || {});\n          if (!_t) continue;\n          var lines = _t.split('<br>');\n          var nL = lines.length;\n          var nC = 0;\n          for (k = 0; k < nL; k++) {\n            nC = Math.max(nC, lines[k].length);\n          }\n          textData.push({\n            l: nL,\n            // number of lines\n            c: nC,\n            // maximum number of chars in a line\n            t: _t,\n            // text\n            x: _x,\n            y: _y,\n            z: zVal\n          });\n        }\n      }\n      var font = trace.textfont;\n      var fontFamily = font.family;\n      var fontSize = font.size;\n      var globalFontSize = gd._fullLayout.font.size;\n      if (!fontSize || fontSize === 'auto') {\n        var minW = Infinity;\n        var minH = Infinity;\n        var maxL = 0;\n        var maxC = 0;\n        for (k = 0; k < textData.length; k++) {\n          var d = textData[k];\n          maxL = Math.max(maxL, d.l);\n          maxC = Math.max(maxC, d.c);\n          if (k < textData.length - 1) {\n            var nextD = textData[k + 1];\n            var dx = Math.abs(nextD.x - d.x);\n            var dy = Math.abs(nextD.y - d.y);\n            if (dx) minW = Math.min(minW, dx);\n            if (dy) minH = Math.min(minH, dy);\n          }\n        }\n        if (!isFinite(minW) || !isFinite(minH)) {\n          fontSize = globalFontSize;\n        } else {\n          minW -= xGap;\n          minH -= yGap;\n          minW /= maxC;\n          minH /= maxL;\n          minW /= LINE_SPACING / 2;\n          minH /= LINE_SPACING;\n          fontSize = Math.min(Math.floor(minW), Math.floor(minH), globalFontSize);\n        }\n      }\n      if (fontSize <= 0 || !isFinite(fontSize)) return;\n      var xFn = function (d) {\n        return d.x;\n      };\n      var yFn = function (d) {\n        return d.y - fontSize * (d.l * LINE_SPACING / 2 - 1);\n      };\n      var labels = selectLabels(plotGroup).data(textData);\n      labels.enter().append('g').classed(labelClass, 1).append('text').attr('text-anchor', 'middle').each(function (d) {\n        var thisLabel = d3.select(this);\n        var fontColor = font.color;\n        if (!fontColor || fontColor === 'auto') {\n          fontColor = Color.contrast('rgba(' + sclFunc(d.z).join() + ')');\n        }\n        thisLabel.attr('data-notex', 1).call(svgTextUtils.positionText, xFn(d), yFn(d)).call(Drawing.font, fontFamily, fontSize, fontColor).text(d.t).call(svgTextUtils.convertToTspans, gd);\n      });\n    }\n  });\n};\n\n// get interpolated bin value. Returns {bin0:closest bin, frac:fractional dist to next, bin1:next bin}\nfunction findInterp(pixel, pixArray) {\n  var maxBin = pixArray.length - 2;\n  var bin = Lib.constrain(Lib.findBin(pixel, pixArray), 0, maxBin);\n  var pix0 = pixArray[bin];\n  var pix1 = pixArray[bin + 1];\n  var interp = Lib.constrain(bin + (pixel - pix0) / (pix1 - pix0) - 0.5, 0, maxBin);\n  var bin0 = Math.round(interp);\n  var frac = Math.abs(interp - bin0);\n  if (!interp || interp === maxBin || !frac) {\n    return {\n      bin0: bin0,\n      bin1: bin0,\n      frac: 0\n    };\n  }\n  return {\n    bin0: bin0,\n    frac: frac,\n    bin1: Math.round(bin0 + frac / (interp - bin0))\n  };\n}\nfunction findInterpFromCenters(pixel, centerPixArray) {\n  var maxBin = centerPixArray.length - 1;\n  var bin = Lib.constrain(Lib.findBin(pixel, centerPixArray), 0, maxBin);\n  var pix0 = centerPixArray[bin];\n  var pix1 = centerPixArray[bin + 1];\n  var frac = (pixel - pix0) / (pix1 - pix0) || 0;\n  if (frac <= 0) {\n    return {\n      bin0: bin,\n      bin1: bin,\n      frac: 0\n    };\n  }\n  if (frac < 0.5) {\n    return {\n      bin0: bin,\n      bin1: bin + 1,\n      frac: frac\n    };\n  }\n  return {\n    bin0: bin + 1,\n    bin1: bin,\n    frac: 1 - frac\n  };\n}\nfunction putColor(pixels, pxIndex, c) {\n  pixels[pxIndex] = c[0];\n  pixels[pxIndex + 1] = c[1];\n  pixels[pxIndex + 2] = c[2];\n  pixels[pxIndex + 3] = Math.round(c[3] * 255);\n}","map":{"version":3,"names":["d3","require","tinycolor","Registry","Drawing","Axes","Lib","svgTextUtils","formatLabels","Color","extractOpts","makeColorScaleFuncFromTrace","xmlnsNamespaces","alignmentConstants","LINE_SPACING","labelClass","selectLabels","plotGroup","selectAll","removeLabels","remove","module","exports","gd","plotinfo","cdheatmaps","heatmapLayer","xa","xaxis","ya","yaxis","makeTraceGroups","each","cd","select","cd0","trace","xGap","xgap","yGap","ygap","z","x","y","xc","xCenter","yc","yCenter","isContour","traceIs","zsmooth","m","length","n","maxRowLength","xrev","yrev","left","right","temp","top","bottom","i","j","k","undefined","c2p","xfill","yfill","extra","Math","max","_length","min","imageWidth","round","imageHeight","isOffScreen","noImage","data","exit","canvasW","canvasH","canvas","document","createElement","width","height","context","getContext","sclFunc","noNumericCheck","returnArray","xpx","ypx","index","identity","constrain","yi","yb","xbi","ybi","pixcount","rcount","gcount","bcount","xb","xi","v","row","c","setColor","pixsize","interpColor","r0","r1","xinterp","yinterp","z00","bin0","z01","bin1","z10","z11","dx","dy","dxy","frac","pxIndex","pixels","Uint8Array","e","Array","xForPx","yForPx","xPixArray","yPixArray","xinterpArray","findInterpX","findInterpFromCenters","findInterp","findInterpY","putColor","imageData","createImageData","set","pxArray","dlen","putImageData","xGapLeft","floor","yGapTop","reverse","fillStyle","join","fillRect","avgColor","_hmpixcount","_hmlumcount","getLuminance","image3","enter","append","attr","xmlns","svg","preserveAspectRatio","toDataURL","texttemplate","cOpts","dummyAx","type","range","_separators","_numFormat","aHistogram2dContour","aContour","iStart","iStop","jStart","jStop","textData","yVal","_y","xVal","_x","obj","_fullLayout","zVal","zLabel","tickText","text","theText","_t","texttemplateString","_d3locale","_meta","lines","split","nL","nC","push","l","t","font","textfont","fontFamily","family","fontSize","size","globalFontSize","minW","Infinity","minH","maxL","maxC","d","nextD","abs","isFinite","xFn","yFn","labels","classed","thisLabel","fontColor","color","contrast","call","positionText","convertToTspans","pixel","pixArray","maxBin","bin","findBin","pix0","pix1","interp","centerPixArray"],"sources":["/Users/lordvoldemort/django_react/second_attempt/frontend/bull_bear/node_modules/plotly.js/src/traces/heatmap/plot.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Drawing = require('../../components/drawing');\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar formatLabels = require('../scatter/format_labels');\nvar Color = require('../../components/color');\nvar extractOpts = require('../../components/colorscale').extractOpts;\nvar makeColorScaleFuncFromTrace = require('../../components/colorscale').makeColorScaleFuncFromTrace;\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignmentConstants = require('../../constants/alignment');\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\n\nvar labelClass = 'heatmap-label';\n\nfunction selectLabels(plotGroup) {\n    return plotGroup.selectAll('g.' + labelClass);\n}\n\nfunction removeLabels(plotGroup) {\n    selectLabels(plotGroup).remove();\n}\n\nmodule.exports = function(gd, plotinfo, cdheatmaps, heatmapLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    Lib.makeTraceGroups(heatmapLayer, cdheatmaps, 'hm').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n        var xGap = trace.xgap || 0;\n        var yGap = trace.ygap || 0;\n\n        var z = cd0.z;\n        var x = cd0.x;\n        var y = cd0.y;\n        var xc = cd0.xCenter;\n        var yc = cd0.yCenter;\n        var isContour = Registry.traceIs(trace, 'contour');\n        var zsmooth = isContour ? 'best' : trace.zsmooth;\n\n        // get z dims\n        var m = z.length;\n        var n = Lib.maxRowLength(z);\n        var xrev = false;\n        var yrev = false;\n\n        var left, right, temp, top, bottom, i, j, k;\n\n        // TODO: if there are multiple overlapping categorical heatmaps,\n        // or if we allow category sorting, then the categories may not be\n        // sequential... may need to reorder and/or expand z\n\n        // Get edges of png in pixels (xa.c2p() maps axes coordinates to pixel coordinates)\n        // figure out if either axis is reversed (y is usually reversed, in pixel coords)\n        // also clip the image to maximum 50% outside the visible plot area\n        // bigger image lets you pan more naturally, but slows performance.\n        // TODO: use low-resolution images outside the visible plot for panning\n        // these while loops find the first and last brick bounds that are defined\n        // (in case of log of a negative)\n        i = 0;\n        while(left === undefined && i < x.length - 1) {\n            left = xa.c2p(x[i]);\n            i++;\n        }\n        i = x.length - 1;\n        while(right === undefined && i > 0) {\n            right = xa.c2p(x[i]);\n            i--;\n        }\n\n        if(right < left) {\n            temp = right;\n            right = left;\n            left = temp;\n            xrev = true;\n        }\n\n        i = 0;\n        while(top === undefined && i < y.length - 1) {\n            top = ya.c2p(y[i]);\n            i++;\n        }\n        i = y.length - 1;\n        while(bottom === undefined && i > 0) {\n            bottom = ya.c2p(y[i]);\n            i--;\n        }\n\n        if(bottom < top) {\n            temp = top;\n            top = bottom;\n            bottom = temp;\n            yrev = true;\n        }\n\n        // for contours with heatmap fill, we generate the boundaries based on\n        // brick centers but then use the brick edges for drawing the bricks\n        if(isContour) {\n            xc = x;\n            yc = y;\n            x = cd0.xfill;\n            y = cd0.yfill;\n        }\n\n        // make an image that goes at most half a screen off either side, to keep\n        // time reasonable when you zoom in. if zsmooth is true/fast, don't worry\n        // about this, because zooming doesn't increase number of pixels\n        // if zsmooth is best, don't include anything off screen because it takes too long\n        if(zsmooth !== 'fast') {\n            var extra = zsmooth === 'best' ? 0 : 0.5;\n            left = Math.max(-extra * xa._length, left);\n            right = Math.min((1 + extra) * xa._length, right);\n            top = Math.max(-extra * ya._length, top);\n            bottom = Math.min((1 + extra) * ya._length, bottom);\n        }\n\n        var imageWidth = Math.round(right - left);\n        var imageHeight = Math.round(bottom - top);\n\n        // setup image nodes\n\n        // if image is entirely off-screen, don't even draw it\n        var isOffScreen = (imageWidth <= 0 || imageHeight <= 0);\n\n        if(isOffScreen) {\n            var noImage = plotGroup.selectAll('image').data([]);\n            noImage.exit().remove();\n\n            removeLabels(plotGroup);\n            return;\n        }\n\n        // generate image data\n\n        var canvasW, canvasH;\n        if(zsmooth === 'fast') {\n            canvasW = n;\n            canvasH = m;\n        } else {\n            canvasW = imageWidth;\n            canvasH = imageHeight;\n        }\n\n        var canvas = document.createElement('canvas');\n        canvas.width = canvasW;\n        canvas.height = canvasH;\n        var context = canvas.getContext('2d');\n\n        var sclFunc = makeColorScaleFuncFromTrace(trace, {noNumericCheck: true, returnArray: true});\n\n        // map brick boundaries to image pixels\n        var xpx,\n            ypx;\n        if(zsmooth === 'fast') {\n            xpx = xrev ?\n                function(index) { return n - 1 - index; } :\n                Lib.identity;\n            ypx = yrev ?\n                function(index) { return m - 1 - index; } :\n                Lib.identity;\n        } else {\n            xpx = function(index) {\n                return Lib.constrain(Math.round(xa.c2p(x[index]) - left),\n                    0, imageWidth);\n            };\n            ypx = function(index) {\n                return Lib.constrain(Math.round(ya.c2p(y[index]) - top),\n                    0, imageHeight);\n            };\n        }\n\n        // build the pixel map brick-by-brick\n        // cruise through z-matrix row-by-row\n        // build a brick at each z-matrix value\n        var yi = ypx(0);\n        var yb = [yi, yi];\n        var xbi = xrev ? 0 : 1;\n        var ybi = yrev ? 0 : 1;\n        // for collecting an average luminosity of the heatmap\n        var pixcount = 0;\n        var rcount = 0;\n        var gcount = 0;\n        var bcount = 0;\n\n        var xb, xi, v, row, c;\n\n        function setColor(v, pixsize) {\n            if(v !== undefined) {\n                var c = sclFunc(v);\n                c[0] = Math.round(c[0]);\n                c[1] = Math.round(c[1]);\n                c[2] = Math.round(c[2]);\n\n                pixcount += pixsize;\n                rcount += c[0] * pixsize;\n                gcount += c[1] * pixsize;\n                bcount += c[2] * pixsize;\n                return c;\n            }\n            return [0, 0, 0, 0];\n        }\n\n        function interpColor(r0, r1, xinterp, yinterp) {\n            var z00 = r0[xinterp.bin0];\n            if(z00 === undefined) return setColor(undefined, 1);\n\n            var z01 = r0[xinterp.bin1];\n            var z10 = r1[xinterp.bin0];\n            var z11 = r1[xinterp.bin1];\n            var dx = (z01 - z00) || 0;\n            var dy = (z10 - z00) || 0;\n            var dxy;\n\n            // the bilinear interpolation term needs different calculations\n            // for all the different permutations of missing data\n            // among the neighbors of the main point, to ensure\n            // continuity across brick boundaries.\n            if(z01 === undefined) {\n                if(z11 === undefined) dxy = 0;\n                else if(z10 === undefined) dxy = 2 * (z11 - z00);\n                else dxy = (2 * z11 - z10 - z00) * 2 / 3;\n            } else if(z11 === undefined) {\n                if(z10 === undefined) dxy = 0;\n                else dxy = (2 * z00 - z01 - z10) * 2 / 3;\n            } else if(z10 === undefined) dxy = (2 * z11 - z01 - z00) * 2 / 3;\n            else dxy = (z11 + z00 - z01 - z10);\n\n            return setColor(z00 + xinterp.frac * dx + yinterp.frac * (dy + xinterp.frac * dxy));\n        }\n\n        if(zsmooth) { // best or fast, works fastest with imageData\n            var pxIndex = 0;\n            var pixels;\n\n            try {\n                pixels = new Uint8Array(imageWidth * imageHeight * 4);\n            } catch(e) {\n                pixels = new Array(imageWidth * imageHeight * 4);\n            }\n\n            if(zsmooth === 'best') {\n                var xForPx = xc || x;\n                var yForPx = yc || y;\n                var xPixArray = new Array(xForPx.length);\n                var yPixArray = new Array(yForPx.length);\n                var xinterpArray = new Array(imageWidth);\n                var findInterpX = xc ? findInterpFromCenters : findInterp;\n                var findInterpY = yc ? findInterpFromCenters : findInterp;\n                var yinterp, r0, r1;\n\n                // first make arrays of x and y pixel locations of brick boundaries\n                for(i = 0; i < xForPx.length; i++) xPixArray[i] = Math.round(xa.c2p(xForPx[i]) - left);\n                for(i = 0; i < yForPx.length; i++) yPixArray[i] = Math.round(ya.c2p(yForPx[i]) - top);\n\n                // then make arrays of interpolations\n                // (bin0=closest, bin1=next, frac=fractional dist.)\n                for(i = 0; i < imageWidth; i++) xinterpArray[i] = findInterpX(i, xPixArray);\n\n                // now do the interpolations and fill the png\n                for(j = 0; j < imageHeight; j++) {\n                    yinterp = findInterpY(j, yPixArray);\n                    r0 = z[yinterp.bin0];\n                    r1 = z[yinterp.bin1];\n                    for(i = 0; i < imageWidth; i++, pxIndex += 4) {\n                        c = interpColor(r0, r1, xinterpArray[i], yinterp);\n                        putColor(pixels, pxIndex, c);\n                    }\n                }\n            } else { // zsmooth = fast\n                for(j = 0; j < m; j++) {\n                    row = z[j];\n                    yb = ypx(j);\n                    for(i = 0; i < imageWidth; i++) {\n                        c = setColor(row[i], 1);\n                        pxIndex = (yb * imageWidth + xpx(i)) * 4;\n                        putColor(pixels, pxIndex, c);\n                    }\n                }\n            }\n\n            var imageData = context.createImageData(imageWidth, imageHeight);\n            try {\n                imageData.data.set(pixels);\n            } catch(e) {\n                var pxArray = imageData.data;\n                var dlen = pxArray.length;\n                for(j = 0; j < dlen; j ++) {\n                    pxArray[j] = pixels[j];\n                }\n            }\n\n            context.putImageData(imageData, 0, 0);\n        } else { // zsmooth = false -> filling potentially large bricks works fastest with fillRect\n            // gaps do not need to be exact integers, but if they *are* we will get\n            // cleaner edges by rounding at least one edge\n            var xGapLeft = Math.floor(xGap / 2);\n            var yGapTop = Math.floor(yGap / 2);\n\n            for(j = 0; j < m; j++) {\n                row = z[j];\n                yb.reverse();\n                yb[ybi] = ypx(j + 1);\n                if(yb[0] === yb[1] || yb[0] === undefined || yb[1] === undefined) {\n                    continue;\n                }\n                xi = xpx(0);\n                xb = [xi, xi];\n                for(i = 0; i < n; i++) {\n                    // build one color brick!\n                    xb.reverse();\n                    xb[xbi] = xpx(i + 1);\n                    if(xb[0] === xb[1] || xb[0] === undefined || xb[1] === undefined) {\n                        continue;\n                    }\n                    v = row[i];\n                    c = setColor(v, (xb[1] - xb[0]) * (yb[1] - yb[0]));\n                    context.fillStyle = 'rgba(' + c.join(',') + ')';\n\n                    context.fillRect(xb[0] + xGapLeft, yb[0] + yGapTop,\n                        xb[1] - xb[0] - xGap, yb[1] - yb[0] - yGap);\n                }\n            }\n        }\n\n        rcount = Math.round(rcount / pixcount);\n        gcount = Math.round(gcount / pixcount);\n        bcount = Math.round(bcount / pixcount);\n        var avgColor = tinycolor('rgb(' + rcount + ',' + gcount + ',' + bcount + ')');\n\n        gd._hmpixcount = (gd._hmpixcount||0) + pixcount;\n        gd._hmlumcount = (gd._hmlumcount||0) + pixcount * avgColor.getLuminance();\n\n        var image3 = plotGroup.selectAll('image')\n            .data(cd);\n\n        image3.enter().append('svg:image').attr({\n            xmlns: xmlnsNamespaces.svg,\n            preserveAspectRatio: 'none'\n        });\n\n        image3.attr({\n            height: imageHeight,\n            width: imageWidth,\n            x: left,\n            y: top,\n            'xlink:href': canvas.toDataURL('image/png')\n        });\n\n        removeLabels(plotGroup);\n\n        var texttemplate = trace.texttemplate;\n        if(texttemplate) {\n            // dummy axis for formatting the z value\n            var cOpts = extractOpts(trace);\n            var dummyAx = {\n                type: 'linear',\n                range: [cOpts.min, cOpts.max],\n                _separators: xa._separators,\n                _numFormat: xa._numFormat\n            };\n\n            var aHistogram2dContour = trace.type === 'histogram2dcontour';\n            var aContour = trace.type === 'contour';\n            var iStart = aContour ? 1 : 0;\n            var iStop = aContour ? m - 1 : m;\n            var jStart = aContour ? 1 : 0;\n            var jStop = aContour ? n - 1 : n;\n\n            var textData = [];\n            for(i = iStart; i < iStop; i++) {\n                var yVal;\n                if(aContour) {\n                    yVal = cd0.y[i];\n                } else if(aHistogram2dContour) {\n                    if(i === 0 || i === m - 1) continue;\n                    yVal = cd0.y[i];\n                } else if(cd0.yCenter) {\n                    yVal = cd0.yCenter[i];\n                } else {\n                    if(i + 1 === m && cd0.y[i + 1] === undefined) continue;\n                    yVal = (cd0.y[i] + cd0.y[i + 1]) / 2;\n                }\n\n                var _y = Math.round(ya.c2p(yVal));\n                if(0 > _y || _y > ya._length) continue;\n\n                for(j = jStart; j < jStop; j++) {\n                    var xVal;\n                    if(aContour) {\n                        xVal = cd0.x[j];\n                    } else if(aHistogram2dContour) {\n                        if(j === 0 || j === n - 1) continue;\n                        xVal = cd0.x[j];\n                    } else if(cd0.xCenter) {\n                        xVal = cd0.xCenter[j];\n                    } else {\n                        if(j + 1 === n && cd0.x[j + 1] === undefined) continue;\n                        xVal = (cd0.x[j] + cd0.x[j + 1]) / 2;\n                    }\n\n                    var _x = Math.round(xa.c2p(xVal));\n                    if(0 > _x || _x > xa._length) continue;\n\n                    var obj = formatLabels({\n                        x: xVal,\n                        y: yVal\n                    }, trace, gd._fullLayout);\n\n                    obj.x = xVal;\n                    obj.y = yVal;\n\n                    var zVal = cd0.z[i][j];\n                    if(zVal === undefined) {\n                        obj.z = '';\n                        obj.zLabel = '';\n                    } else {\n                        obj.z = zVal;\n                        obj.zLabel = Axes.tickText(dummyAx, zVal, 'hover').text;\n                    }\n\n                    var theText = cd0.text && cd0.text[i] && cd0.text[i][j];\n                    if(theText === undefined || theText === false) theText = '';\n                    obj.text = theText;\n\n                    var _t = Lib.texttemplateString(texttemplate, obj, gd._fullLayout._d3locale, obj, trace._meta || {});\n                    if(!_t) continue;\n\n                    var lines = _t.split('<br>');\n                    var nL = lines.length;\n                    var nC = 0;\n                    for(k = 0; k < nL; k++) {\n                        nC = Math.max(nC, lines[k].length);\n                    }\n\n                    textData.push({\n                        l: nL, // number of lines\n                        c: nC, // maximum number of chars in a line\n                        t: _t, // text\n                        x: _x,\n                        y: _y,\n                        z: zVal\n                    });\n                }\n            }\n\n            var font = trace.textfont;\n            var fontFamily = font.family;\n            var fontSize = font.size;\n            var globalFontSize = gd._fullLayout.font.size;\n\n            if(!fontSize || fontSize === 'auto') {\n                var minW = Infinity;\n                var minH = Infinity;\n                var maxL = 0;\n                var maxC = 0;\n\n                for(k = 0; k < textData.length; k++) {\n                    var d = textData[k];\n                    maxL = Math.max(maxL, d.l);\n                    maxC = Math.max(maxC, d.c);\n\n                    if(k < textData.length - 1) {\n                        var nextD = textData[k + 1];\n                        var dx = Math.abs(nextD.x - d.x);\n                        var dy = Math.abs(nextD.y - d.y);\n\n                        if(dx) minW = Math.min(minW, dx);\n                        if(dy) minH = Math.min(minH, dy);\n                    }\n                }\n\n                if(\n                    !isFinite(minW) ||\n                    !isFinite(minH)\n                ) {\n                    fontSize = globalFontSize;\n                } else {\n                    minW -= xGap;\n                    minH -= yGap;\n\n                    minW /= maxC;\n                    minH /= maxL;\n\n                    minW /= LINE_SPACING / 2;\n                    minH /= LINE_SPACING;\n\n                    fontSize = Math.min(\n                        Math.floor(minW),\n                        Math.floor(minH),\n                        globalFontSize\n                    );\n                }\n            }\n            if(fontSize <= 0 || !isFinite(fontSize)) return;\n\n            var xFn = function(d) { return d.x; };\n            var yFn = function(d) {\n                return d.y - fontSize * ((d.l * LINE_SPACING) / 2 - 1);\n            };\n\n            var labels = selectLabels(plotGroup).data(textData);\n\n            labels\n                .enter()\n                .append('g')\n                .classed(labelClass, 1)\n                .append('text')\n                .attr('text-anchor', 'middle')\n                .each(function(d) {\n                    var thisLabel = d3.select(this);\n\n                    var fontColor = font.color;\n                    if(!fontColor || fontColor === 'auto') {\n                        fontColor = Color.contrast(\n                            'rgba(' +\n                                sclFunc(d.z).join() +\n                            ')'\n                        );\n                    }\n\n                    thisLabel\n                        .attr('data-notex', 1)\n                        .call(svgTextUtils.positionText, xFn(d), yFn(d))\n                        .call(Drawing.font, fontFamily, fontSize, fontColor)\n                        .text(d.t)\n                        .call(svgTextUtils.convertToTspans, gd);\n                });\n        }\n    });\n};\n\n// get interpolated bin value. Returns {bin0:closest bin, frac:fractional dist to next, bin1:next bin}\nfunction findInterp(pixel, pixArray) {\n    var maxBin = pixArray.length - 2;\n    var bin = Lib.constrain(Lib.findBin(pixel, pixArray), 0, maxBin);\n    var pix0 = pixArray[bin];\n    var pix1 = pixArray[bin + 1];\n    var interp = Lib.constrain(bin + (pixel - pix0) / (pix1 - pix0) - 0.5, 0, maxBin);\n    var bin0 = Math.round(interp);\n    var frac = Math.abs(interp - bin0);\n\n    if(!interp || interp === maxBin || !frac) {\n        return {\n            bin0: bin0,\n            bin1: bin0,\n            frac: 0\n        };\n    }\n    return {\n        bin0: bin0,\n        frac: frac,\n        bin1: Math.round(bin0 + frac / (interp - bin0))\n    };\n}\n\nfunction findInterpFromCenters(pixel, centerPixArray) {\n    var maxBin = centerPixArray.length - 1;\n    var bin = Lib.constrain(Lib.findBin(pixel, centerPixArray), 0, maxBin);\n    var pix0 = centerPixArray[bin];\n    var pix1 = centerPixArray[bin + 1];\n    var frac = ((pixel - pix0) / (pix1 - pix0)) || 0;\n    if(frac <= 0) {\n        return {\n            bin0: bin,\n            bin1: bin,\n            frac: 0\n        };\n    }\n    if(frac < 0.5) {\n        return {\n            bin0: bin,\n            bin1: bin + 1,\n            frac: frac\n        };\n    }\n    return {\n        bin0: bin + 1,\n        bin1: bin,\n        frac: 1 - frac\n    };\n}\n\nfunction putColor(pixels, pxIndex, c) {\n    pixels[pxIndex] = c[0];\n    pixels[pxIndex + 1] = c[1];\n    pixels[pxIndex + 2] = c[2];\n    pixels[pxIndex + 3] = Math.round(c[3] * 255);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}